{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#georeader","title":"georeader","text":"<p>georeader is a package to process raster data from different satellite missions. georeader makes easy to read specific areas of your image, to reproject images from different satellites to a common grid  (<code>georeader.read</code>), to go from vector to raster formats (<code>georeader.vectorize</code> and <code>georeader.rasterize</code>) or to do radiance to reflectance conversions (<code>georeader.reflectance</code>). </p> <p>georeader is mainly used to process satellite data for scientific usage, to create ML-ready datasets and to implement end-to-end operational inference pipelines (e.g. the Kherson Dam Break floodmap). See georeader concepts and protocols for basic concepts and API.</p>"},{"location":"#install","title":"Install","text":"<p>The core package dependencies are <code>numpy</code>, <code>rasterio</code>, <code>shapely</code> and <code>geopandas</code>.</p> <pre><code>pip install georeader-spaceml\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":"<p>Read from a Sentinel-2 image a fixed size subimage on an specific <code>lon,lat</code> location:</p> <p><pre><code>from georeader.rasterio_reader import RasterioReader\nfrom georeader import read\n\n# S2 image from WorldFloodsv2 dataset\ns2url = \"https://huggingface.co/datasets/isp-uv-es/WorldFloodsv2/resolve/main/test/S2/EMSR264_18MIANDRIVAZODETAIL_DEL_v2.tif\"\nrst = RasterioReader(s2url)\n\n# lazy loading bands\nrst_rgb = rst.isel({\"band\": [3, 2, 1]}) # 1-based list as in rasterio\n\ncords_read = (45.43, -19.53) # long, lat\ncrs_cords = \"EPSG:4326\"\n\n# See also read.read_from_bounds, read.read_from_polygon for different ways of croping an image\ndata = read.read_from_center_coords(rst_rgb,\n                                    cords_read, shape=(504, 1040),\n                                    crs_center_coords=crs_cords)\n\ndata_memory = data.load() # this loads the data to memory\n\ndata_memory # GeoTensor object\n</code></pre> <pre><code>&gt;&gt;  Transform: | 10.00, 0.00, 539910.00|\n| 0.00,-10.00, 7842990.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 504, 1040)\n         Resolution: (10.0, 10.0)\n         Bounds: (539910.0, 7837950.0, 550310.0, 7842990.0)\n         CRS: EPSG:32738\n         fill_value_default: 0\n</code></pre></p> <p><pre><code>from georeader import plot\nplot.show((data_memory / 3_500).clip(0, 1))\n</code></pre> </p> <p>Saving the <code>GeoTensor</code> as a COG GeoTIFF: </p> <pre><code>from georeader.save import save_cog\n\n# Supports writing in remote location (e.g. gs://bucket-name/s2_crop.tif)\nsave_cog(data_memory, \"s2_crop.tif\", descriptions=[\"B4\",\"B3\", \"B2\"])\n</code></pre>"},{"location":"#tutorials","title":"Tutorials","text":""},{"location":"#sentinel-2","title":"Sentinel-2","text":"<ul> <li>Reading Sentinel-2 images from the public Google bucket </li> <li>Explore metadata of Sentinel-2 object </li> <li>Query Sentinel-2 images over a location and time span, mosaic and plot them </li> <li>Sentinel-2 images from GEE and CloudSEN12 cloud detection </li> </ul>"},{"location":"#read-rasters-from-different-satellites","title":"Read rasters from different satellites","text":"<ul> <li>Tiling and stitching predictions of an AI model </li> <li>Tutorial to read overlapping tiles from a GeoTIFF and a Sentinel-2 image </li> <li>Example of reading a Proba-V image overlapping with Sentinel-2 forcing same resolution</li> <li>Work with EMIT images </li> <li>Read overlapping images of PRISMA and EMIT </li> <li>Read EnMAP images, integrate them to Sentinel-2 bands, convert radiance to TOA reflectance and run CloudSEN12 cloud detection model </li> </ul>"},{"location":"#used-in-other-projects","title":"Used in other projects","text":"<ul> <li>georeader with ml4floods to automatically download and produce flood extent maps: the Kherson Dam Break example</li> <li>georeader with STARCOP to simulate Sentinel-2 from AVIRIS images</li> <li>georeader with STARCOP to run plume detection in EMIT images</li> <li>georeader with CloudSEN12 to run cloud detection in Sentinel-2 images</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you find this code useful please cite: <pre><code>@article{portales-julia_global_2023,\n    title = {Global flood extent segmentation in optical satellite images},\n    volume = {13},\n    issn = {2045-2322},\n    doi = {10.1038/s41598-023-47595-7},\n    number = {1},\n    urldate = {2023-11-30},\n    journal = {Scientific Reports},\n    author = {Portal\u00e9s-Juli\u00e0, Enrique and Mateo-Garc\u00eda, Gonzalo and Purcell, Cormac and G\u00f3mez-Chova, Luis},\n    month = nov,\n    year = {2023},\n    pages = {20316},\n}\n@article{ruzicka_starcop_2023,\n    title = {Semantic segmentation of methane plumes with hyperspectral machine learning models},\n    volume = {13},\n    issn = {2045-2322},\n    url = {https://www.nature.com/articles/s41598-023-44918-6},\n    doi = {10.1038/s41598-023-44918-6},\n    number = {1},\n    journal = {Scientific Reports},\n    author = {R\u016f\u017ei\u010dka, V\u00edt and Mateo-Garcia, Gonzalo and G\u00f3mez-Chova, Luis and Vaughan, Anna, and Guanter, Luis and Markham, Andrew},\n    month = nov,\n    year = {2023},\n    pages = {19999},\n}\n</code></pre></p>"},{"location":"#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This research has been supported by the DEEPCLOUD project (PID2019-109026RB-I00) funded by the Spanish Ministry of Science and Innovation (MCIN/AEI/10.13039/501100011033) and the European Union (NextGenerationEU).</p> <p></p> <ul> <li>Documentation https://spaceml-org.github.io/georeader/</li> </ul>"},{"location":"emit_explore/","title":"EMIT","text":"<pre><code>from georeader.readers import emit\nfrom georeader.readers import download_utils\nimport os\n\ndir_emit_files = \"emit_database/raw\"\nos.makedirs(dir_emit_files, exist_ok=True)\n# link = 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/EMIT_L1B_RAD_001_20220828T051941_2224004_006/EMIT_L1B_RAD_001_20220828T051941_2224004_006.nc'\nlink = 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/EMIT_L1B_RAD_001_20220827T060753_2223904_013/EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\nfile_save = os.path.join(dir_emit_files, os.path.basename(link))\n\nemit.download_product(link, file_save)\n</code></pre> <pre>\n<code>File emit_database/raw/EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc exists. It won't be downloaded again\n</code>\n</pre> <pre>\n<code>'emit_database/raw/EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'</code>\n</pre> <pre><code># file_save = \"emit_database/EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc\"\nei = emit.EMITImage(file_save)\nei\n</code></pre> <pre>\n<code> \n         File: emit_database/raw/EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc\n         Transform: | 0.00,-0.00, 61.16|\n|-0.00,-0.00, 36.83|\n| 0.00, 0.00, 1.00|\n         Shape: (285, 2007, 2239)\n         Resolution: (0.0005422325202530942, 0.0005422325202530942)\n         Bounds: (61.1592142222353, 35.74201728362127, 62.3732728350893, 36.8302779517758)\n         CRS: EPSG:4326\n         units: uW/cm^2/SR/nm\n        </code>\n</pre> <pre><code>ei.nc_ds\n</code></pre> <pre>\n<code>&lt;class 'netCDF4._netCDF4.Dataset'&gt;\nroot group (NETCDF4 data model, file format HDF5):\n    ncei_template_version: NCEI_NetCDF_Swath_Template_v2.0\n    summary: The Earth Surface Mineral Dust Source Investigation (EMIT) is an Earth Ventures-Instrument (EVI-4) Mission that maps the surface mineralogy of arid dust source regions via imaging spectroscopy in the visible and short-wave infrared (VSWIR). Installed on the International Space Station (ISS), the EMIT instrument is a Dyson imaging spectrometer that uses contiguous spectroscopic measurements from 410 to 2450 nm to resolve absoprtion features of iron oxides, clays, sulfates, carbonates, and other dust-forming minerals. During its one-year mission, EMIT will observe the sunlit Earth's dust source regions that occur within +/-52\u00b0 latitude and produce maps of the source regions that can be used to improve forecasts of the role of mineral dust in the radiative forcing (warming or cooling) of the atmosphere.\\n\\nThis file contains L1B at-sensor calibrated radiances. The radiance calibration occurs in two basic stages: 1) transforming raw digital numbers into radiance units using a calibrated radiometric response and correcting for electronic artifacts, and 2) a correction for instrument optical effects which results in an absolute spectral wavelength calibration. The radiance file contains radiance for each of 285 channels in units of microwatts per centimeter per centimeter squared per steradian. Geolocation data (latitude, longitude, height) and a lookup table to project the data are also included.\n    keywords: Imaging Spectroscopy, minerals, EMIT, dust, radiative forcing\n    Conventions: CF-1.63\n    sensor: EMIT (Earth Surface Mineral Dust Source Investigation)\n    instrument: EMIT\n    platform: ISS\n    institution: NASA Jet Propulsion Laboratory/California Institute of Technology\n    license: https://science.nasa.gov/earth-science/earth-science-data/data-information-policy/\n    naming_authority: LPDAAC\n    date_created: 2023-01-21T12:24:18Z\n    keywords_vocabulary: NASA Global Change Master Directory (GCMD) Science Keywords\n    stdname_vocabulary: NetCDF Climate and Forecast (CF) Metadata Convention\n    creator_name: Jet Propulsion Laboratory/California Institute of Technology\n    creator_url: https://earth.jpl.nasa.gov/emit/\n    project: Earth Surface Mineral Dust Source Investigation\n    project_url: https://emit.jpl.nasa.gov/\n    publisher_name: NASA LPDAAC\n    publisher_url: https://lpdaac.usgs.gov\n    publisher_email: lpdaac@usgs.gov\n    identifier_product_doi_authority: https://doi.org\n    flight_line: emit20220827t060753_o23904_s001\n    time_coverage_start: 2022-08-27T06:07:53+0000\n    time_coverage_end: 2022-08-27T06:08:05+0000\n    software_build_version: 010603\n    product_version: V001\n    history: PGE Run Command: {python /beegfs/store/emit/ops/repos/emit-sds-l1b/emitrdn.py --mode default --level INFO --log_file /tmp/emit/ops/emit20220827t060753_emit.L1BCalibrate_20221112t080244/output/emit20220827t060753_o23904_s001_l1b_rdn_b0106_v01_pge.log /beegfs/store/emit/ops/data/acquisitions/20220827/emit20220827t060753/l1a/emit20220827t060753_o23904_s001_l1a_raw_b0106_v01.img /beegfs/store/emit/ops/data/acquisitions/20220827/emit20220827t054803/l1a/emit20220827t054803_o23904_s000_l1a_raw_b0106_v01.img /tmp/emit/ops/emit20220827t060753_emit.L1BCalibrate_20221112t080244/l1b_config.json /tmp/emit/ops/emit20220827t060753_emit.L1BCalibrate_20221112t080244/output/emit20220827t060753_o23904_s001_l1b_rdn_b0106_v01.img /tmp/emit/ops/emit20220827t060753_emit.L1BCalibrate_20221112t080244/output/emit20220827t060753_o23904_s001_l1b_bandmask_b0106_v01.img;python /beegfs/store/emit/ops/repos/emit-sds-l1b/utils/fitflatfield.py /tmp/emit/ops/emit20220827t060753_emit.L1BCalibrate_20221112t080244/output/emit20220827t060753_o23904_s001_l1b_rdn_b0106_v01.img /tmp/emit/ops/emit20220827t060753_emit.L1BCalibrate_20221112t080244/output/emit20220827t060753_o23904_s001_l1b_rdn_destripe_b0106_v01.img /tmp/emit/ops/emit20220827t060753_emit.L1BCalibrate_20221112t080244/output/emit20220827t060753_o23904_s001_l1b_destripeff_b0106_v01.img /tmp/emit/ops/emit20220827t060753_emit.L1BCalibrate_20221112t080244/output/emit20220827t060753_o23904_s001_l1b_destripedark_b0106_v01.img}, PGE Input Files: {srf_correction_file=/beegfs/store/emit/ops/repos/emit-sds-l1b/data/emit/EMIT_SpectralScatter_20220406, crf_correction_file=/beegfs/store/emit/ops/repos/emit-sds-l1b/data/emit/EMIT_SpatialScatter_20220406, bad_element_file=/beegfs/store/emit/ops/repos/emit-sds-l1b/data/emit/EMIT_BadElements_20220307, spectral_calibration_file=/beegfs/store/emit/ops/repos/emit-sds-l1b/data/emit/EMIT_Wavelengths_20220817.txt, ghost_map_file=/beegfs/store/emit/ops/repos/emit-sds-l1b/data/emit/EMIT_GhostMap_20220424.json, linearity_file=/beegfs/store/emit/ops/repos/emit-sds-l1b/data/emit/EMIT_LinearityBasis_20220504, linearity_map_file=/beegfs/store/emit/ops/repos/emit-sds-l1b/data/emit/EMIT_LinearityMap_20220504, flat_field_file=/beegfs/store/emit/ops/repos/emit-sds-l1b/data/emit/EMIT_FlatField_20220825, radiometric_coefficient_file=/beegfs/store/emit/ops/repos/emit-sds-l1b/data/emit/EMIT_RadiometricCoeffs_20220901.txt, dark_file=/beegfs/store/emit/ops/data/acquisitions/20220827/emit20220827t054803/l1a/emit20220827t054803_o23904_s000_l1a_raw_b0106_v01.img}\n    crosstrack_orientation: as seen on ground\n    easternmost_longitude: 61.1592142222353\n    northernmost_latitude: 36.8302779517758\n    westernmost_longitude: 62.3732728350893\n    southernmost_latitude: 35.74201728362127\n    spatialResolution: 0.000542232520256367\n    spatial_ref: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n    geotransform: [ 6.11592142e+01  5.42232520e-04 -0.00000000e+00  3.68302780e+01\n -0.00000000e+00 -5.42232520e-04]\n    day_night_flag: Day\n    title: EMIT L1B At-Sensor Calibrated Radiance Data 60 m V001\n    dimensions(sizes): downtrack(1280), crosstrack(1242), bands(285), ortho_y(2007), ortho_x(2239)\n    variables(dimensions): float32 radiance(downtrack, crosstrack, bands)\n    groups: sensor_band_parameters, location</code>\n</pre> <pre><code>ei.wavelengths\n</code></pre> <pre>\n<code>array([ 381.00558,  388.4092 ,  395.81583,  403.2254 ,  410.638  ,\n        418.0536 ,  425.47214,  432.8927 ,  440.31726,  447.7428 ,\n        455.17035,  462.59888,  470.0304 ,  477.46292,  484.89743,\n        492.33292,  499.77142,  507.2099 ,  514.6504 ,  522.0909 ,\n        529.5333 ,  536.9768 ,  544.42126,  551.8667 ,  559.3142 ,\n        566.7616 ,  574.20905,  581.6585 ,  589.108  ,  596.55835,\n        604.0098 ,  611.4622 ,  618.9146 ,  626.36804,  633.8215 ,\n        641.2759 ,  648.7303 ,  656.1857 ,  663.6411 ,  671.09753,\n        678.5539 ,  686.0103 ,  693.4677 ,  700.9251 ,  708.38354,\n        715.84094,  723.2993 ,  730.7587 ,  738.2171 ,  745.6765 ,\n        753.1359 ,  760.5963 ,  768.0557 ,  775.5161 ,  782.97754,\n        790.4379 ,  797.89935,  805.36176,  812.8232 ,  820.2846 ,\n        827.746  ,  835.2074 ,  842.66986,  850.1313 ,  857.5937 ,\n        865.0551 ,  872.5176 ,  879.98004,  887.44147,  894.90393,\n        902.3664 ,  909.82886,  917.2913 ,  924.7538 ,  932.21625,\n        939.6788 ,  947.14026,  954.6027 ,  962.0643 ,  969.5268 ,\n        976.9883 ,  984.4498 ,  991.9114 ,  999.37286, 1006.8344 ,\n       1014.295  , 1021.7566 , 1029.2172 , 1036.6777 , 1044.1383 ,\n       1051.5989 , 1059.0596 , 1066.5201 , 1073.9797 , 1081.4404 ,\n       1088.9    , 1096.3597 , 1103.8184 , 1111.2781 , 1118.7368 ,\n       1126.1964 , 1133.6552 , 1141.1129 , 1148.5717 , 1156.0304 ,\n       1163.4882 , 1170.9459 , 1178.4037 , 1185.8616 , 1193.3184 ,\n       1200.7761 , 1208.233  , 1215.6898 , 1223.1467 , 1230.6036 ,\n       1238.0596 , 1245.5154 , 1252.9724 , 1260.4283 , 1267.8833 ,\n       1275.3392 , 1282.7942 , 1290.2502 , 1297.7052 , 1305.1603 ,\n       1312.6144 , 1320.0685 , 1327.5225 , 1334.9756 , 1342.4287 ,\n       1349.8818 , 1357.3351 , 1364.7872 , 1372.2384 , 1379.6907 ,\n       1387.1418 , 1394.5931 , 1402.0433 , 1409.4937 , 1416.944  ,\n       1424.3933 , 1431.8427 , 1439.292  , 1446.7404 , 1454.1888 ,\n       1461.6372 , 1469.0847 , 1476.5321 , 1483.9796 , 1491.4261 ,\n       1498.8727 , 1506.3192 , 1513.7649 , 1521.2104 , 1528.655  ,\n       1536.1007 , 1543.5454 , 1550.9891 , 1558.4329 , 1565.8766 ,\n       1573.3193 , 1580.7621 , 1588.205  , 1595.6467 , 1603.0886 ,\n       1610.5295 , 1617.9705 , 1625.4104 , 1632.8513 , 1640.2903 ,\n       1647.7303 , 1655.1694 , 1662.6074 , 1670.0455 , 1677.4836 ,\n       1684.9209 , 1692.358  , 1699.7952 , 1707.2314 , 1714.6667 ,\n       1722.103  , 1729.5383 , 1736.9727 , 1744.4071 , 1751.8414 ,\n       1759.2749 , 1766.7084 , 1774.1418 , 1781.5743 , 1789.007  ,\n       1796.4385 , 1803.8701 , 1811.3008 , 1818.7314 , 1826.1611 ,\n       1833.591  , 1841.0206 , 1848.4495 , 1855.8773 , 1863.3052 ,\n       1870.733  , 1878.16   , 1885.5869 , 1893.013  , 1900.439  ,\n       1907.864  , 1915.2892 , 1922.7133 , 1930.1375 , 1937.5607 ,\n       1944.9839 , 1952.4071 , 1959.8295 , 1967.2518 , 1974.6732 ,\n       1982.0946 , 1989.515  , 1996.9355 , 2004.355  , 2011.7745 ,\n       2019.1931 , 2026.6118 , 2034.0304 , 2041.4471 , 2048.865  ,\n       2056.2808 , 2063.6965 , 2071.1123 , 2078.5273 , 2085.9421 ,\n       2093.3562 , 2100.769  , 2108.1821 , 2115.5942 , 2123.0063 ,\n       2130.4175 , 2137.8289 , 2145.239  , 2152.6482 , 2160.0576 ,\n       2167.467  , 2174.8755 , 2182.283  , 2189.6904 , 2197.097  ,\n       2204.5034 , 2211.9092 , 2219.3147 , 2226.7195 , 2234.1233 ,\n       2241.5269 , 2248.9297 , 2256.3328 , 2263.7346 , 2271.1365 ,\n       2278.5376 , 2285.9387 , 2293.3386 , 2300.7378 , 2308.136  ,\n       2315.5342 , 2322.9326 , 2330.3298 , 2337.7263 , 2345.1216 ,\n       2352.517  , 2359.9126 , 2367.3071 , 2374.7007 , 2382.0935 ,\n       2389.486  , 2396.878  , 2404.2695 , 2411.6604 , 2419.0513 ,\n       2426.4402 , 2433.8303 , 2441.2183 , 2448.6064 , 2455.9944 ,\n       2463.3816 , 2470.7678 , 2478.153  , 2485.5386 , 2492.9238 ],\n      dtype=float32)</code>\n</pre> <pre><code>ei.time_coverage_start, ei.time_coverage_end\n</code></pre> <pre>\n<code>(datetime.datetime(2022, 8, 27, 6, 7, 53, tzinfo=datetime.timezone.utc),\n datetime.datetime(2022, 8, 27, 6, 8, 5, tzinfo=datetime.timezone.utc))</code>\n</pre> <pre><code>import geopandas as gpd\n\ngpd.GeoDataFrame(geometry=[ei.footprint()],\n                 crs=ei.crs).explore()\n</code></pre> Make this Notebook Trusted to load map: File -&gt; Trust Notebook <pre><code>import numpy as np\nwavelengths_read = np.array([640, 550, 460])\n\nbands_read = np.argmin(np.abs(wavelengths_read[:, np.newaxis] - ei.wavelengths), axis=1).tolist()\nei_rgb = ei.read_from_bands(bands_read)\nei_rgb\n</code></pre> <pre>\n<code> \n         File: emit_database/raw/EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc\n         Transform: | 0.00,-0.00, 61.16|\n|-0.00,-0.00, 36.83|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 2007, 2239)\n         Resolution: (0.0005422325202530942, 0.0005422325202530942)\n         Bounds: (61.1592142222353, 35.74201728362127, 62.3732728350893, 36.8302779517758)\n         CRS: EPSG:4326\n         units: uW/cm^2/SR/nm\n        </code>\n</pre> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nfrom georeader import reflectance\n\nthuiller = reflectance.load_thuillier_irradiance() # (dataframe with 8191 rows, 2 colums -&amp;gt; Nanometer, Radiance(mW/m2/nm)\n\nei_rgb.wavelengths, ei_rgb.fwhm # (K,) vectors with the center wavelength and the FWHM\n\nresponse = reflectance.srf(ei_rgb.wavelengths, ei_rgb.fwhm, thuiller[\"Nanometer\"].values) # (8191, K)\n\ncolors = [\"red\",\"green\", \"blue\"]\nfig, ax = plt.subplots(1,1,figsize=(12,4))\n\nax.plot(thuiller[\"Nanometer\"].values,\n        thuiller[\"Radiance(mW/m2/nm)\"].values,\n        label=\"Thuiller irradiance\")\nax.set_ylabel(\"Solar irradiance (mW/m$^2$/nm)\")\nax = ax.twinx()\nfor k in range(3):\n    ax.plot(thuiller[\"Nanometer\"].values, response[:, k], \n            label=f\"{wavelengths_read[k]}nm\",c=colors[k])\nax.set_xlabel(\"Wavelength nm\")\nax.set_ylabel(\"SRF\")\nax.set_xlim(410,700)\nax.legend(loc=\"upper left\")\n</code></pre> <pre>\n<code>&lt;matplotlib.legend.Legend at 0x7f03eb294220&gt;</code>\n</pre> <pre><code># solar_irradiance_norm = thuiller[\"Radiance(mW/m2/nm)\"].values.dot(response) # mW/m$^2$/nm\n# solar_irradiance_norm/=1_000  # W/m$^2$/nm\n# solar_irradiance_norm\n# ei_rgb_local = ei_rgb.load(as_reflectance=False)\n# ei_rgb_local = reflectance.radiance_to_reflectance(ei_rgb_local, solar_irradiance_norm,\n#                                                    ei.time_coverage_start,units=units)\n</code></pre> <pre><code>ei_rgb_local = ei_rgb.load(as_reflectance=True)\n</code></pre> <pre><code>from georeader.plot import show\n\nshow((ei_rgb_local).clip(0,1), \n     mask=ei_rgb_local.values == ei_rgb_local.fill_value_default)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>import georeader\n\ncrs_utm = georeader.get_utm_epsg(ei.footprint(\"EPSG:4326\"))\nemit_image_utm = ei.to_crs(crs_utm)\nemit_image_utm_rgb = emit_image_utm.read_from_bands(bands_read)\nemit_image_utm_rgb_local = emit_image_utm_rgb.load(as_reflectance=True)\nemit_image_utm_rgb_local\n</code></pre> <pre>\n<code> \n         Transform: | 60.00, 0.00, 333546.51|\n| 0.00,-60.00, 4077625.88|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 2036, 1844)\n         Resolution: (60.0, 60.0)\n         Bounds: (333546.5136802632, 3955465.8769401284, 444186.5136802632, 4077625.8769401284)\n         CRS: EPSG:32641\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>emit_image_utm_rgb.observation_date_correction_factor\n</code></pre> <pre>\n<code>3.9465190869822364</code>\n</pre> <pre><code>show((emit_image_utm_rgb_local).clip(0,1), \n     mask=emit_image_utm_rgb_local.values == emit_image_utm_rgb_local.fill_value_default,\n     add_scalebar=True)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>show(emit_image_utm.elevation(), add_colorbar_next_to=True, add_scalebar=True,\n     mask=True,title=\"Elevation\")\n</code></pre> <pre>\n<code>&lt;Axes: title={'center': 'Elevation'}&gt;</code>\n</pre> <pre><code>from georeader import read\n\npoint_tup = (61.28, 36.21)\nei_subset = read.read_from_center_coords(emit_image_utm_rgb, point_tup, \n                                         shape=(200,200),crs_center_coords=\"EPSG:4326\")\n\nei_subset_local = ei_subset.load(as_reflectance=True)\nei_subset_local\n</code></pre> <pre>\n<code> \n         Transform: | 60.00, 0.00, 339366.51|\n| 0.00,-60.00, 4014625.88|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 200, 200)\n         Resolution: (60.0, 60.0)\n         Bounds: (339366.5136802632, 4002625.8769401284, 351366.5136802632, 4014625.8769401284)\n         CRS: EPSG:32641\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>from georeader.plot import add_shape_to_plot\nfrom shapely.geometry import Point\n\nax = show((ei_subset_local).clip(0,1),\n          mask=ei_subset_local.values == ei_rgb_local.fill_value_default,\n         add_scalebar=True)\nadd_shape_to_plot(Point(*point_tup),crs_shape=\"EPSG:4326\",\n                  crs_plot=ei_subset_local.crs, ax=ax)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>import matplotlib.pyplot as plt\n\nei_rgb_raw = ei_rgb.load_raw(transpose=False)\nplt.imshow((ei_rgb_raw/12).clip(0,1))\n</code></pre> <pre>\n<code>&lt;matplotlib.image.AxesImage at 0x7f03db62f370&gt;</code>\n</pre> <pre><code>ei_rgb_subset = ei_subset.load_raw(transpose=False)\nplt.imshow((ei_rgb_subset/12).clip(0,1))\n</code></pre> <pre>\n<code>&lt;matplotlib.image.AxesImage at 0x7f03db6b0df0&gt;</code>\n</pre> <pre><code>emit_image_utm.mask_bands\n</code></pre> <pre>\n<code>array(['Cloud flag', 'Cirrus flag', 'Water flag', 'Spacecraft Flag',\n       'Dilated Cloud Flag', 'AOD550', 'H2O (g cm-2)', 'Aggregate Flag'],\n      dtype=object)</code>\n</pre> <pre><code># mask filtering cloudy pixels\nshow(emit_image_utm.validmask(), add_scalebar=True,vmin=0, vmax=1,\n     mask=True,title=\"Valid Mask\")\n</code></pre> <pre>\n<code>&lt;Axes: title={'center': 'Valid Mask'}&gt;</code>\n</pre> <pre><code>emit_image_utm.observation_bands\n</code></pre> <pre>\n<code>array(['Path length (sensor-to-ground in meters)',\n       'To-sensor azimuth (0 to 360 degrees CW from N)',\n       'To-sensor zenith (0 to 90 degrees from zenith)',\n       'To-sun azimuth (0 to 360 degrees CW from N)',\n       'To-sun zenith (0 to 90 degrees from zenith)',\n       'Solar phase (degrees between to-sensor and to-sun vectors in principal plane)',\n       'Slope (local surface slope as derived from DEM in degrees)',\n       'Aspect (local surface aspect 0 to 360 degrees clockwise from N)',\n       'Cosine(i) (apparent local illumination factor based on DEM slope and aspect and to sun vector)',\n       'UTC Time (decimal hours for mid-line pixels)',\n       'Earth-sun distance (AU)'], dtype=object)</code>\n</pre> <pre><code>show(emit_image_utm.sza(), add_colorbar_next_to=True, add_scalebar=True,\n     mask=True,title=\"Solar Zenith Angle\")\n</code></pre> <pre>\n<code>&lt;Axes: title={'center': 'Solar Zenith Angle'}&gt;</code>\n</pre> <pre><code>show(emit_image_utm.vza(), add_colorbar_next_to=True, add_scalebar=True,\n     mask=True,title=\"Viewing Zenith Angle\")\n</code></pre> <pre>\n<code>&lt;Axes: title={'center': 'Viewing Zenith Angle'}&gt;</code>\n</pre> <pre><code>show(emit_image_utm.observation('Path length (sensor-to-ground in meters)'), \n     add_colorbar_next_to=True, add_scalebar=True,\n     mask=True,title='Path length (sensor-to-ground in meters)')\n</code></pre> <pre>\n<code>&lt;Axes: title={'center': 'Path length (sensor-to-ground in meters)'}&gt;</code>\n</pre> <pre><code>show(emit_image_utm.observation('Slope (local surface slope as derived from DEM in degrees)'), \n     add_colorbar_next_to=True, add_scalebar=True,\n     mask=True,title='Slope (local surface slope as derived from DEM in degrees)')\n</code></pre> <pre>\n<code>&lt;Axes: title={'center': 'Slope (local surface slope as derived from DEM in degrees)'}&gt;</code>\n</pre>"},{"location":"emit_explore/#emit","title":"EMIT","text":""},{"location":"emit_explore/#install-package-with-emit-dependecies","title":"Install package with EMIT dependecies","text":"<p>EMIT requires the <code>netcdf4</code> package to read the products. We will also use the <code>pysolar</code> package to convert the EMIT L1B radiances to reflectances.</p> <pre><code>pip install georeader-spaceml netcdf4 pysolar\n</code></pre>"},{"location":"emit_explore/#download-an-emit-image","title":"Download an EMIT image","text":""},{"location":"emit_explore/#create-and-inspec-emit-object","title":"Create and inspec emit object","text":"<p>EMIT objects let you open an EMIT nc file without loading the content of the file in memory. The object in the cell below has 285 spectral bands. For the API description of the EMIT class see the emit module. Since the object follows the API of georeader, you can read from the rasters using the functions from the read module.</p>"},{"location":"emit_explore/#load-rgb","title":"Load RGB","text":"<p>Select the RGB bands, we see that the raster has only 3 channels now (see Shape in the output of the cell below). The <code>ei</code> object has an attribute called <code>wavelengths</code> with the central wavelength of the hyperspectral band.</p>"},{"location":"emit_explore/#normalize-radiance-to-reflectance","title":"Normalize radiance to reflectance","text":""},{"location":"emit_explore/#reproject-to-utm","title":"Reproject to UTM","text":""},{"location":"emit_explore/#subset-emit-image","title":"Subset EMIT image","text":""},{"location":"emit_explore/#load-image-non-orthorectified","title":"Load image non-orthorectified","text":""},{"location":"emit_explore/#full-image","title":"Full image","text":""},{"location":"emit_explore/#subset","title":"Subset","text":""},{"location":"emit_explore/#load-l2amask","title":"Load L2AMask","text":"<p>The L2AMask is stored in a separated file. The <code>mask</code> array has the following variables:</p>"},{"location":"emit_explore/#load-metadata","title":"Load metadata","text":"<p>Metadata is stored in a separated file (with suffix <code>_OBS_</code> instead of <code>_RAD_</code>). In metadata we have the following variables:</p>"},{"location":"emit_explore/#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite:</p> <pre><code>@article{ruzicka_starcop_2023,\n    title = {Semantic segmentation of methane plumes with hyperspectral machine learning models},\n    volume = {13},\n    issn = {2045-2322},\n    url = {https://www.nature.com/articles/s41598-023-44918-6},\n    doi = {10.1038/s41598-023-44918-6},\n    number = {1},\n    journal = {Scientific Reports},\n    author = {R\u016f\u017ei\u010dka, V\u00edt and Mateo-Garcia, Gonzalo and G\u00f3mez-Chova, Luis and Vaughan, Anna, and Guanter, Luis and Markham, Andrew},\n    month = nov,\n    year = {2023},\n    pages = {19999},\n}\n</code></pre>"},{"location":"enmap_with_cloudsen12/","title":"EnMAP","text":"<p>This notebook requires the <code>cloudsen12_models</code> package <pre><code>pip install georeader-spaceml cloudsen12_models fsspec\n</code></pre></p> <pre><code>from georeader.readers import enmap\nfrom cloudsen12_models import cloudsen12\nfrom georeader import plot\n\nxml_file = \"tempEnMAP/ENMAP01-____L1B-DT0000074101_20240511T080843Z_001_V010402_20240514T093550Z/ENMAP01-____L1B-DT0000074101_20240511T080843Z_001_V010402_20240514T093550Z-METADATA.XML\"\nenmap_reader = enmap.EnMAP(xml_file,by_folder=False)\nenmap_reader\n</code></pre> <pre>\n<code>/home/gonzalo/mambaforge/envs/georeader3/lib/python3.10/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</code>\n</pre> <pre>\n<code>\n        File: tempEnMAP/ENMAP01-____L1B-DT0000074101_20240511T080843Z_001_V010402_20240514T093550Z/ENMAP01-____L1B-DT0000074101_20240511T080843Z_001_V010402_20240514T093550Z-METADATA.XML\n        Bounds: (47.42948365009492, 29.213144376313977, 47.8031320641908, 29.53032430940031)\n        Time: 2024-05-11 08:08:43.855554+00:00\n        Spatial shape (height, width): (1024, 1000)\n        VNIR Range: (411.42039, 1003.9755) nbands: 91 \n        SWIR Range: (892.78475, 2452.4581000000003) nbands: 133\n        </code>\n</pre> <pre><code>%%time\n\nrgb = enmap_reader.load_rgb(apply_rpcs=False)\nplot.show(rgb)\n</code></pre> <pre>\n<code>CPU times: user 588 ms, sys: 940 ms, total: 1.53 s\nWall time: 406 ms\n</code>\n</pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>from georeader.readers import S2_SAFE_reader\n\nsrf = S2_SAFE_reader.read_srf(\"S2A\")\nsrf\n</code></pre> <pre>\n<code>/home/gonzalo/mambaforge/envs/georeader3/lib/python3.10/site-packages/openpyxl/worksheet/_reader.py:329: UserWarning: Unknown extension is not supported and will be removed\n  warn(msg)\n</code>\n</pre> B01 B02 B03 B04 B05 B06 B07 B08 B8A B09 B10 B11 B12 SR_WL 412 0.001776 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 413 0.004073 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 414 0.003626 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 415 0.003515 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 416 0.005729 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2316 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.010984 2317 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.007360 2318 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.006491 2319 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.004697 2320 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.002059 <p>877 rows \u00d7 13 columns</p> <pre><code>%%time\n\n# Load swir in enmap_reader.units (i.e. radiance units)\nswir = enmap_reader.load_product(\"SPECTRAL_IMAGE_SWIR\")\n</code></pre> <pre>\n<code>CPU times: user 12.4 s, sys: 1.11 s, total: 13.5 s\nWall time: 13.5 s\n</code>\n</pre> <pre><code>from georeader import reflectance\n\nbands_s2_swir = [\"B09\",\"B10\",\"B11\",\"B12\"]\ns2bandsswir = reflectance.transform_to_srf(swir, \n                                           srf[bands_s2_swir],\n                                           wavelengths_hyperspectral=enmap_reader.wl_center[\"swir\"],\n                                           as_reflectance=True,\n                                           observation_date_corr_factor=enmap_reader.observation_date_correction_factor,\n                                           verbose=True,\n                                           units=enmap_reader.units)\n\ns2bandsswir\n</code></pre> <pre>\n<code>2024-10-30 10:31:40(0/4) Processing band B09\n2024-10-30 10:31:40  Loading 4 bands\n2024-10-30 10:31:40  bands loaded, computing tensor\n2024-10-30 10:31:40(1/4) Processing band B10\n2024-10-30 10:31:40  Loading 5 bands\n2024-10-30 10:31:40  bands loaded, computing tensor\n2024-10-30 10:31:41(2/4) Processing band B11\n2024-10-30 10:31:41  Loading 13 bands\n2024-10-30 10:31:41  bands loaded, computing tensor\n2024-10-30 10:31:41(3/4) Processing band B12\n2024-10-30 10:31:41  Loading 30 bands\n2024-10-30 10:31:41  bands loaded, computing tensor\n</code>\n</pre> <pre>\n<code> \n         Transform: | 0.00,-0.00, 47.50|\n|-0.00,-0.00, 29.53|\n| 0.00, 0.00, 1.00|\n         Shape: (4, 1024, 1000)\n         Resolution: (0.0003069912745516993, 0.0002759618727434178)\n         Bounds: (47.42948365009492, 29.213144376313977, 47.8031320641908, 29.53032430940031)\n         CRS: EPSG:4326\n         fill_value_default: 0.0\n        </code>\n</pre> <pre><code>import matplotlib.pyplot as plt\n\nfig, ax =plt.subplots(2,2,figsize=(12,5), tight_layout=True)\nax =ax.flatten()\n\nfor i,b in enumerate(bands_s2_swir):\n    ax[i].hist(s2bandsswir.values[i].ravel())\n    ax[i].set_title(b)\n</code></pre> <pre><code>vnir = enmap_reader.load_product(\"SPECTRAL_IMAGE_VNIR\")\nbands_s2_vnir = [\"B01\",\"B02\",\"B03\",\"B04\",\"B05\",\"B06\",\"B07\",\"B08\",\"B8A\"]\ns2bandsvnir = reflectance.transform_to_srf(vnir, \n                                           srf[bands_s2_vnir],\n                                           wavelengths_hyperspectral=enmap_reader.wl_center[\"vnir\"],\n                                           as_reflectance=True,\n                                           observation_date_corr_factor=enmap_reader.observation_date_correction_factor,\n                                           verbose=True,\n                                           extrapolate=True,\n                                           units=enmap_reader.units)\ns2bandsvnir\n</code></pre> <pre>\n<code>2024-10-30 10:31:52(0/9) Processing band B01\n2024-10-30 10:31:52  Loading 8 bands\n2024-10-30 10:31:52  bands loaded, computing tensor\n2024-10-30 10:31:52(1/9) Processing band B02\n2024-10-30 10:31:52  Loading 18 bands\n2024-10-30 10:31:52  bands loaded, computing tensor\n2024-10-30 10:31:53(2/9) Processing band B03\n2024-10-30 10:31:53  Loading 9 bands\n2024-10-30 10:31:53  bands loaded, computing tensor\n2024-10-30 10:31:53(3/9) Processing band B04\n2024-10-30 10:31:53  Loading 7 bands\n2024-10-30 10:31:53  bands loaded, computing tensor\n2024-10-30 10:31:53(4/9) Processing band B05\n2024-10-30 10:31:53  Loading 4 bands\n2024-10-30 10:31:53  bands loaded, computing tensor\n2024-10-30 10:31:53(5/9) Processing band B06\n2024-10-30 10:31:53  Loading 4 bands\n2024-10-30 10:31:53  bands loaded, computing tensor\n2024-10-30 10:31:53(6/9) Processing band B07\n2024-10-30 10:31:53  Loading 4 bands\n2024-10-30 10:31:53  bands loaded, computing tensor\n2024-10-30 10:31:53(7/9) Processing band B08\n2024-10-30 10:31:53  Loading 20 bands\n2024-10-30 10:31:53  bands loaded, computing tensor\n2024-10-30 10:31:53(8/9) Processing band B8A\n2024-10-30 10:31:53  Loading 6 bands\n2024-10-30 10:31:53  bands loaded, computing tensor\n</code>\n</pre> <pre>\n<code> \n         Transform: | 0.00,-0.00, 47.50|\n|-0.00,-0.00, 29.53|\n| 0.00, 0.00, 1.00|\n         Shape: (9, 1024, 1000)\n         Resolution: (0.0003069912745516993, 0.0002759618727434178)\n         Bounds: (47.42948365009492, 29.213144376313977, 47.8031320641908, 29.53032430940031)\n         CRS: EPSG:4326\n         fill_value_default: 0.0\n        </code>\n</pre> <pre><code>fig, ax =plt.subplots(4,2,figsize=(12,10), tight_layout=True)\nax =ax.flatten()\n\nfor i,b in enumerate(bands_s2_vnir[:-1]):\n    ax[i].hist(s2bandsvnir.values[i].ravel())\n    ax[i].set_title(b)\n</code></pre> <pre><code>rgb_s2 = s2bandsvnir.isel({\"band\": [3,2,1]})\nplot.show(rgb_s2)\n</code></pre> <pre>\n<code>/home/gonzalo/git/georeader/georeader/plot.py:119: UserWarning: The transform is not rectilinear. The x and y ticks and the scale bar are not going to be correct. To discard this warning use: warnings.filterwarnings('ignore', message='The transform is not rectilinear.')\n  warnings.warn(\"The transform is not rectilinear. The x and y ticks and the scale bar are not going to be correct.\"\n</code>\n</pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>from georeader.geotensor import GeoTensor\nimport numpy as np\ns2_image = GeoTensor(np.concatenate([s2bandsvnir.values, s2bandsswir.values],axis=0),\n                     transform=s2bandsswir.transform, crs=s2bandsswir.crs, \n                     fill_value_default=s2bandsswir.fill_value_default)\ns2_image\n</code></pre> <pre>\n<code> \n         Transform: | 0.00,-0.00, 47.50|\n|-0.00,-0.00, 29.53|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 1024, 1000)\n         Resolution: (0.0003069912745516993, 0.0002759618727434178)\n         Bounds: (47.42948365009492, 29.213144376313977, 47.8031320641908, 29.53032430940031)\n         CRS: EPSG:4326\n         fill_value_default: 0.0\n        </code>\n</pre> <pre><code>swir_nir_red = (s2_image.isel({\"band\": [S2_SAFE_reader.BANDS_S2_L1C.index(b) for b in [\"B11\", \"B08\", \"B04\"]]}) / .45).clip(0,1)\n\nplot.show(swir_nir_red)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>model_4bands = cloudsen12.load_model_by_name(name=\"dtacs4bands\", weights_folder=\"cloudsen12_models\")\ncloudmask = model_4bands.predict(s2_image.isel({\"band\": [S2_SAFE_reader.BANDS_S2_L1C.index(b) for b in model_4bands.bands]}))\n\nfig, ax = plt.subplots(1,2,figsize=(14,5),sharey=True, tight_layout=True)\n\nplot.show(swir_nir_red,ax=ax[0])\ncloudsen12.plot_cloudSEN12mask(cloudmask, ax=ax[1])\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>model = cloudsen12.load_model_by_name(name=\"UNetMobV2_V2\", weights_folder=\"cloudsen12_models\")\ncloudmask = model.predict(s2_image)\n\nfig, ax = plt.subplots(1,2,figsize=(14,5),sharey=True, tight_layout=True)\n\nplot.show(swir_nir_red,ax=ax[0])\ncloudsen12.plot_cloudSEN12mask(cloudmask, ax=ax[1])\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre>"},{"location":"enmap_with_cloudsen12/#enmap","title":"EnMAP","text":""},{"location":"enmap_with_cloudsen12/#licence","title":"Licence","text":"<p>The <code>cloudsen12_models</code> package is published under a GNU Lesser GPL v3 licence</p> <p>The CloudSEN12 database and all pre-trained models are released under a Creative Commons non-commercial licence. For using the models in comercial pipelines written consent by the authors must be provided.</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite: <pre><code>@article{aybar_cloudsen12_2024,\n    title = {{CloudSEN12}+: {The} largest dataset of expert-labeled pixels for cloud and cloud shadow detection in {Sentinel}-2},\n    issn = {2352-3409},\n    url = {https://www.sciencedirect.com/science/article/pii/S2352340924008163},\n    doi = {10.1016/j.dib.2024.110852},\n    journal = {Data in Brief},\n    author = {Aybar, Cesar and Bautista, Lesly and Montero, David and Contreras, Julio and Ayala, Daryl and Prudencio, Fernando and Loja, Jhomira and Ysuhuaylas, Luis and Herrera, Fernando and Gonzales, Karen and Valladares, Jeanett and Flores, Lucy A. and Mamani, Evelin and Qui\u00f1onez, Maria and Fajardo, Rai and Espinoza, Wendy and Limas, Antonio and Yali, Roy and Alc\u00e1ntara, Alejandro and Leyva, Martin and Loayza-Muro, Rau\u00b4l and Willems, Bram and Mateo-Garc\u00eda, Gonzalo and G\u00f3mez-Chova, Luis},\n    month = aug,\n    year = {2024},\n    pages = {110852},\n}\n</code></pre></p>"},{"location":"example_readme/","title":"Example readme","text":"<pre><code>from georeader.rasterio_reader import RasterioReader\nfrom georeader import read\n\n# S2 image from WorldFloodsv2 dataset\ns2url = \"https://huggingface.co/datasets/isp-uv-es/WorldFloodsv2/resolve/main/test/S2/EMSR264_18MIANDRIVAZODETAIL_DEL_v2.tif\"\nrst = RasterioReader(s2url)\n\n# lazy loading bands\nrst_rgb = rst.isel({\"band\": [3, 2, 1]}) # 1-based list as in rasterio\n\ncords_read = (45.43, -19.53) # long, lat\ncrs_cords = \"EPSG:4326\"\n\n# See also read.read_from_bounds, read.read_from_polygon for different ways of croping an image\ndata = read.read_from_center_coords(rst_rgb,\n                                    cords_read, shape=(504, 1040),\n                                    crs_center_coords=crs_cords)\n\ndata_memory = data.load() # this loads the data to memory\n\ndata_memory # GeoTensor object\n</code></pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 539910.00|\n| 0.00,-10.00, 7842990.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 504, 1040)\n         Resolution: (10.0, 10.0)\n         Bounds: (539910.0, 7837950.0, 550310.0, 7842990.0)\n         CRS: EPSG:32738\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>from georeader import plot\n\nplot.show((data_memory / 3_500).clip(0, 1))\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>from georeader.save import save_cog\n\n# Supports writing in bucket location (e.g. gs://bucket-name/s2_crop.tif)\nsave_cog(data_memory, \"s2_crop.tif\", descriptions=[\"B4\",\"B3\", \"B2\"])\n</code></pre>"},{"location":"geotensor_numpy_api/","title":"GeoTensors","text":"<pre><code># From ml4floods: https://spaceml-org.github.io/ml4floods/content/ml4ops/HOWTO_Run_Inference_multioutput_binary.html\n# from huggingface_hub import hf_hub_url\n# subset = \"test\"\n# filename = \"EMSR264_18MIANDRIVAZODETAIL_DEL_v2\"\n\n# s2url = hf_hub_url(repo_id=\"isp-uv-es/WorldFloodsv2\",\n#                    subfolder=f\"{subset}/S2\", filename=f\"{filename}.tif\",\n#                    repo_type=\"dataset\")\n# print(s2url)\n</code></pre> <pre><code>from georeader import plot\nfrom georeader.geotensor import GeoTensor\nfrom georeader import save\nimport os\nimport numpy as np\n\ns2url = \"https://huggingface.co/datasets/isp-uv-es/WorldFloodsv2/resolve/main/test/S2/EMSR264_18MIANDRIVAZODETAIL_DEL_v2.tif\"\nfilelocal = os.path.basename(s2url)\nif not os.path.exists(filelocal):\n    s2img = GeoTensor.load_file(s2url)\n    save.save_tiled_geotiff(s2img, filelocal)\nelse:\n    s2img = GeoTensor.load_file(filelocal)\n\n# Set nodata value to zero\ns2img.fill_value_default = 0\ns2img\n</code></pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 537430.00|\n| 0.00,-10.00, 7844180.00|\n| 0.00, 0.00, 1.00|\n         Shape: (15, 1313, 1530)\n         Resolution: (10.0, 10.0)\n         Bounds: (537430.0, 7831050.0, 552730.0, 7844180.0)\n         CRS: EPSG:32738\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>transform_before = s2img.transform\ns2img = s2img.pad(((0,0), (25, 25), (10, 10)))\ns2img\n</code></pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 537330.00|\n| 0.00,-10.00, 7844430.00|\n| 0.00, 0.00, 1.00|\n         Shape: (15, 1363, 1550)\n         Resolution: (10.0, 10.0)\n         Bounds: (537330.0, 7830800.0, 552830.0, 7844430.0)\n         CRS: EPSG:32738\n         fill_value_default: 0\n        </code>\n</pre> <p>Padding changes transform</p> <pre><code>assert s2img.transform != transform_before, \"adding changes transform\"\ns2img.transform, transform_before\n</code></pre> <pre>\n<code>(Affine(10.0, 0.0, 537330.0,\n        0.0, -10.0, 7844430.0),\n Affine(10.0, 0.0, 537430.0,\n        0.0, -10.0, 7844180.0))</code>\n</pre> <pre><code>rgb = (s2img[[3,2,1]] / 3_500).clip(0,1)\nplot.show(rgb)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>invalids = np.all(s2img.invalidmask(),axis=0) \n\nassert isinstance(invalids, GeoTensor), \"invalids is of class GeoTensor!\"\n\nplot.plot_segmentation_mask(invalids, interpretation_array=[\"valid\", \"invalid\"],\n                           color_array=[\"C0\",\"C1\"])\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>rgb_slice = rgb[:, 20:300, 50:340]\nrgb_slice\n</code></pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 537830.00|\n| 0.00,-10.00, 7844230.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 280, 290)\n         Resolution: (10.0, 10.0)\n         Bounds: (537830.0, 7841430.0, 540730.0, 7844230.0)\n         CRS: EPSG:32738\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>assert rgb_slice.transform != rgb.transform, f\"Different transform\"\n\nrgb_slice.transform, rgb.transform\n</code></pre> <pre>\n<code>(Affine(10.0, 0.0, 537830.0,\n        0.0, -10.0, 7844230.0),\n Affine(10.0, 0.0, 537330.0,\n        0.0, -10.0, 7844430.0))</code>\n</pre> <pre><code>plot.show(rgb_slice)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>import numpy as np\n\ngreyimg = np.mean(rgb, axis=0)\ngreyimg\n</code></pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 537330.00|\n| 0.00,-10.00, 7844430.00|\n| 0.00, 0.00, 1.00|\n         Shape: (1363, 1550)\n         Resolution: (10.0, 10.0)\n         Bounds: (537330.0, 7830800.0, 552830.0, 7844430.0)\n         CRS: EPSG:32738\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>plot.show(greyimg, add_colorbar_next_to=True)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <p>When reducing over the spatial axis, return object is <code>np.ndarray</code>:</p> <pre><code>average_reflectance_band = np.mean(rgb, axis=(-2,-1))\naverage_reflectance_band\n</code></pre> <pre>\n<code>array([0.39475575, 0.36224817, 0.34591881])</code>\n</pre> <pre><code>greyimg_sin = np.sin(greyimg)\ngreyimg_sin\n</code></pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 537330.00|\n| 0.00,-10.00, 7844430.00|\n| 0.00, 0.00, 1.00|\n         Shape: (1363, 1550)\n         Resolution: (10.0, 10.0)\n         Bounds: (537330.0, 7830800.0, 552830.0, 7844430.0)\n         CRS: EPSG:32738\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>clouds = greyimg &amp;gt;= .9\nplot.plot_segmentation_mask(clouds, interpretation_array=[\"clear\",\"cloud\"], \n                            color_array=[\"C0\", \"white\"])\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>cloud_percentage = np.mean(clouds)\ncloud_percentage\n</code></pre> <pre>\n<code>np.float64(0.022976830047570587)</code>\n</pre> <pre><code>import matplotlib.pyplot as plt\n\naverage_reflectance_band = np.mean(rgb, axis=(-2,-1), keepdims=True)\nstd_reflectance = np.mean(rgb, axis=(-2,-1), keepdims=True)\n\nrgb_norm = (rgb - average_reflectance_band) / std_reflectance\n\nfig, ax = plt.subplots(1, 3, figsize=(15, 5),sharey=True, tight_layout=True)\nfor i in range(3):\n    plot.show(rgb_norm[i], add_colorbar_next_to=True,ax=ax[i], title=f\"B{i+2}\")\n</code></pre> <pre><code>b11 = s2img[11].astype(np.float64)\nb3 = s2img[2].astype(np.float64)\n\nmndwi = (b11 - b3) / (b11 + b3)\nplot.show(mndwi, add_colorbar_next_to=True)\n</code></pre> <pre>\n<code>/home/gonzalo/git/georeader/georeader/geotensor.py:508: RuntimeWarning: invalid value encountered in divide\n  result_values = self.values / other\n</code>\n</pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>water = mndwi &amp;lt; 0\nland_water_clouds = GeoTensor(np.ones(clouds.shape, dtype=np.uint8),\n                              fill_value_default=0,\n                              crs=clouds.crs,\n                              transform=clouds.transform)\n\nland_water_clouds[water] = 2\nland_water_clouds[clouds] = 3\nland_water_clouds[invalids] = 0\n\nplot.plot_segmentation_mask(land_water_clouds, \n                            interpretation_array=[\"invalids\",\"clear\",\"water\",\"cloud\"], \n                            color_array=[\"#000000\",\"#c66d43\",\"#437cc6\",\"#eeeeee\"])\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>clouds.values\n</code></pre> <pre>\n<code>array([[False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       ...,\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False],\n       [False, False, False, ..., False, False, False]])</code>\n</pre> <pre><code>from scipy import ndimage as ndi\n\ngreyimg_smoothed = ndi.gaussian_filter(greyimg, sigma=5, cval=0, mode=\"reflect\")\ngreyimg_smoothed\n</code></pre> <pre>\n<code>array([[0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       ...,\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.]])</code>\n</pre> <pre><code>greyimg_smoothed = rgb.array_as_geotensor(greyimg_smoothed)\nplot.show(greyimg_smoothed, add_colorbar_next_to=True)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre>"},{"location":"geotensor_numpy_api/#geotensor-numpy-api","title":"<code>GeoTensor</code> <code>numpy</code> API","text":"<ul> <li>Author: Gonzalo Mateo-Garc\u00eda</li> </ul> <p>This tutorial shows how to operate with the <code>numpy</code> API with <code>GeoTensor</code> objects. The <code>GeoTensor</code> class is a subclass of <code>np.ndarray</code> that stores the spatial affine transform, the coordinate reference system and no data value (called <code>fill_value_default</code>). When a <code>GeoTensor</code> is sliced, its <code>transform</code> attribute is shifted accordingly. Additionally its transform is also shifted if the <code>GeoTensor</code> is padded. <code>GeoTensor</code>s are restricted to be 2D, 3D or 4D arrays and their two last dimensions are assumed to be the <code>y</code> and <code>x</code> spatial axis.</p> <p>As a subclass of <code>np.ndarray</code>, operations with <code>GeoTensor</code> objects work similar than operations with <code>np.ndarray</code>s. However, there are some restrictions that we have implemented to keep consistency with the <code>GeoTensor</code> concept. If you need to use the <code>numpy</code> implementation you can access the bare <code>numpy</code> object with the <code>.values</code> attribute. Below there's a list with restrictions on <code>numpy</code> operations:</p> <ol> <li>Slicing a <code>GeoTensor</code> is more restrictive than a <code>numpy</code> array. It only allows to slice with <code>lists</code>, numbers or <code>slice</code>s. In particular the spatial dimensions can only be sliced with <code>slice</code>s. Slicing for inplace modification is not restricted (i.e. you can slice with boolean arrays to modify certain values of the object).</li> <li>Binary operations (such as add, multiply etc) check for <code>GeoTensor</code> inputs if they have the <code>same_extent</code>; that is, same <code>transform</code> <code>crs</code> and spatial dimensions (<code>width</code> and <code>height</code>).</li> <li><code>squeeze</code>, <code>expand_dims</code> and <code>transpose</code> make sure spatial dimensions (last two axes) are not modified and kept at the end of the array.</li> <li><code>concatenate</code> and <code>stack</code> make sure all operated <code>GeoTensor</code>s have <code>same_extent</code> and <code>shape</code>. <code>concatenate</code> does not allow to concatenate on the spatial dims.</li> <li>Reductions (such as <code>np.mean</code> or <code>np.all</code>) return <code>GeoTensor</code> object if the spatial dimensions are preserved and <code>np.ndarray</code> or scalars otherwise.</li> </ol>"},{"location":"geotensor_numpy_api/#load-some-sample-data","title":"Load some sample data","text":""},{"location":"geotensor_numpy_api/#padding-and-slicing-as-with-numpy-arrays","title":"Padding and slicing as with <code>numpy</code> arrays","text":""},{"location":"geotensor_numpy_api/#validmask-and-invalidmask-methods","title":"<code>validmask</code> and <code>invalidmask</code> methods","text":""},{"location":"geotensor_numpy_api/#slicing-propagates-the-affine-transform","title":"Slicing propagates the affine transform","text":""},{"location":"geotensor_numpy_api/#npmean-and-other-reduction-ops-return-geotensor","title":"<code>np.mean</code> and other reduction ops return <code>GeoTensor</code>","text":"<p>When reduction axis are not the spatial axis, the returned object is a <code>GeoTensor</code></p>"},{"location":"geotensor_numpy_api/#vectorized-ufuncs","title":"vectorized <code>ufuncs</code>","text":""},{"location":"geotensor_numpy_api/#ops-of-geotensor-with-numbers-and-npndarray","title":"Ops of <code>GeoTensor</code> with numbers and <code>np.ndarray</code>","text":""},{"location":"geotensor_numpy_api/#example-normalize-by-bands","title":"Example: normalize by bands","text":""},{"location":"geotensor_numpy_api/#computing-rs-indexes","title":"Computing RS indexes","text":""},{"location":"geotensor_numpy_api/#values-attribute-returns-a-view-of-the-object-as-npndarray","title":"<code>.values</code> attribute returns a view of the object as <code>np.ndarray</code>","text":""},{"location":"geotensor_numpy_api/#apply-function-that-expects-npndarray-objects","title":"Apply function that expects <code>np.ndarray</code> objects","text":"<p>We can pass a <code>GeoTensor</code> to any function that expects <code>np.ndarray</code>. Depending on the function the return type may be a <code>GeoTensor</code> or a <code>np.ndarray</code>. If the return type is <code>np.ndarray</code> we can wrap the array with <code>array_as_geotensor</code> method to convert back to <code>GeoTensor</code> object with the same spatial info.</p>"},{"location":"geotensor_numpy_api/#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite:</p> <pre><code>@article{portales-julia_global_2023,\n    title = {Global flood extent segmentation in optical satellite images},\n    volume = {13},\n    issn = {2045-2322},\n    doi = {10.1038/s41598-023-47595-7},\n    number = {1},\n    urldate = {2023-11-30},\n    journal = {Scientific Reports},\n    author = {Portal\u00e9s-Juli\u00e0, Enrique and Mateo-Garc\u00eda, Gonzalo and Purcell, Cormac and G\u00f3mez-Chova, Luis},\n    month = nov,\n    year = {2023},\n    pages = {20316},\n}\n</code></pre>"},{"location":"prisma_with_cloudsen12/","title":"PRISMA cloud detection","text":"<pre><code>from georeader.readers import prisma\nfrom cloudsen12_models import cloudsen12\nfrom georeader import plot\n</code></pre> <pre>\n<code>/home/gonzalo/mambaforge/envs/marsmlpy312/lib/python3.12/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</code>\n</pre> <pre><code>file = \"rasters/PRS_L1_STD_OFFL_20241109073054_20241109073059_0001.he5\"\nprisma_reader = prisma.PRISMA(file)\nprisma_reader\n</code></pre> <pre>\n<code>\n        File: rasters/PRS_L1_STD_OFFL_20241109073054_20241109073059_0001.he5\n        Bounds: (47.82221221923828, 29.50290870666504, 48.19811248779297, 29.824541091918945)\n        Time: 2024-11-09 07:30:54.783000+00:00\n        VNIR Range: (406.9934, 977.3654) 63 bands\n        SWIR Range: (943.3579, 2497.1155) 171 bands\n        </code>\n</pre> <pre><code>from georeader.readers import S2_SAFE_reader\n\nsrf = S2_SAFE_reader.read_srf(\"S2A\")\nsrf\n</code></pre> <pre>\n<code>/home/gonzalo/mambaforge/envs/marsmlpy312/lib/python3.12/site-packages/openpyxl/worksheet/_reader.py:329: UserWarning: Unknown extension is not supported and will be removed\n  warn(msg)\n</code>\n</pre> B01 B02 B03 B04 B05 B06 B07 B08 B8A B09 B10 B11 B12 SR_WL 412 0.001776 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 413 0.004073 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 414 0.003626 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 415 0.003515 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 416 0.005729 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2316 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.010984 2317 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.007360 2318 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.006491 2319 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.004697 2320 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.002059 <p>877 rows \u00d7 13 columns</p> <pre><code>%%time\nimport numpy as np\n# Load VNIR-SWIR in prisma units (i.e. radiance units)\nvnir = prisma_reader.load_raw(swir_flag=False); print(vnir.shape)\nswir = prisma_reader.load_raw(swir_flag=True); print(swir.shape)\nvnir_swir = np.moveaxis(np.concatenate((vnir, swir), axis = 2), 2, 0)\n# Load VNIR-SWIR central wavelengths\nvnir_wvl = prisma_reader.wavelength_vnir[0]\nswir_wvl = prisma_reader.wavelength_swir[0]\nvnir_swir_wvl = np.concatenate((vnir_wvl, swir_wvl))\n</code></pre> <pre>\n<code>(1000, 1000, 63)\n(1000, 1000, 171)\nCPU times: user 7.46 s, sys: 1.39 s, total: 8.86 s\nWall time: 8.85 s\n</code>\n</pre> <pre><code>from georeader import reflectance\ns2bands = reflectance.transform_to_srf(vnir_swir, \n                                           srf,\n                                           wavelengths_hyperspectral=vnir_swir_wvl,\n                                           as_reflectance=True,\n                                           observation_date_corr_factor=prisma_reader.observation_date_correction_factor,\n                                           verbose=True,\n                                           units=prisma_reader.units)\ntype(s2bands)\n</code></pre> <pre>\n<code>2025-01-31 09:25:09(0/13) Processing band B01\n2025-01-31 09:25:09  Loading 7 bands\n2025-01-31 09:25:09  bands loaded, computing tensor\n2025-01-31 09:25:09(1/13) Processing band B02\n2025-01-31 09:25:09  Loading 12 bands\n2025-01-31 09:25:09  bands loaded, computing tensor\n</code>\n</pre> <pre>\n<code>/home/gonzalo/mambaforge/envs/marsmlpy312/lib/python3.12/site-packages/pysolar/solartime.py:113: UserWarning: I don't know about leap seconds after 2023\n  warnings.warn \\\n</code>\n</pre> <pre>\n<code>2025-01-31 09:25:10(2/13) Processing band B03\n2025-01-31 09:25:10  Loading 7 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n2025-01-31 09:25:10(3/13) Processing band B04\n2025-01-31 09:25:10  Loading 5 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n2025-01-31 09:25:10(4/13) Processing band B05\n2025-01-31 09:25:10  Loading 3 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n2025-01-31 09:25:10(5/13) Processing band B06\n2025-01-31 09:25:10  Loading 3 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n2025-01-31 09:25:10(6/13) Processing band B07\n2025-01-31 09:25:10  Loading 4 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n2025-01-31 09:25:10(7/13) Processing band B08\n2025-01-31 09:25:10  Loading 14 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n2025-01-31 09:25:10(8/13) Processing band B8A\n2025-01-31 09:25:10  Loading 5 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n2025-01-31 09:25:10(9/13) Processing band B09\n2025-01-31 09:25:10  Loading 5 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n2025-01-31 09:25:10(10/13) Processing band B10\n2025-01-31 09:25:10  Loading 8 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n2025-01-31 09:25:10(11/13) Processing band B11\n2025-01-31 09:25:10  Loading 14 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n2025-01-31 09:25:10(12/13) Processing band B12\n2025-01-31 09:25:10  Loading 32 bands\n2025-01-31 09:25:10  bands loaded, computing tensor\n</code>\n</pre> <pre>\n<code>numpy.ndarray</code>\n</pre> <pre><code>import matplotlib.pyplot as plt\n\nbands_s2 = [\"B01\",\"B02\",\"B03\",\"B04\",\"B05\",\"B06\",\"B07\",\"B08\",\"B8A\", \"B09\",\"B10\",\"B11\",\"B12\"]\n\nfig, ax =plt.subplots(7,2,figsize=(10,10), tight_layout=True)\nax =ax.flatten()\n\nfor i,b in enumerate(bands_s2):\n    ax[i].hist(s2bands[i].ravel())\n    ax[i].set_title(b)\n</code></pre> <pre><code>s2bands.shape\nnp.moveaxis(s2bands, 0, 2).astype(np.float32).shape\n</code></pre> <pre>\n<code>(1000, 1000, 13)</code>\n</pre> <pre><code>from georeader import griddata\nfrom georeader.geotensor import GeoTensor\ns2_image = griddata.read_to_crs(np.moveaxis(s2bands, 0, 2).astype(np.float32), \n                                lons=prisma_reader.lons, lats=prisma_reader.lats, \n                                resolution_dst=30)\ns2_image\n</code></pre> <pre>\n<code> \n         Transform: | 30.00, 0.00, 192085.06|\n| 0.00,-30.00, 3303421.30|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 1211, 1235)\n         Resolution: (30.0, 30.0)\n         Bounds: (192085.06318415108, 3267091.300334674, 229135.06318415108, 3303421.300334674)\n         CRS: EPSG:32639\n         fill_value_default: -1\n        </code>\n</pre> <pre><code>swir_nir_red = (s2_image.isel({\"band\": [S2_SAFE_reader.BANDS_S2_L1C.index(b) for b in [\"B11\", \"B08\", \"B04\"]]}) / .45).clip(0,1)\n\nplot.show(swir_nir_red)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>model_4bands = cloudsen12.load_model_by_name(name=\"dtacs4bands\", weights_folder=\"cloudsen12_models\")\ncloudmask = model_4bands.predict(s2bands[[S2_SAFE_reader.BANDS_S2_L1C.index(b) for b in model_4bands.bands]])\n\ncloudmask_geotensor = griddata.read_to_crs(cloudmask,\n                                           lons=prisma_reader.lons, lats=prisma_reader.lats, \n                                           resolution_dst=30, method=\"nearest\")\n</code></pre> <pre><code>invalids = np.all(swir_nir_red.values == 0,axis=0)\ncloudmask_geotensor.values[invalids] = np.nan\n# swir_nir_red.values[:, invalids] = np.nan\n</code></pre> <pre><code>cloudsen12.plot_cloudSEN12mask(cloudmask_geotensor, ax=ax[1])\n\nfig, ax = plt.subplots(1,2,figsize=(14,5),sharey=True, tight_layout=True)\n\nplot.show(swir_nir_red,ax=ax[0])\ncloudsen12.plot_cloudSEN12mask(cloudmask_geotensor, ax=ax[1])\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre>"},{"location":"prisma_with_cloudsen12/#run-cloudsen12-models-in-prisma","title":"Run CloudSEN12 models in PRISMA","text":"<ul> <li>Authors: Gonzalo Mateo-Garc\u00eda, Manuel Montesino Martin</li> </ul> <p>This tutorial shows how to run <code>CloudSEN12</code>cloud detection models in a PRISMA image. It requires the <code>cloudsen12_models</code> package.</p> <pre><code>pip install cloudsen12_models georeader-spaceml\n</code></pre>"},{"location":"prisma_with_cloudsen12/#licence","title":"Licence","text":"<p>The <code>cloudsen12_models</code> package is published under a GNU Lesser GPL v3 licence</p> <p>The CloudSEN12 database and all pre-trained models are released under a Creative Commons non-commercial licence. For using the models in comercial pipelines written consent by the authors must be provided.</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite: <pre><code>@article{aybar_cloudsen12_2024,\n    title = {{CloudSEN12}+: {The} largest dataset of expert-labeled pixels for cloud and cloud shadow detection in {Sentinel}-2},\n    issn = {2352-3409},\n    url = {https://www.sciencedirect.com/science/article/pii/S2352340924008163},\n    doi = {10.1016/j.dib.2024.110852},\n    journal = {Data in Brief},\n    author = {Aybar, Cesar and Bautista, Lesly and Montero, David and Contreras, Julio and Ayala, Daryl and Prudencio, Fernando and Loja, Jhomira and Ysuhuaylas, Luis and Herrera, Fernando and Gonzales, Karen and Valladares, Jeanett and Flores, Lucy A. and Mamani, Evelin and Qui\u00f1onez, Maria and Fajardo, Rai and Espinoza, Wendy and Limas, Antonio and Yali, Roy and Alc\u00e1ntara, Alejandro and Leyva, Martin and Loayza-Muro, Rau\u00b4l and Willems, Bram and Mateo-Garc\u00eda, Gonzalo and G\u00f3mez-Chova, Luis},\n    month = aug,\n    year = {2024},\n    pages = {110852},\n}\n</code></pre></p>"},{"location":"read_S2_SAFE_from_bucket/","title":"From the public bucket","text":"<pre><code>!pip install georeader-spaceml fsspec gcsfs\n</code></pre> <pre><code>import os\nfrom georeader.readers import S2_SAFE_reader\n\nos.environ[\"GS_NO_SIGN_REQUEST\"] = \"YES\"\n\n# Donwload key from next line link to access the buckets and requester pays requests to public bucket (this is needed to query Sentinel-2 data)\n# This is required to do advaced operations in the GCP bucket\n# os.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"path/to/file.json\"\n# os.environ[\"GS_USER_PROJECT\"] = \"project-name\"\n# S2_SAFE_reader.DEFAULT_REQUESTER_PAYS=True\n</code></pre> <pre><code>%%time\n\nsafe_file = \"S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE\"\ns2_safe_folder = S2_SAFE_reader.s2_public_bucket_path(safe_file, check_exists=False)\n\nprint(f\"File is located at: {s2_safe_folder}\")\n\ns2obj = S2_SAFE_reader.s2loader(s2_safe_folder, out_res=10)\n\nos.makedirs(\"deleteme\",exist_ok=True)\ns2obj = s2obj.cache_product_to_local_dir(\"deleteme\")\n\ns2obj\n</code></pre> <pre>\n<code>File is located at: gs://gcp-public-data-sentinel-2/tiles/49/S/GV/S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE\n</code>\n</pre> <pre>\n<code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 13/13 [00:00&lt;00:00, 26341.04it/s]</code>\n</pre> <pre>\n<code>CPU times: user 410 ms, sys: 40.2 ms, total: 450 ms\nWall time: 529 ms\n</code>\n</pre> <pre>\n<code>\n</code>\n</pre> <pre>\n<code> \n         deleteme/S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE\n         Transform: | 10.00, 0.00, 699960.00|\n| 0.00,-10.00, 4000020.00|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 10980, 10980)\n         Resolution: (10.0, 10.0)\n         Bounds: (699960.0, 3890220.0, 809760.0, 4000020.0)\n         CRS: EPSG:32649\n         bands: ['B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B8A', 'B09', 'B10', 'B11', 'B12']\n         fill_value_default: 0\n        </code>\n</pre> <p>Select the bands and bounds to read and trigger <code>load</code> (to read the data in memory)</p> <pre><code>%%time\nfrom georeader import read\nbounds_read = (759760.0, 3940220.0, 799760.0, 3960220.0)\n\ns2obj_3bands = s2obj.read_from_band_names([\"B04\", \"B03\", \"B02\"])\ndata = read.read_from_bounds(s2obj_3bands, bounds_read) # This does not trigger the download of the data\ndata_memory = data.load() # this triggers download only for the selected bands and within the bounds\ndata_memory\n</code></pre> <pre>\n<code>CPU times: user 24.2 s, sys: 410 ms, total: 24.7 s\nWall time: 2.44 s\n</code>\n</pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 759760.00|\n| 0.00,-10.00, 3960220.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 2000, 4000)\n         Resolution: (10.0, 10.0)\n         Bounds: (759760.0, 3940220.0, 799760.0, 3960220.0)\n         CRS: EPSG:32649\n         fill_value_default: 0\n        </code>\n</pre> <p>The <code>numpy.array</code> is stored in the <code>values</code> property.</p> <pre><code>%%time\ndata_memory.values\n</code></pre> <pre>\n<code>CPU times: user 10 \u00b5s, sys: 0 ns, total: 10 \u00b5s\nWall time: 18.6 \u00b5s\n</code>\n</pre> <pre>\n<code>array([[[1314, 1139, 1156, ..., 1517, 1730, 1561],\n        [1309, 1142, 1274, ..., 1581, 1730, 1508],\n        [1335, 1288, 1526, ..., 1659, 1688, 1395],\n        ...,\n        [1510, 1539, 1567, ..., 1012, 1016, 1028],\n        [1479, 1514, 1545, ...,  974,  952,  954],\n        [1517, 1515, 1555, ...,  951,  952,  946]],\n\n       [[1395, 1271, 1275, ..., 1460, 1567, 1423],\n        [1355, 1260, 1347, ..., 1450, 1584, 1385],\n        [1396, 1360, 1502, ..., 1483, 1569, 1326],\n        ...,\n        [1570, 1585, 1595, ..., 1159, 1160, 1147],\n        [1563, 1572, 1578, ..., 1151, 1133, 1105],\n        [1555, 1576, 1562, ..., 1147, 1135, 1112]],\n\n       [[1398, 1301, 1320, ..., 1560, 1629, 1459],\n        [1386, 1319, 1403, ..., 1608, 1605, 1418],\n        [1417, 1401, 1544, ..., 1633, 1561, 1377],\n        ...,\n        [1690, 1699, 1687, ..., 1216, 1218, 1215],\n        [1665, 1670, 1666, ..., 1213, 1208, 1195],\n        [1653, 1647, 1652, ..., 1204, 1208, 1191]]], dtype=uint16)</code>\n</pre> <p>Plot the data that we have read</p> <pre><code>%%time\n\nimport rasterio.plot as rstplt\nimport numpy as np\n\n# From processing baseline PB04.00  values have an offset of 1_000. \n# This is handled automatically by the load function\nrstplt.show(np.clip(data_memory.values/3_000,0,1), transform=data_memory.transform)\n</code></pre> <pre>\n<code>CPU times: user 3.99 s, sys: 498 ms, total: 4.49 s\nWall time: 4.6 s\n</code>\n</pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code># import shutil\n\n# if os.path.exists(\"deleteme\"):\n#     shutil.rmtree(\"deleteme\")\n</code></pre> <pre><code>\n</code></pre>"},{"location":"read_S2_SAFE_from_bucket/#read-sentinel-2-files-from-public-bucket","title":"Read Sentinel-2 files from public bucket","text":"<ul> <li>Author: Gonzalo Mateo-Garc\u00eda</li> </ul> <p>This notebook shows how to read a Sentinel-2 SAFE file from the public Google bucket and reading a subset of it.</p>"},{"location":"read_S2_SAFE_from_bucket/#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite:</p> <pre><code>@article{portales-julia_global_2023,\n    title = {Global flood extent segmentation in optical satellite images},\n    volume = {13},\n    issn = {2045-2322},\n    doi = {10.1038/s41598-023-47595-7},\n    number = {1},\n    urldate = {2023-11-30},\n    journal = {Scientific Reports},\n    author = {Portal\u00e9s-Juli\u00e0, Enrique and Mateo-Garc\u00eda, Gonzalo and Purcell, Cormac and G\u00f3mez-Chova, Luis},\n    month = nov,\n    year = {2023},\n    pages = {20316},\n}\n</code></pre>"},{"location":"read_overlapping_probav_and_sentinel2/","title":"Overlapping S2 and Proba-V","text":"<p>Download the Proba-V image</p> <pre><code>from georeader.readers import download_pv_product\n\nlink_pv_product = \"https://www.vito-eodata.be/PDF/datapool/Free_Data/PROBA-V_100m/S1_TOA_100_m_C1/2019/2/9/PV_S1_TOA-20190209_100M_V101/PROBAV_S1_TOA_X07Y05_20190209_100M_V101.HDF5\"\nfilename_down = download_pv_product.download_product(link_pv_product)\nfilename_down\n</code></pre> <pre>\n<code>File PROBAV_S1_TOA_X07Y05_20190209_100M_V101.HDF5 exists. It won't be downloaded again\n</code>\n</pre> <pre><code>%%time\n\nfrom georeader.readers import probav_image_operational\n\ntoa_reader = probav_image_operational.ProbaVRadiometry(filename_down, level_name=\"LEVEL3\")\ntoa_reader\n</code></pre> <pre>\n<code>CPU times: user 807 ms, sys: 164 ms, total: 972 ms\nWall time: 1.88 s\n</code>\n</pre> <pre>\n<code>/home/gonzalo/miniconda3/envs/starcop/lib/python3.9/site-packages/tqdm/auto.py:22: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</code>\n</pre> <pre>\n<code> \n         File: PROBAV_S1_TOA_X07Y05_20190209_100M_V101.HDF5\n         Transform: | 0.00, 0.00,-110.00|\n| 0.00,-0.00, 25.00|\n| 0.00, 0.00, 1.00|\n         Shape: 10080, 10080\n         Resolution: (0.000992063492063, 0.000992063492063)\n         Bounds: (-110.0, 15.00000000000496, -100.00000000000496, 25.0)\n         CRS: {'init': 'epsg:4326'}\n         Level: LEVEL3\n         TOA/TOC: TOA\n         Resolution name : 100M\n        </code>\n</pre> <pre><code>toa_reader.assert_can_be_read()\n# If this raises an error reinstall h5py with pip and reset the notebook:\n# pip install h5py --no-deps --ignore-installed\n</code></pre> <pre><code>from georeader.rasterio_reader import RasterioReader\n\ns2reader = RasterioReader(\"S2L1C.tif\")\ns2reader\n</code></pre> <pre>\n<code> \n         Paths: ['S2L1C.tif']\n         Transform: | 10.00, 0.00, 770950.00|\n| 0.00,-10.00, 2696720.00|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 509, 509)\n         Resolution: (10.0, 10.0)\n         Bounds: (770950.0, 2691630.0, 776040.0, 2696720.0)\n         CRS: EPSG:32613\n         nodata: None\n         fill_value_default: 0\n        </code>\n</pre> <p>Band names are stored in the <code>descriptions</code> attribute</p> <pre><code>s2reader.descriptions\n</code></pre> <pre>\n<code>['B1',\n 'B2',\n 'B3',\n 'B4',\n 'B5',\n 'B6',\n 'B7',\n 'B8',\n 'B8A',\n 'B9',\n 'B10',\n 'B11',\n 'B12']</code>\n</pre> <p>Set the reader to read the BLUE, RED NIR and SWIR bands of Sentinel-2 that are equivalent to the bands of Proba-V.</p> <pre><code>s2reader.set_indexes_by_name([\"B2\",\"B4\", \"B8\",\"B11\"])\ns2reader\n</code></pre> <pre>\n<code> \n         Paths: ['S2L1C.tif']\n         Transform: | 10.00, 0.00, 770950.00|\n| 0.00,-10.00, 2696720.00|\n| 0.00, 0.00, 1.00|\n         Shape: (4, 509, 509)\n         Resolution: (10.0, 10.0)\n         Bounds: (770950.0, 2691630.0, 776040.0, 2696720.0)\n         CRS: EPSG:32613\n         nodata: None\n         fill_value_default: 0\n        </code>\n</pre> <pre><code># Read image in memory\ns2reader_memory = s2reader.load()\ns2reader_memory.values\n</code></pre> <pre>\n<code>array([[[ 998.,  976.,  954., ...,  948.,  879.,  995.],\n        [1013.,  956.,  942., ..., 1181., 1133., 1080.],\n        [1028.,  957.,  989., ..., 1125., 1173., 1257.],\n        ...,\n        [1596., 1579., 1472., ..., 1203., 1256., 1191.],\n        [1548., 1433., 1360., ..., 1296., 1325., 1225.],\n        [1550., 1539., 1377., ..., 1406., 1371., 1298.]],\n\n       [[1032., 1015.,  899., ...,  930.,  848.,  988.],\n        [1045.,  948.,  891., ..., 1296., 1209., 1164.],\n        [1119.,  918.,  988., ..., 1233., 1334., 1502.],\n        ...,\n        [2360., 2318., 2084., ..., 1491., 1541., 1490.],\n        [2305., 2049., 1953., ..., 1650., 1685., 1476.],\n        [2366., 2126., 2023., ..., 1815., 1730., 1642.]],\n\n       [[1387., 1377., 1191., ..., 1262., 1103., 1283.],\n        [1374., 1262., 1195., ..., 1635., 1580., 1559.],\n        [1432., 1319., 1351., ..., 1501., 1747., 1885.],\n        ...,\n        [2563., 2576., 2363., ..., 1943., 1975., 1939.],\n        [2527., 2290., 2204., ..., 2173., 2085., 1940.],\n        [2630., 2472., 2259., ..., 2355., 2178., 2146.]],\n\n       [[2583., 2502., 2502., ..., 2716., 2732., 2732.],\n        [2583., 2502., 2502., ..., 2716., 2732., 2732.],\n        [2691., 2545., 2545., ..., 2653., 2852., 2852.],\n        ...,\n        [3995., 3813., 3813., ..., 3097., 3066., 3066.],\n        [3995., 3813., 3813., ..., 3097., 3066., 3066.],\n        [4063., 3725., 3725., ..., 3314., 3262., 3262.]]], dtype=float32)</code>\n</pre> <pre><code>%%time\nfrom georeader import read\n\ntile_read = read.read_from_bounds(toa_reader, bounds=s2reader.bounds, crs_bounds=s2reader.crs,\n                                  pad_add=(50, 50))\ntile_read\n</code></pre> <pre>\n<code>CPU times: user 18.8 ms, sys: 0 ns, total: 18.8 ms\nWall time: 34 ms\n</code>\n</pre> <pre>\n<code> \n         File: PROBAV_S1_TOA_X07Y05_20190209_100M_V101.HDF5\n         Transform: | 0.00, 0.00,-102.38|\n| 0.00,-0.00, 24.41|\n| 0.00, 0.00, 1.00|\n         Shape: 148, 152\n         Resolution: (0.000992063492063, 0.000992063492063)\n         Bounds: (-102.3799603174641, 24.263888888889255, -102.22916666667052, 24.41071428571458)\n         CRS: {'init': 'epsg:4326'}\n         Level: LEVEL3\n         TOA/TOC: TOA\n         Resolution name : 100M\n        </code>\n</pre> <pre><code>tile_read_memory = tile_read.load()\ntile_read_memory.values\n</code></pre> <pre>\n<code>array([[[0.1295, 0.1285, 0.1255, ..., 0.151 , 0.152 , 0.149 ],\n        [0.1315, 0.1305, 0.129 , ..., 0.15  , 0.15  , 0.1515],\n        [0.131 , 0.135 , 0.137 , ..., 0.1495, 0.1475, 0.143 ],\n        ...,\n        [0.2445, 0.2405, 0.238 , ..., 0.1335, 0.1365, 0.136 ],\n        [0.2415, 0.238 , 0.233 , ..., 0.138 , 0.131 , 0.1355],\n        [0.237 , 0.2385, 0.234 , ..., 0.135 , 0.1275, 0.1365]],\n\n       [[0.1205, 0.1185, 0.119 , ..., 0.1725, 0.1745, 0.176 ],\n        [0.1185, 0.1205, 0.1275, ..., 0.1705, 0.1715, 0.172 ],\n        [0.1265, 0.1465, 0.155 , ..., 0.167 , 0.164 , 0.163 ],\n        ...,\n        [0.249 , 0.2455, 0.243 , ..., 0.116 , 0.1255, 0.122 ],\n        [0.245 , 0.2395, 0.236 , ..., 0.1325, 0.124 , 0.1225],\n        [0.2385, 0.2325, 0.2255, ..., 0.123 , 0.1115, 0.125 ]],\n\n       [[0.156 , 0.154 , 0.153 , ..., 0.227 , 0.2335, 0.229 ],\n        [0.153 , 0.1575, 0.165 , ..., 0.2245, 0.2245, 0.2305],\n        [0.1625, 0.18  , 0.196 , ..., 0.2225, 0.22  , 0.218 ],\n        ...,\n        [0.286 , 0.286 , 0.2855, ..., 0.173 , 0.182 , 0.174 ],\n        [0.2845, 0.2785, 0.277 , ..., 0.1825, 0.1735, 0.1725],\n        [0.2795, 0.2755, 0.2695, ..., 0.171 , 0.154 , 0.1695]],\n\n       [[0.228 , 0.2295, 0.2325, ..., 0.36  , 0.3575, 0.3555],\n        [0.237 , 0.2425, 0.2485, ..., 0.363 , 0.3575, 0.3565],\n        [0.248 , 0.2555, 0.261 , ..., 0.3625, 0.352 , 0.349 ],\n        ...,\n        [0.302 , 0.3015, 0.3005, ..., 0.2235, 0.228 , 0.2365],\n        [0.3005, 0.2995, 0.298 , ..., 0.2265, 0.229 , 0.2405],\n        [0.3015, 0.299 , 0.297 , ..., 0.2275, 0.232 , 0.2465]]],\n      dtype=float32)</code>\n</pre> <pre><code>%%time\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# SWIR, NIR, RED composite\nrgb_show = np.transpose(tile_read.values[:0:-1],(1,2,0))\nplt.imshow(rgb_show)\n</code></pre> <pre>\n<code>CPU times: user 627 ms, sys: 19.1 ms, total: 646 ms\nWall time: 712 ms\n</code>\n</pre> <pre>\n<code>&lt;matplotlib.image.AxesImage at 0x7fa66f827c70&gt;</code>\n</pre> <pre><code>plt.imshow(np.clip(s2reader_memory.values[:0:-1]/10_000,0,1).transpose((1,2,0)))\n</code></pre> <pre>\n<code>&lt;matplotlib.image.AxesImage at 0x7fa665f3e3d0&gt;</code>\n</pre> <pre><code>probav_100m_utm = read.read_reproject(toa_reader, bounds=s2reader.bounds, dst_crs=s2reader.crs,\n                                      resolution_dst_crs=100)\nprobav_100m_utm\n</code></pre> <pre>\n<code> \n         Transform: | 100.00, 0.00, 770950.00|\n| 0.00,-100.00, 2696720.00|\n| 0.00, 0.00, 1.00|\n         Shape: (4, 51, 51)\n         Resolution: (100.0, 100.0)\n         Bounds: (770950.0, 2691620.0, 776050.0, 2696720.0)\n         CRS: EPSG:32613\n         fill_value_default: -0.0005\n        </code>\n</pre> <p>Secondly we will reproject Sentinel-2 to 100m using an anti-aliasing filter to avoid artifacts.</p> <pre><code>s2reader_memory.set_dtype(np.float32) # Convert to float to avoid resampling errors!\n\ns2_100m = read.resize(s2reader_memory, resolution_dst=100, anti_aliasing=True)\ns2_100m\n</code></pre> <pre>\n<code> \n         Transform: | 100.00, 0.00, 770950.00|\n| 0.00,-100.00, 2696720.00|\n| 0.00, 0.00, 1.00|\n         Shape: (4, 51, 51)\n         Resolution: (100.0, 100.0)\n         Bounds: (770950.0, 2691620.0, 776050.0, 2696720.0)\n         CRS: EPSG:32613\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>fig, ax = plt.subplots(2,3,figsize=(18,12))\nax[0,0].imshow(probav_100m_utm.values[:0:-1].transpose((1,2,0)))\nax[0,0].set_title(\"Proba-V 100m (UTM grid) SWIR/NIR/RED\")\nax[0,1].imshow(np.clip(s2_100m.values[:0:-1].transpose((1,2,0))/10_000,0,1))\nax[0,1].set_title(\"Sentinel-2 100m SWIR/NIR/RED\")\nax[0,2].imshow(np.clip(s2reader_memory.values[:0:-1].transpose((1,2,0))/10_000,0,1))\nax[0,2].set_title(\"Sentinel-2 10m SWIR/NIR/RED\")\n\nax[1,0].imshow(probav_100m_utm.values[-2::-1].transpose((1,2,0)))\nax[1,0].set_title(\"Proba-V 100m (UTM grid) NIR/RED/BLUE\")\nax[1,1].imshow(np.clip(s2_100m.values[-2::-1].transpose((1,2,0))/10_000,0,1))\nax[1,1].set_title(\"Sentinel-2 100m NIR/RED/BLUE\")\nax[1,2].imshow(np.clip(s2reader_memory.values[-2::-1].transpose((1,2,0))/10_000,0,1))\nax[1,2].set_title(\"Sentinel-2 10m NIR/RED/BLUE\")\n</code></pre> <pre>\n<code>Text(0.5, 1.0, 'Sentinel-2 10m NIR/RED/BLUE')</code>\n</pre>"},{"location":"read_overlapping_probav_and_sentinel2/#read-overlapping-images-from-proba-v-and-sentinel-2","title":"Read overlapping images from Proba-V and Sentinel-2","text":"<p>Given a Sentinel-2 GeoTIFF file from the CloudSEN12 dataset and a Proba-V image we will show how to read the overlapping regions of those two using the georeader package.</p> <p>The Sentinel-2 image from CloudSEN12 that we will use in this tutorial is: <code>cloudsen12/high/point_0317/20190207T172509_20190207T173213_T13QGG/S2L1C.tif</code>. In order to proceed you need to download the image and store it in the same directory as this tutorial.</p>"},{"location":"read_overlapping_probav_and_sentinel2/#install-package-with-proba-v-dependecies","title":"Install package with Proba-V dependecies","text":"<pre><code>pip install git+https://github.com/spaceml-org/georeader#egg=georeader[probav]\n</code></pre>"},{"location":"read_overlapping_probav_and_sentinel2/#inspect-proba-v-products","title":"Inspect Proba-V products","text":"<p>Prova-V images are very large (10,080x10,080 pixels). Therefore we should avoid read them all in memory if possible.</p>"},{"location":"read_overlapping_probav_and_sentinel2/#warning","title":"Warning!!","text":"<p>To read the Proba-V image content the <code>h5py</code> package requires an special compression. If installed from conda this compressor is not available. Therefore, re-install h5py from pip if the following cell fails!</p> <p><code>pip install h5py --no-deps --ignore-installed</code></p>"},{"location":"read_overlapping_probav_and_sentinel2/#read-sentinel-2-file-of-the-cloudsen12-dataset","title":"Read Sentinel-2 file of the cloudSEN12 dataset","text":""},{"location":"read_overlapping_probav_and_sentinel2/#read-proba-v-image-within-the-bounds-of-the-sentinel-2","title":"Read Proba-V image within the bounds of the Sentinel-2","text":""},{"location":"read_overlapping_probav_and_sentinel2/#reproject-proba-v-and-sentinel-2","title":"Reproject Proba-V and Sentinel-2","text":"<p>First we will reproject the Proba-V image to the UTM crs of Sentinel-2 at a 100m resolution</p>"},{"location":"read_overlapping_probav_and_sentinel2/#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite:</p> <pre><code>@article{portales-julia_global_2023,\n    title = {Global flood extent segmentation in optical satellite images},\n    volume = {13},\n    issn = {2045-2322},\n    doi = {10.1038/s41598-023-47595-7},\n    number = {1},\n    urldate = {2023-11-30},\n    journal = {Scientific Reports},\n    author = {Portal\u00e9s-Juli\u00e0, Enrique and Mateo-Garc\u00eda, Gonzalo and Purcell, Cormac and G\u00f3mez-Chova, Luis},\n    month = nov,\n    year = {2023},\n    pages = {20316},\n}\n</code></pre>"},{"location":"reading_overlapping_sentinel2_aviris/","title":"Overlapping S2 and AVIRIS","text":"<p>Step 1: Create the reader object for the AVIRIS image</p> <pre><code>%%time\n\nfrom georeader.rasterio_reader import RasterioReader\n\naviris_reader = RasterioReader(\"/home/gonzalo/Downloads/permian_2019/permian_2019/ang20190928t185111-4_r6871_c424_rgb.tif\")\naviris_reader\n</code></pre> <pre>\n<code>CPU times: user 519 ms, sys: 1.84 s, total: 2.36 s\nWall time: 163 ms\n</code>\n</pre> <pre>\n<code> \n         Paths: ['/home/gonzalo/Downloads/permian_2019/permian_2019/ang20190928t185111-4_r6871_c424_rgb.tif']\n         Transform: | 5.99, 4.35, 592577.80|\n| 4.35,-5.99, 3519916.50|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 151, 151)\n         Resolution: (7.400000000000001, 7.400000000000001)\n         Bounds: (592577.7996484624, 3519012.5018222863, 594138.5864788886, 3520573.2886527125)\n         CRS: EPSG:32613\n         nodata: None\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>%%time\n\naviris_reader_in_memory = aviris_reader.load()\naviris_reader_in_memory.values\n</code></pre> <pre>\n<code>CPU times: user 0 ns, sys: 2.35 ms, total: 2.35 ms\nWall time: 2.35 ms\n</code>\n</pre> <pre>\n<code>array([[[253, 254, 237, ..., 187, 181, 134],\n        [231, 221, 199, ..., 203, 197, 164],\n        [193, 194, 194, ..., 212, 202, 193],\n        ...,\n        [ 90,  88,  88, ..., 183, 160, 170],\n        [ 92,  95,  95, ..., 192, 172, 181],\n        [ 88,  93,  89, ..., 194, 187, 210]],\n\n       [[235, 230, 213, ..., 172, 165, 131],\n        [216, 203, 181, ..., 185, 180, 153],\n        [184, 178, 177, ..., 189, 182, 178],\n        ...,\n        [ 96,  96,  96, ..., 183, 162, 171],\n        [ 99, 100, 100, ..., 191, 173, 181],\n        [ 97,  98,  96, ..., 193, 185, 205]],\n\n       [[190, 183, 163, ..., 148, 141, 116],\n        [174, 165, 142, ..., 151, 152, 129],\n        [151, 145, 143, ..., 148, 147, 148],\n        ...,\n        [102, 101, 100, ..., 166, 149, 155],\n        [103, 104, 103, ..., 173, 158, 163],\n        [102, 102, 100, ..., 175, 167, 180]]], dtype=uint8)</code>\n</pre> <p>Step 2: Create the reader object for the Sentinel-2 image</p> <pre><code>%%time\n\nimport os\nfrom georeader.readers import S2_SAFE_reader\n# This is required to do advaced operations in the GCP bucket\n# os.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"path/to/file.json\"\n# os.environ[\"GS_USER_PROJECT\"] = \"project-name\"\n# S2_SAFE_reader.DEFAULT_REQUESTER_PAYS=True\n\nos.environ[\"GS_NO_SIGN_REQUEST\"] = \"YES\"\n\n# Read only RGB bands\n\ns2path = \"gs://gcp-public-data-sentinel-2/tiles/13/S/ER/S2B_MSIL1C_20190928T173109_N0208_R055_T13SER_20190928T205958.SAFE\"\ns2_reader = S2_SAFE_reader.s2loader(s2path, out_res=10, bands=[\"B04\", \"B03\", \"B02\"])\ns2_reader\n</code></pre> <pre>\n<code>CPU times: user 229 ms, sys: 27.4 ms, total: 257 ms\nWall time: 344 ms\n</code>\n</pre> <pre>\n<code> \n         gs://gcp-public-data-sentinel-2/tiles/13/S/ER/S2B_MSIL1C_20190928T173109_N0208_R055_T13SER_20190928T205958.SAFE\n         Transform: | 10.00, 0.00, 499980.00|\n| 0.00,-10.00, 3600000.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 10980, 10980)\n         Resolution: (10.0, 10.0)\n         Bounds: (499980.0, 3490200.0, 609780.0, 3600000.0)\n         CRS: EPSG:32613\n         bands: ['B04', 'B03', 'B02']\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>%%time\n\nfrom georeader import read\n\ns2_at_aviris_loc = read.read_from_bounds(s2_reader, aviris_reader_in_memory.bounds, crs_bounds=aviris_reader_in_memory.crs)\ns2_at_aviris_loc\n</code></pre> <pre>\n<code>CPU times: user 4.13 ms, sys: 180 \u00b5s, total: 4.31 ms\nWall time: 3.28 ms\n</code>\n</pre> <pre>\n<code> \n         gs://gcp-public-data-sentinel-2/tiles/13/S/ER/S2B_MSIL1C_20190928T173109_N0208_R055_T13SER_20190928T205958.SAFE\n         Transform: | 10.00, 0.00, 592570.00|\n| 0.00,-10.00, 3520580.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 157, 157)\n         Resolution: (10.0, 10.0)\n         Bounds: (592570.0, 3519010.0, 594140.0, 3520580.0)\n         CRS: EPSG:32613\n         bands: ['B04', 'B03', 'B02']\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>%%time\ns2_at_aviris_loc_in_memory = s2_at_aviris_loc.load()\ns2_at_aviris_loc_in_memory.values\n</code></pre> <pre>\n<code>CPU times: user 772 ms, sys: 203 ms, total: 976 ms\nWall time: 24.5 s\n</code>\n</pre> <pre>\n<code>array([[[2387, 2649, 2654, ..., 2302, 2292, 2241],\n        [2244, 2454, 2630, ..., 2412, 2376, 2339],\n        [2540, 2432, 2373, ..., 2473, 2442, 2403],\n        ...,\n        [1347, 1312, 1325, ..., 1851, 2073, 2010],\n        [1268, 1265, 1368, ..., 2194, 2193, 2098],\n        [1261, 1293, 1392, ..., 2235, 2018, 1881]],\n\n       [[1803, 1946, 1970, ..., 1802, 1801, 1754],\n        [1739, 1879, 1971, ..., 1873, 1876, 1810],\n        [1914, 1862, 1796, ..., 1920, 1888, 1867],\n        ...,\n        [1265, 1239, 1268, ..., 1611, 1750, 1705],\n        [1194, 1210, 1283, ..., 1815, 1851, 1770],\n        [1181, 1214, 1271, ..., 1886, 1671, 1626]],\n\n       [[1622, 1689, 1683, ..., 1621, 1653, 1576],\n        [1517, 1632, 1690, ..., 1677, 1696, 1624],\n        [1665, 1637, 1614, ..., 1718, 1703, 1637],\n        ...,\n        [1294, 1302, 1299, ..., 1459, 1566, 1569],\n        [1288, 1256, 1333, ..., 1617, 1599, 1591],\n        [1273, 1266, 1350, ..., 1662, 1561, 1474]]], dtype=uint16)</code>\n</pre> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(1,2,figsize=(12,6))\nax[0].imshow(aviris_reader_in_memory.values.transpose((1,2,0)))\nax[1].imshow(np.clip(s2_at_aviris_loc_in_memory.values/3_500,0,1).transpose((1,2,0)))\n</code></pre> <pre>\n<code>&lt;matplotlib.image.AxesImage at 0x7f90b4eba080&gt;</code>\n</pre> <pre><code>from georeader import dataarray\ndr = dataarray.toDataArray(s2_at_aviris_loc_in_memory)\ndr\n</code></pre> <pre>&lt;xarray.DataArray (band: 3, y: 157, x: 157)&gt; Size: 148kB\narray([[[2387, 2649, 2654, ..., 2302, 2292, 2241],\n        [2244, 2454, 2630, ..., 2412, 2376, 2339],\n        [2540, 2432, 2373, ..., 2473, 2442, 2403],\n        ...,\n        [1347, 1312, 1325, ..., 1851, 2073, 2010],\n        [1268, 1265, 1368, ..., 2194, 2193, 2098],\n        [1261, 1293, 1392, ..., 2235, 2018, 1881]],\n\n       [[1803, 1946, 1970, ..., 1802, 1801, 1754],\n        [1739, 1879, 1971, ..., 1873, 1876, 1810],\n        [1914, 1862, 1796, ..., 1920, 1888, 1867],\n        ...,\n        [1265, 1239, 1268, ..., 1611, 1750, 1705],\n        [1194, 1210, 1283, ..., 1815, 1851, 1770],\n        [1181, 1214, 1271, ..., 1886, 1671, 1626]],\n\n       [[1622, 1689, 1683, ..., 1621, 1653, 1576],\n        [1517, 1632, 1690, ..., 1677, 1696, 1624],\n        [1665, 1637, 1614, ..., 1718, 1703, 1637],\n        ...,\n        [1294, 1302, 1299, ..., 1459, 1566, 1569],\n        [1288, 1256, 1333, ..., 1617, 1599, 1591],\n        [1273, 1266, 1350, ..., 1662, 1561, 1474]]], dtype=uint16)\nCoordinates:\n  * x        (x) float64 1kB 5.926e+05 5.926e+05 ... 5.941e+05 5.941e+05\n  * y        (y) float64 1kB 3.521e+06 3.521e+06 ... 3.519e+06 3.519e+06\nDimensions without coordinates: band\nAttributes:\n    crs:      EPSG:32613</pre>xarray.DataArray <p><ul><li>band: 3</li><li>y: 157</li><li>x: 157</li></ul></p> <p><ul><li>2387 2649 2654 2512 2296 2217 2333 ... 1510 1484 1662 1662 1561 1474 <p><pre>array([[[2387, 2649, 2654, ..., 2302, 2292, 2241],\n        [2244, 2454, 2630, ..., 2412, 2376, 2339],\n        [2540, 2432, 2373, ..., 2473, 2442, 2403],\n        ...,\n        [1347, 1312, 1325, ..., 1851, 2073, 2010],\n        [1268, 1265, 1368, ..., 2194, 2193, 2098],\n        [1261, 1293, 1392, ..., 2235, 2018, 1881]],\n<pre><code>   [[1803, 1946, 1970, ..., 1802, 1801, 1754],\n    [1739, 1879, 1971, ..., 1873, 1876, 1810],\n    [1914, 1862, 1796, ..., 1920, 1888, 1867],\n    ...,\n    [1265, 1239, 1268, ..., 1611, 1750, 1705],\n    [1194, 1210, 1283, ..., 1815, 1851, 1770],\n    [1181, 1214, 1271, ..., 1886, 1671, 1626]],\n\n   [[1622, 1689, 1683, ..., 1621, 1653, 1576],\n    [1517, 1632, 1690, ..., 1677, 1696, 1624],\n    [1665, 1637, 1614, ..., 1718, 1703, 1637],\n    ...,\n    [1294, 1302, 1299, ..., 1459, 1566, 1569],\n    [1288, 1256, 1333, ..., 1617, 1599, 1591],\n    [1273, 1266, 1350, ..., 1662, 1561, 1474]]], dtype=uint16)&lt;/pre&gt;\n</code></pre>\n\n\n\n<li>Coordinates: (2)<ul><li>x(x)float645.926e+05 5.926e+05 ... 5.941e+05<pre>array([592575., 592585., 592595., 592605., 592615., 592625., 592635., 592645.,\n       592655., 592665., 592675., 592685., 592695., 592705., 592715., 592725.,\n       592735., 592745., 592755., 592765., 592775., 592785., 592795., 592805.,\n       592815., 592825., 592835., 592845., 592855., 592865., 592875., 592885.,\n       592895., 592905., 592915., 592925., 592935., 592945., 592955., 592965.,\n       592975., 592985., 592995., 593005., 593015., 593025., 593035., 593045.,\n       593055., 593065., 593075., 593085., 593095., 593105., 593115., 593125.,\n       593135., 593145., 593155., 593165., 593175., 593185., 593195., 593205.,\n       593215., 593225., 593235., 593245., 593255., 593265., 593275., 593285.,\n       593295., 593305., 593315., 593325., 593335., 593345., 593355., 593365.,\n       593375., 593385., 593395., 593405., 593415., 593425., 593435., 593445.,\n       593455., 593465., 593475., 593485., 593495., 593505., 593515., 593525.,\n       593535., 593545., 593555., 593565., 593575., 593585., 593595., 593605.,\n       593615., 593625., 593635., 593645., 593655., 593665., 593675., 593685.,\n       593695., 593705., 593715., 593725., 593735., 593745., 593755., 593765.,\n       593775., 593785., 593795., 593805., 593815., 593825., 593835., 593845.,\n       593855., 593865., 593875., 593885., 593895., 593905., 593915., 593925.,\n       593935., 593945., 593955., 593965., 593975., 593985., 593995., 594005.,\n       594015., 594025., 594035., 594045., 594055., 594065., 594075., 594085.,\n       594095., 594105., 594115., 594125., 594135.])</pre></li><li>y(y)float643.521e+06 3.521e+06 ... 3.519e+06<pre>array([3520575., 3520565., 3520555., 3520545., 3520535., 3520525., 3520515.,\n       3520505., 3520495., 3520485., 3520475., 3520465., 3520455., 3520445.,\n       3520435., 3520425., 3520415., 3520405., 3520395., 3520385., 3520375.,\n       3520365., 3520355., 3520345., 3520335., 3520325., 3520315., 3520305.,\n       3520295., 3520285., 3520275., 3520265., 3520255., 3520245., 3520235.,\n       3520225., 3520215., 3520205., 3520195., 3520185., 3520175., 3520165.,\n       3520155., 3520145., 3520135., 3520125., 3520115., 3520105., 3520095.,\n       3520085., 3520075., 3520065., 3520055., 3520045., 3520035., 3520025.,\n       3520015., 3520005., 3519995., 3519985., 3519975., 3519965., 3519955.,\n       3519945., 3519935., 3519925., 3519915., 3519905., 3519895., 3519885.,\n       3519875., 3519865., 3519855., 3519845., 3519835., 3519825., 3519815.,\n       3519805., 3519795., 3519785., 3519775., 3519765., 3519755., 3519745.,\n       3519735., 3519725., 3519715., 3519705., 3519695., 3519685., 3519675.,\n       3519665., 3519655., 3519645., 3519635., 3519625., 3519615., 3519605.,\n       3519595., 3519585., 3519575., 3519565., 3519555., 3519545., 3519535.,\n       3519525., 3519515., 3519505., 3519495., 3519485., 3519475., 3519465.,\n       3519455., 3519445., 3519435., 3519425., 3519415., 3519405., 3519395.,\n       3519385., 3519375., 3519365., 3519355., 3519345., 3519335., 3519325.,\n       3519315., 3519305., 3519295., 3519285., 3519275., 3519265., 3519255.,\n       3519245., 3519235., 3519225., 3519215., 3519205., 3519195., 3519185.,\n       3519175., 3519165., 3519155., 3519145., 3519135., 3519125., 3519115.,\n       3519105., 3519095., 3519085., 3519075., 3519065., 3519055., 3519045.,\n       3519035., 3519025., 3519015.])</pre></li></ul></li>\n<li>Indexes: (2)<ul><li>xPandasIndex<pre>PandasIndex(Index([592575.0, 592585.0, 592595.0, 592605.0, 592615.0, 592625.0, 592635.0,\n       592645.0, 592655.0, 592665.0,\n       ...\n       594045.0, 594055.0, 594065.0, 594075.0, 594085.0, 594095.0, 594105.0,\n       594115.0, 594125.0, 594135.0],\n      dtype='float64', name='x', length=157))</pre></li><li>yPandasIndex<pre>PandasIndex(Index([3520575.0, 3520565.0, 3520555.0, 3520545.0, 3520535.0, 3520525.0,\n       3520515.0, 3520505.0, 3520495.0, 3520485.0,\n       ...\n       3519105.0, 3519095.0, 3519085.0, 3519075.0, 3519065.0, 3519055.0,\n       3519045.0, 3519035.0, 3519025.0, 3519015.0],\n      dtype='float64', name='y', length=157))</pre></li></ul></li>\n<li>Attributes: (1)crs :EPSG:32613</li>\n<p>\n\n\n\n\n</p>\n\n\n\n<pre><code>geotensorback = dataarray.fromDataArray(dr)\ngeotensorback\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code> \n         Transform: | 10.00, 0.00, 592570.00|\n| 0.00,-10.00, 3520580.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 157, 157)\n         Resolution: (10.0, 10.0)\n         Bounds: (592570.0, 3519010.0, 594140.0, 3520580.0)\n         CRS: EPSG:32613\n         fill_value_default: 0\n        </code>\n</pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<pre><code>center_coords_aviris = aviris_reader_in_memory.transform * (aviris_reader_in_memory.shape[1] / 2, aviris_reader_in_memory.shape[0] / 2)\ncenter_coords_aviris\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code>(593036.3218595202, 3520235.9129436193)</code>\n</pre>\n\n\n\n\n\n\n\n\n<pre><code>%%time\n\n\ns2_at_aviris_loc = read.read_from_center_coords(s2_reader, shape=(150,150),\n                                                center_coords=center_coords_aviris, crs_center_coords=aviris_reader_in_memory.crs)\ns2_at_aviris_loc\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code>CPU times: user 5.6 ms, sys: 560 \u00b5s, total: 6.16 ms\nWall time: 4.71 ms\n</code>\n</pre>\n\n\n\n\n<pre>\n<code> \n         gs://gcp-public-data-sentinel-2/tiles/13/S/ER/S2B_MSIL1C_20190928T173109_N0208_R055_T13SER_20190928T205958.SAFE\n         Transform: | 10.00, 0.00, 592290.00|\n| 0.00,-10.00, 3520990.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 150, 150)\n         Resolution: (10.0, 10.0)\n         Bounds: (592290.0, 3519490.0, 593790.0, 3520990.0)\n         CRS: EPSG:32613\n         bands: ['B04', 'B03', 'B02']\n         fill_value_default: 0\n        </code>\n</pre>\n\n\n\n\n\n\n\n\n<pre><code>%%time\ns2_at_aviris_loc_in_memory = s2_at_aviris_loc.load()\ns2_at_aviris_loc_in_memory.values\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code>CPU times: user 857 ms, sys: 9.61 ms, total: 867 ms\nWall time: 117 ms\n</code>\n</pre>\n\n\n\n\n<pre>\n<code>array([[[2403, 2577, 2603, ..., 1957, 2000, 1975],\n        [2360, 2327, 2266, ..., 2012, 1952, 1887],\n        [2298, 2156, 2188, ..., 2026, 2011, 1925],\n        ...,\n        [2368, 2257, 2093, ..., 2197, 2050, 2044],\n        [2316, 2276, 2117, ..., 2418, 2195, 1936],\n        [2370, 2346, 2337, ..., 2401, 2182, 1805]],\n\n       [[1962, 2124, 2189, ..., 1695, 1664, 1711],\n        [1895, 1891, 1861, ..., 1690, 1675, 1602],\n        [1864, 1769, 1811, ..., 1715, 1789, 1610],\n        ...,\n        [1842, 1765, 1661, ..., 1756, 1714, 1698],\n        [1817, 1764, 1653, ..., 1955, 1785, 1633],\n        [1880, 1804, 1762, ..., 1932, 1752, 1546]],\n\n       [[1777, 1899, 1964, ..., 1584, 1567, 1603],\n        [1688, 1676, 1719, ..., 1580, 1540, 1509],\n        [1640, 1561, 1644, ..., 1649, 1626, 1526],\n        ...,\n        [1589, 1559, 1443, ..., 1647, 1579, 1553],\n        [1613, 1565, 1441, ..., 1705, 1601, 1534],\n        [1627, 1575, 1521, ..., 1764, 1610, 1461]]], dtype=uint16)</code>\n</pre>\n\n\n\n\n\n\n\n\n<pre><code>fig, ax = plt.subplots(1,2,figsize=(12,6))\nax[0].imshow(aviris_reader_in_memory.values.transpose((1,2,0)))\nax[1].imshow(np.clip(s2_at_aviris_loc_in_memory.values/3_500,0,1).transpose((1,2,0)))\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code>&lt;matplotlib.image.AxesImage at 0x7f90b44a6200&gt;</code>\n</pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<pre><code>%%time\n\ns2_at_aviris_loc = read.read_reproject_like(s2_reader, aviris_reader_in_memory)\ns2_at_aviris_loc\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code>CPU times: user 773 ms, sys: 5.81 ms, total: 779 ms\nWall time: 127 ms\n</code>\n</pre>\n\n\n\n\n<pre>\n<code> \n         Transform: | 5.99, 4.35, 592577.80|\n| 4.35,-5.99, 3519916.50|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 151, 151)\n         Resolution: (7.400000000038687, 7.399999999944504)\n         Bounds: (592577.7996484624, 3519012.5018222863, 594138.5864788886, 3520573.2886527125)\n         CRS: EPSG:32613\n         fill_value_default: 0\n        </code>\n</pre>\n\n\n\n\n\n\n\n\n<pre><code>fig, ax = plt.subplots(1,2,figsize=(12,6))\nax[0].imshow(aviris_reader_in_memory.values.transpose((1,2,0)))\nax[1].imshow(np.clip(s2_at_aviris_loc.values/3_500,0,1).transpose((1,2,0)))\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code>&lt;matplotlib.image.AxesImage at 0x7f90a47f0790&gt;</code>\n</pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<pre><code>%%time\nimport rasterio.windows\nfrom math import ceil\n\nshape_out = ceil(aviris_reader_in_memory.shape[1] * aviris_reader_in_memory.res[0] / s2_reader.res[0]), ceil(aviris_reader_in_memory.shape[2] * aviris_reader_in_memory.res[1] / s2_reader.res[1])\n\ns2_at_aviris_loc = read.read_reproject(s2_reader, dst_crs=aviris_reader_in_memory.crs, \n                                       dst_transform=aviris_reader_in_memory.transform,\n                                       resolution_dst_crs=s2_reader.res,\n                                       window_out=rasterio.windows.Window(0,0, width=shape_out[-1], height=shape_out[-2]))\ns2_at_aviris_loc\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code>CPU times: user 766 ms, sys: 15.9 ms, total: 782 ms\nWall time: 111 ms\n</code>\n</pre>\n\n\n\n\n<pre>\n<code> \n         Transform: | 8.09, 5.88, 592577.80|\n| 5.88,-8.09, 3519916.50|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 112, 112)\n         Resolution: (9.999999999910532, 10.000000000141569)\n         Bounds: (592577.7996484624, 3519010.398378094, 594142.2181647301, 3520574.816894365)\n         CRS: EPSG:32613\n         fill_value_default: 0\n        </code>\n</pre>\n\n\n\n\n\n\n\n\n<pre><code>fig, ax = plt.subplots(1,2,figsize=(12,6))\nax[0].imshow(aviris_reader_in_memory.values.transpose((1,2,0)))\nax[1].imshow(np.clip(s2_at_aviris_loc.values/3_500,0,1).transpose((1,2,0)))\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code>&lt;matplotlib.image.AxesImage at 0x7f90b4e29c00&gt;</code>\n</pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<pre><code>avirs_at_10m = read.resize(aviris_reader_in_memory,resolution_dst=s2_reader.res,anti_aliasing=True)\navirs_at_10m\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code> \n         Transform: | 8.09, 5.88, 592577.80|\n| 5.88,-8.09, 3519916.50|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 112, 112)\n         Resolution: (9.999999999910532, 10.000000000141569)\n         Bounds: (592577.7996484624, 3519010.398378094, 594142.2181647301, 3520574.816894365)\n         CRS: EPSG:32613\n         fill_value_default: 0\n        </code>\n</pre>\n\n\n\n\n\n\n\n\n<pre><code>fig, ax = plt.subplots(1,3,figsize=(18,6))\nax[0].imshow(aviris_reader_in_memory.values.transpose((1,2,0)))\nax[1].imshow(avirs_at_10m.values.transpose((1,2,0)))\nax[2].imshow(np.clip(s2_at_aviris_loc.values/3_500,0,1).transpose((1,2,0)))\n</code></pre>\n\n\n\n\n\n\n<pre>\n<code>&lt;matplotlib.image.AxesImage at 0x7f9083f5c6d0&gt;</code>\n</pre>"},{"location":"reading_overlapping_sentinel2_aviris/#reading-overlapping-tiles-with-georeader","title":"Reading overlapping tiles with <code>georeader</code>","text":"<p>This tutorial shows how to read overlapping parts of two raster objects of different spatial resolution and with different transforms.</p> <p>For this tutorial we will use a GeoTIFF file derived from an AVIRIS-NG image that we downloaded from here and a Sentinel-2 file SAFE file that can be read directly from the public GCP bucket (or downloaded from Copernicus SciHub).</p>"},{"location":"reading_overlapping_sentinel2_aviris/#install-package-with-google-dependecies","title":"Install package with Google dependecies","text":"<p>This is needed to read image from S2 bucket</p> <pre><code>pip install georeader-spaceml fsspec gcsfs\n</code></pre>"},{"location":"reading_overlapping_sentinel2_aviris/#read-the-s2-image-at-the-aviris-location-using-read_from_bounds","title":"Read the S2 image at the AVIRIS location using <code>read_from_bounds</code>","text":""},{"location":"reading_overlapping_sentinel2_aviris/#convert-to-and-from-xarraydataarray","title":"Convert to and from <code>xarray.DataArray</code>","text":""},{"location":"reading_overlapping_sentinel2_aviris/#read-the-s2-image-at-the-aviris-location-using-read_from_center_coords","title":"Read the S2 image at the AVIRIS location using <code>read_from_center_coords</code>","text":""},{"location":"reading_overlapping_sentinel2_aviris/#read-the-s2-image-at-the-aviris-location-using-read_reproject_like","title":"Read the S2 image at the AVIRIS location using <code>read_reproject_like</code>","text":"<p>This will read the S2 image with the same resolution and transform as the AVIRIS image.</p>"},{"location":"reading_overlapping_sentinel2_aviris/#read-the-s2-image-at-the-aviris-location-using-read_reproject","title":"Read the S2 image at the AVIRIS location using <code>read_reproject</code>","text":"<p>With this we will show how to reproject the S2 image to the AVIRIS grid but keeping the original spatial resolution of Sentinel-2 (10m).</p>"},{"location":"reading_overlapping_sentinel2_aviris/#downscale-aviris-ng-to-the-sentinel-2-resolution-10m","title":"Downscale AVIRIS-NG to the Sentinel-2 resolution (10m)","text":"<p>This AVIRIS-NG image is at 7.40m resolution and we'd like to convert it to 10m resolution. We will set the option anti_aliasing to True to avoid aliasing efects of reducing the sampling size.</p>"},{"location":"reading_overlapping_sentinel2_aviris/#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p>\n<p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p>\n<p>If you find this work useful please cite:</p>\n<pre><code>@article{ruzicka_starcop_2023,\n    title = {Semantic segmentation of methane plumes with hyperspectral machine learning models},\n    volume = {13},\n    issn = {2045-2322},\n    url = {https://www.nature.com/articles/s41598-023-44918-6},\n    doi = {10.1038/s41598-023-44918-6},\n    number = {1},\n    journal = {Scientific Reports},\n    author = {R\u016f\u017ei\u010dka, V\u00edt and Mateo-Garcia, Gonzalo and G\u00f3mez-Chova, Luis and Vaughan, Anna, and Guanter, Luis and Markham, Andrew},\n    month = nov,\n    year = {2023},\n    pages = {19999},\n}\n</code></pre>"},{"location":"simultaneous_prisma_emit/","title":"PRISMA","text":"<pre><code>import os\nprisma_path = \"prisma_database/PRS_L1_STD_OFFL_20230929102749_20230929102753_0001.he5\"\nemit_path = \"emit_database/raw/EMIT_L1B_RAD_001_20230929T122534_2327208_039.nc\"\nos.path.exists(prisma_path),os.path.exists(emit_path)\n</code></pre> <pre>\n<code>(True, True)</code>\n</pre> <pre><code>from georeader.readers import emit\nfrom georeader.readers import prisma\nimport matplotlib.pyplot as plt\nfrom georeader import plot\nfrom georeader import read\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Point\nfrom georeader.window_utils import polygon_to_crs\n\nei = emit.EMITImage(emit_path).to_crs()\nei\n</code></pre> <pre>\n<code> \n         File: emit_database/raw/EMIT_L1B_RAD_001_20230929T122534_2327208_039.nc\n         Transform: | 60.00, 0.00, 184463.99|\n| 0.00,-60.00, 3571041.85|\n| 0.00, 0.00, 1.00|\n         Shape: (285, 1935, 2004)\n         Resolution: (60.0, 60.0)\n         Bounds: (184463.98930973688, 3454941.8506227555, 304703.9893097369, 3571041.8506227555)\n         CRS: EPSG:32632\n         units: uW/cm^2/SR/nm\n        </code>\n</pre> <pre><code>pi = prisma.PRISMA(prisma_path)\npi\n</code></pre> <pre>\n<code>\n        File: prisma_database/PRS_L1_STD_OFFL_20230929102749_20230929102753_0001.he5\n        Bounds: (5.843493461608887, 31.288787841796875, 6.223865509033203, 31.612695693969727)\n        Time: 2023-09-29 10:27:49.047000+00:00\n        VNIR Range: (406.9934, 977.3654) 63 bands\n        SWIR Range: (943.3579, 2497.1155) 171 bands\n        </code>\n</pre> <pre><code># Load SWIR and NIR PRISMA images\npi.load_raw(swir_flag=True)\n_ = pi.load_raw(swir_flag=False)\n</code></pre> <pre><code>pixel_prisma = (45, 65)\n\n# The raw values of prisma are col major\npoint_prisma = pi.lons[pixel_prisma[-1::-1]],pi.lats[pixel_prisma[-1::-1]]\n\nei_on_point = read.read_from_center_coords(ei, point_prisma, \n                                           shape=(50,50), \n                                           crs_center_coords=\"EPSG:4326\").load()\nei_on_point\n</code></pre> <pre>\n<code> \n         Transform: | 60.00, 0.00, 207203.99|\n| 0.00,-60.00, 3501321.85|\n| 0.00, 0.00, 1.00|\n         Shape: (285, 50, 50)\n         Resolution: (60.0, 60.0)\n         Bounds: (207203.98930973688, 3498321.8506227555, 210203.98930973688, 3501321.8506227555)\n         CRS: EPSG:32632\n         fill_value_default: 0\n        </code>\n</pre> <pre><code># Center pixel\npixel_value_emit = ei_on_point.values[:, 25, 25]\n\npixel_value_prisma = pi.ltoa_swir[pixel_prisma + (slice(None),)]\npixel_value_prisma_vnir = pi.ltoa_vnir[pixel_prisma + (slice(None),)]\n\nplt.plot(ei.wavelengths, pixel_value_emit, label=\"EMIT\")\nplt.plot(pi.wavelength_swir[pixel_prisma[1],:], pixel_value_prisma/10, label=\"PRISMA SWIR\")\nplt.plot(pi.wavelength_vnir[pixel_prisma[1],:], pixel_value_prisma_vnir/10, label=\"PRISMA VNIR\")\n\nplt.ylabel(ei.units)\nplt.xlabel(\"$\\lambda$ (nm)\")\nplt.grid()\nplt.legend()\n</code></pre> <pre>\n<code>&lt;matplotlib.legend.Legend at 0x7f4ff610a6e0&gt;</code>\n</pre> <pre><code>rgb_prisma = pi.load_rgb(raw=False)\nrgb_prisma\n</code></pre> <pre>\n<code> \n         Transform: | 30.00, 0.00, 199694.39|\n| 0.00,-30.00, 3501644.59|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 1219, 1227)\n         Resolution: (30.0, 30.0)\n         Bounds: (199694.3906206509, 3465074.5888539106, 236504.3906206509, 3501644.5888539106)\n         CRS: EPSG:32632\n         fill_value_default: -1\n        </code>\n</pre> <pre><code>plot.show(rgb_prisma)\n</code></pre> <pre>\n<code>Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n</code>\n</pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>rgb_emit = ei.load_rgb(as_reflectance=True)\nrgb_emit\n</code></pre> <pre>\n<code> \n         Transform: | 60.00, 0.00, 184463.99|\n| 0.00,-60.00, 3571041.85|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 1935, 2004)\n         Resolution: (60.0, 60.0)\n         Bounds: (184463.98930973688, 3454941.8506227555, 304703.9893097369, 3571041.8506227555)\n         CRS: EPSG:32632\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>fig, ax = plt.subplots(1,1)\nplot.show(rgb_emit, ax=ax)\nplot.add_shape_to_plot(ei.footprint(crs=\"EPSG:4326\"), crs_plot=ei.crs, crs_shape=\"EPSG:4326\", polygon_no_fill=True, ax=ax)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>import geopandas as gpd\nmetadata = gpd.GeoDataFrame({\"geometry\": [ei.footprint(crs=\"EPSG:4326\"), pi.footprint(crs=\"EPSG:4326\")],\n                             # \"geometry\": [rgb_emit.valid_footprint(crs=\"EPSG:4326\"), rgb_prisma.valid_footprint(crs=\"EPSG:4326\")],\n                             \"satellite\": [\"EMIT\", \"PRISMA\"],\n                             \"tile_date\": [ei.time_coverage_start.isoformat(), pi.time_coverage_start.isoformat()]},\n                            geometry=\"geometry\",\n                            crs=\"EPSG:4326\")\nmetadata\n</code></pre> geometry satellite tile_date 0 POLYGON ((6.29588 32.23147, 6.29591 32.23039, ... EMIT 2023-09-29T12:25:34+00:00 1 POLYGON ((5.84349 31.34925, 6.15325 31.28879, ... PRISMA 2023-09-29T10:27:49.047000+00:00 <pre><code>metadata.explore()\n</code></pre> Make this Notebook Trusted to load map: File -&gt; Trust Notebook <pre><code>pol_intersection = rgb_emit.valid_footprint(crs=\"EPSG:4326\").intersection(rgb_prisma.valid_footprint(crs=\"EPSG:4326\"))\n\nrgb_emit_intersect = read.read_from_polygon(rgb_emit, pol_intersection, \"EPSG:4326\")\nrgb_prisma_intersect = read.read_from_polygon(rgb_prisma, pol_intersection, \"EPSG:4326\")\n\n# Show point where we extracted the profile in the plot\npoint_prisma_epsg = Point(*point_prisma)\npoint_emit_crs = polygon_to_crs(point_prisma_epsg, crs_polygon=\"EPSG:4326\", dst_crs=rgb_emit_intersect.crs)\npoint_prisma_crs = polygon_to_crs(point_prisma_epsg, crs_polygon=\"EPSG:4326\", dst_crs=rgb_prisma_intersect.crs)\n\nfig, ax = plt.subplots(1,2,figsize=(16,10))\nplot.show(rgb_emit_intersect, ax=ax[0], title=\"EMIT\")\nax[0].scatter([point_emit_crs.coords[0][0]], [point_emit_crs.coords[0][1]], marker=\"x\", color=\"red\")\nplot.add_shape_to_plot(pol_intersection, crs_plot=rgb_emit_intersect.crs, crs_shape=\"EPSG:4326\", polygon_no_fill=True, ax=ax[0])\nplot.show(rgb_prisma_intersect, ax=ax[1], title=\"PRISMA\")\nax[1].scatter([point_prisma_crs.coords[0][0]], [point_prisma_crs.coords[0][1]], marker=\"x\", color=\"red\")\nplot.add_shape_to_plot(pol_intersection, crs_plot=rgb_prisma_intersect.crs, crs_shape=\"EPSG:4326\", polygon_no_fill=True, ax=ax[1])\n</code></pre> <pre>\n<code>Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n</code>\n</pre> <pre>\n<code>&lt;Axes: title={'center': 'PRISMA'}&gt;</code>\n</pre> <pre><code>rgb_emit_point = read.read_from_center_coords(rgb_emit, point_prisma, shape=(50,50),\n                                                  crs_center_coords=\"EPSG:4326\")\nrgb_prisma_point = read.read_from_center_coords(rgb_prisma, point_prisma, \n                                                shape=(100,100),\n                                                crs_center_coords=\"EPSG:4326\")\n\n# # Show point where we extracted the profile in the plot\n# point_prisma_epsg = Point(*point_prisma)\n# point_emit_crs = polygon_to_crs(point_prisma_epsg, crs_polygon=\"EPSG:4326\", dst_crs=rgb_emit_intersect.crs)\n# point_prisma_crs = polygon_to_crs(point_prisma_epsg, crs_polygon=\"EPSG:4326\", dst_crs=rgb_prisma_intersect.crs)\n\nfig, ax = plt.subplots(1,2,figsize=(16,10))\nplot.show(rgb_emit_point, ax=ax[0], title=\"EMIT\")\nax[0].scatter([point_emit_crs.coords[0][0]], [point_emit_crs.coords[0][1]], marker=\"x\", color=\"red\")\nplot.show(rgb_prisma_point, ax=ax[1], title=\"PRISMA\")\nax[1].scatter([point_prisma_crs.coords[0][0]], [point_prisma_crs.coords[0][1]], marker=\"x\", color=\"red\")\n</code></pre> <pre>\n<code>Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n</code>\n</pre> <pre>\n<code>&lt;matplotlib.collections.PathCollection at 0x7f4fef997d90&gt;</code>\n</pre>"},{"location":"simultaneous_prisma_emit/#prisma-and-emit-readers","title":"PRISMA and EMIT readers","text":""},{"location":"simultaneous_prisma_emit/#install-package-dependecies","title":"Install package  dependecies","text":"<p>EMIT requires the <code>netcdf4</code> package to read the products. We will also use the <code>pysolar</code> package to convert the EMIT L1B radiances to reflectances. PRISMA requires the <code>h5py</code> package and we need <code>scipy</code> for the <code>georeader.reflectance</code> module.</p> <pre><code>pip install georeader-spaceml netcdf4 pysolar h5py scipy\n</code></pre>"},{"location":"simultaneous_prisma_emit/#read-images","title":"Read images","text":""},{"location":"simultaneous_prisma_emit/#read-same-pixel-value","title":"Read same pixel value","text":""},{"location":"simultaneous_prisma_emit/#load-rgb-reflectance","title":"Load RGB reflectance","text":""},{"location":"simultaneous_prisma_emit/#plot-rgb-over-the-exact-same-area","title":"Plot RGB over the exact same area","text":""},{"location":"simultaneous_prisma_emit/#zoom-in-in-the-point","title":"Zoom in in the point","text":""},{"location":"simultaneous_prisma_emit/#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite:</p> <pre><code>@article{ruzicka_starcop_2023,\n    title = {Semantic segmentation of methane plumes with hyperspectral machine learning models},\n    volume = {13},\n    issn = {2045-2322},\n    url = {https://www.nature.com/articles/s41598-023-44918-6},\n    doi = {10.1038/s41598-023-44918-6},\n    number = {1},\n    journal = {Scientific Reports},\n    author = {R\u016f\u017ei\u010dka, V\u00edt and Mateo-Garcia, Gonzalo and G\u00f3mez-Chova, Luis and Vaughan, Anna, and Guanter, Luis and Markham, Andrew},\n    month = nov,\n    year = {2023},\n    pages = {19999},\n}\n</code></pre>"},{"location":"Sentinel-2/convert_to_radiance/","title":"ToA reflectance to radiance","text":"<pre><code>import ee\nimport matplotlib.pyplot as plt\nfrom georeader import plot\nfrom shapely.geometry import box\nfrom georeader.readers import ee_image\nfrom datetime import datetime, timezone\nfrom rasterio import Affine\nfrom georeader.readers import S2_SAFE_reader\nfrom georeader import reflectance\nimport os\n\nos.environ[\"GS_NO_SIGN_REQUEST\"] = \"YES\"\n\n# ee.Authenticate()\nee.Initialize()\n</code></pre> <pre><code>collection_name = \"COPERNICUS/S2_HARMONIZED\"\ntile = \"S2A_MSIL1C_20240417T064631_N0510_R020_T40RCN_20240417T091941\"\nimg_col = ee.ImageCollection(collection_name)\nimage = img_col.filter(ee.Filter.eq(\"PRODUCT_ID\", tile)).first()\ninfo_img = image.getInfo()\n</code></pre> <pre><code># projgee = image.select(\"B2\").projection().getInfo()\n\naoi = box(55.325, 25.225, 55.415, 25.28)\n\nbands_0bname = list(S2_SAFE_reader.BANDS_S2_L1C)\nbands = [b.replace(\"B0\",\"B\") for b in bands_0bname]\ncrs = info_img[\"bands\"][1][\"crs\"]\ntransform = Affine(*info_img[\"bands\"][1][\"crs_transform\"])\nimg_local = ee_image.export_image(info_img['id'],\n                                  crs=crs, transform=transform,\n                                  bands_gee=bands,\n                                  geometry=aoi)\nimg_local\n</code></pre> <pre>\n<code>Warning 1: TIFFReadDirectory:Sum of Photometric type-related color channels and ExtraSamples doesn't match SamplesPerPixel. Defining non-color channels as ExtraSamples.\n</code>\n</pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 331260.00|\n| 0.00,-10.00, 2797010.00|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 622, 916)\n         Resolution: (10.0, 10.0)\n         Bounds: (331260.0, 2790790.0, 340420.0, 2797010.0)\n         CRS: EPSG:32640\n         fill_value_default: 0.0\n        </code>\n</pre> <pre><code>s2_safe_folder = S2_SAFE_reader.s2_public_bucket_path(tile, check_exists=False)\n\nprint(f\"File is located at: {s2_safe_folder}\")\n\ns2obj = S2_SAFE_reader.s2loader(s2_safe_folder, out_res=10)\ns2obj\n</code></pre> <pre>\n<code>File is located at: gs://gcp-public-data-sentinel-2/tiles/40/R/CN/S2A_MSIL1C_20240417T064631_N0510_R020_T40RCN_20240417T091941.SAFE\n</code>\n</pre> <pre>\n<code> \n         gs://gcp-public-data-sentinel-2/tiles/40/R/CN/S2A_MSIL1C_20240417T064631_N0510_R020_T40RCN_20240417T091941.SAFE\n         Transform: | 10.00, 0.00, 300000.00|\n| 0.00,-10.00, 2800020.00|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 10980, 10980)\n         Resolution: (10.0, 10.0)\n         Bounds: (300000.0, 2690220.0, 409800.0, 2800020.0)\n         CRS: EPSG:32640\n         bands: ['B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B8A', 'B09', 'B10', 'B11', 'B12']\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>toa_refl = img_local / 10_000\n</code></pre> <pre><code>solar_irradiance_gee = {k:v/1_000. for k, v in info_img['properties'].items() if k.startswith(\"SOLAR_IRRADIANCE\")}\nfor b in bands:\n    print(f\"{b} -&amp;gt; {solar_irradiance_gee[f'SOLAR_IRRADIANCE_{b}']}\")\n</code></pre> <pre>\n<code>B1 -&gt; 1.88469\nB2 -&gt; 1.9596600000000002\nB3 -&gt; 1.82324\nB4 -&gt; 1.51206\nB5 -&gt; 1.4246400000000001\nB6 -&gt; 1.28761\nB7 -&gt; 1.16208\nB8 -&gt; 1.04163\nB8A -&gt; 0.9553200000000001\nB9 -&gt; 0.81292\nB10 -&gt; 0.36715\nB11 -&gt; 0.24559\nB12 -&gt; 0.08525\n</code>\n</pre> <pre><code>date_of_aquisition = datetime.fromtimestamp(info_img['properties'][\"system:time_start\"]/ 1000).replace(tzinfo=timezone.utc)\ndate_of_aquisition\n</code></pre> <pre>\n<code>datetime.datetime(2024, 4, 17, 9, 2, 44, 342000, tzinfo=datetime.timezone.utc)</code>\n</pre> <pre><code>mean_solar_zenith_angle = info_img['properties']['MEAN_SOLAR_ZENITH_ANGLE']\nU = info_img['properties'][\"REFLECTANCE_CONVERSION_CORRECTION\"]\nmean_solar_zenith_angle, U\n</code></pre> <pre>\n<code>(22.6291255460394, 0.994777427364766)</code>\n</pre> <pre><code>import numpy as np\n\nobservation_date_corr_factor = np.pi / (np.cos(mean_solar_zenith_angle/180*np.pi) * U)\nprint(observation_date_corr_factor)\n\nrad = reflectance.reflectance_to_radiance(toa_refl, \n                                          solar_irradiance = [solar_irradiance_gee[f\"SOLAR_IRRADIANCE_{b}\"] for b in bands],\n                                          observation_date_corr_factor=observation_date_corr_factor)\nrad\n</code></pre> <pre>\n<code>3.4214902841464196\n</code>\n</pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 331260.00|\n| 0.00,-10.00, 2797010.00|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 622, 916)\n         Resolution: (10.0, 10.0)\n         Bounds: (331260.0, 2790790.0, 340420.0, 2797010.0)\n         CRS: EPSG:32640\n         fill_value_default: 0.0\n        </code>\n</pre> <pre><code>s2obj.read_metadata_tl()\nsolar_irr_safe = s2obj.solar_irradiance()\nU_save = s2obj.scale_factor_U()\nprint(f\"SZA: {s2obj.mean_sza} U: {U_save}\")\nsolar_irr_safe\nfor b in bands_0bname:\n    print(f\"{b} -&amp;gt; {solar_irr_safe[b]}\")\n</code></pre> <pre>\n<code>SZA: 22.6291255460394 U: 0.994777427364766\nB01 -&gt; 1.88469\nB02 -&gt; 1.9596600000000002\nB03 -&gt; 1.82324\nB04 -&gt; 1.51206\nB05 -&gt; 1.4246400000000001\nB06 -&gt; 1.28761\nB07 -&gt; 1.16208\nB08 -&gt; 1.04163\nB8A -&gt; 0.9553200000000001\nB09 -&gt; 0.81292\nB10 -&gt; 0.36715\nB11 -&gt; 0.24559\nB12 -&gt; 0.08525\n</code>\n</pre> <pre><code>satellite = tile.split(\"_\")[0] # S2A, S2B or S2C\n\nsrf_satellite = S2_SAFE_reader.read_srf(satellite)\nirradiances = reflectance.integrated_irradiance(srf_satellite) / 1_000 # Convert from mW/m2/sr/nm to W/m2/sr/nm\nsolar_irradiance_calc = dict(zip(srf_satellite.columns, irradiances))\nsolar_irradiance_calc\n</code></pre> <pre>\n<code>/home/gonzalo/mambaforge/envs/marsmlpy312/lib/python3.12/site-packages/openpyxl/worksheet/_reader.py:329: UserWarning: Unknown extension is not supported and will be removed\n  warn(msg)\n</code>\n</pre> <pre>\n<code>{'B01': 1.884835040894774,\n 'B02': 1.9585911091822743,\n 'B03': 1.8241227793692252,\n 'B04': 1.5121602113335022,\n 'B05': 1.424787320092646,\n 'B06': 1.2873886799012966,\n 'B07': 1.1565783864975936,\n 'B08': 0.9709833673468558,\n 'B8A': 0.9532926414812208,\n 'B09': 0.7941054027444697,\n 'B10': 0.36748198011502775,\n 'B11': 0.24593390086371422,\n 'B12': 0.0856471195539582}</code>\n</pre> <pre><code>for b in bands_0bname:\n    bnozero = b.replace(\"B0\", \"B\")\n    print(f\"{b} -&amp;gt; GEE: {solar_irradiance_gee[f'SOLAR_IRRADIANCE_{bnozero}']} SAFE: {solar_irr_safe[b]:.4f} Calc: {solar_irradiance_calc[b]:.4f}\")\n</code></pre> <pre>\n<code>B01 -&gt; GEE: 1.88469 SAFE: 1.8847 Calc: 1.8848\nB02 -&gt; GEE: 1.9596600000000002 SAFE: 1.9597 Calc: 1.9586\nB03 -&gt; GEE: 1.82324 SAFE: 1.8232 Calc: 1.8241\nB04 -&gt; GEE: 1.51206 SAFE: 1.5121 Calc: 1.5122\nB05 -&gt; GEE: 1.4246400000000001 SAFE: 1.4246 Calc: 1.4248\nB06 -&gt; GEE: 1.28761 SAFE: 1.2876 Calc: 1.2874\nB07 -&gt; GEE: 1.16208 SAFE: 1.1621 Calc: 1.1566\nB08 -&gt; GEE: 1.04163 SAFE: 1.0416 Calc: 0.9710\nB8A -&gt; GEE: 0.9553200000000001 SAFE: 0.9553 Calc: 0.9533\nB09 -&gt; GEE: 0.81292 SAFE: 0.8129 Calc: 0.7941\nB10 -&gt; GEE: 0.36715 SAFE: 0.3671 Calc: 0.3675\nB11 -&gt; GEE: 0.24559 SAFE: 0.2456 Calc: 0.2459\nB12 -&gt; GEE: 0.08525 SAFE: 0.0853 Calc: 0.0856\n</code>\n</pre> <pre><code>observation_date_corr_factor_calc = reflectance.observation_date_correction_factor(img_local.footprint(\"EPSG:4326\").centroid.coords[0],\n                                                                                   date_of_acquisition=date_of_aquisition)\nobservation_date_corr_factor_calc\n</code></pre> <pre>\n<code>3.327182058670046</code>\n</pre> <pre><code>rad2 = reflectance.reflectance_to_radiance(toa_refl, \n                                          solar_irradiance = [solar_irradiance_calc[b] for b in bands_0bname],\n                                          observation_date_corr_factor=observation_date_corr_factor)\nrad2\n</code></pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 331260.00|\n| 0.00,-10.00, 2797010.00|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 622, 916)\n         Resolution: (10.0, 10.0)\n         Bounds: (331260.0, 2790790.0, 340420.0, 2797010.0)\n         CRS: EPSG:32640\n         fill_value_default: 0.0\n        </code>\n</pre> <pre><code>for i, b in enumerate(bands_0bname):\n    rad_b_or = rad.isel({\"band\":i})\n    rad_b_2 = rad2.isel({\"band\":i})\n    ratio = rad_b_or.values / rad_b_2.values\n    mean_ratio = np.mean(ratio)\n    std_ratio = np.std(ratio)\n    print(f\"{b} {mean_ratio:.4f} {std_ratio:.6f}\")\n</code></pre> <pre>\n<code>B01 0.9999 0.000000\nB02 1.0005 0.000000\nB03 0.9995 0.000000\nB04 0.9999 0.000000\nB05 0.9999 0.000000\nB06 1.0002 0.000000\nB07 1.0048 0.000000\nB08 1.0728 0.000000\nB8A 1.0021 0.000000\nB09 1.0237 0.000000\nB10 0.9991 0.000000\nB11 0.9986 0.000000\nB12 0.9954 0.000000\n</code>\n</pre>"},{"location":"Sentinel-2/convert_to_radiance/#sentinel-2-toa-reflectance-to-radiance","title":"Sentinel-2 ToA reflectance to radiance","text":"<p>Author: Gonzalo Mateo-Garc\u00eda</p> <p>In this notebook we show how to convert ToA reflectance from Sentinel-2 to radiance using the metadata fetched from the GEE or directly computing the conversion factors.</p>"},{"location":"Sentinel-2/convert_to_radiance/#fetch-a-s2-image-from-gee","title":"Fetch a S2 image from GEE","text":""},{"location":"Sentinel-2/convert_to_radiance/#fetch-same-image-from-google-bucket","title":"Fetch same image from Google bucket","text":""},{"location":"Sentinel-2/convert_to_radiance/#convert-dn-to-reflectances","title":"Convert DN to reflectances","text":""},{"location":"Sentinel-2/convert_to_radiance/#fetch-metadata-to-do-toa-reflectance-to-radiance-conversion","title":"Fetch metadata to do toa reflectance to radiance conversion","text":"<p>See: Google Earth Engine Sentinel-2 image properties</p>"},{"location":"Sentinel-2/convert_to_radiance/#metadata-from-the-safe-file","title":"Metadata from the <code>SAFE</code> file","text":""},{"location":"Sentinel-2/convert_to_radiance/#calculate-irradiance-and-correction-factor-using-georeader","title":"Calculate Irradiance and correction factor using georeader","text":""},{"location":"Sentinel-2/convert_to_radiance/#show-differences-in-solar-irradiance","title":"Show differences in solar irradiance","text":""},{"location":"Sentinel-2/convert_to_radiance/#show-relative-differences-between-the-calculated-and-official-factors","title":"Show relative differences between the calculated and official factors","text":""},{"location":"Sentinel-2/convert_to_radiance/#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite:</p> <pre><code>@article{portales-julia_global_2023,\n    title = {Global flood extent segmentation in optical satellite images},\n    volume = {13},\n    issn = {2045-2322},\n    doi = {10.1038/s41598-023-47595-7},\n    number = {1},\n    urldate = {2023-11-30},\n    journal = {Scientific Reports},\n    author = {Portal\u00e9s-Juli\u00e0, Enrique and Mateo-Garc\u00eda, Gonzalo and Purcell, Cormac and G\u00f3mez-Chova, Luis},\n    month = nov,\n    year = {2023},\n    pages = {20316},\n}\n</code></pre>"},{"location":"Sentinel-2/explore_metadata_s2/","title":"Metadata","text":"<pre><code>!pip install georeader-spaceml fsspec gcsfs\n</code></pre> <pre><code>import os\n# Donwload key from next line link to access the buckets and requester pays requests to public bucket (this is needed to query Sentinel-2 data)\nos.environ[\"GS_NO_SIGN_REQUEST\"] = \"YES\"\n</code></pre> <pre><code>%%time\nfrom georeader.readers import S2_SAFE_reader\n\nsafe_file = \"S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE\"\ns2_safe_folder = S2_SAFE_reader.s2_public_bucket_path(safe_file)\n\nprint(f\"File is located at: {s2_safe_folder}\")\n\ns2obj = S2_SAFE_reader.s2loader(s2_safe_folder, out_res=10)\ns2obj\n</code></pre> <pre>\n<code>/home/gonzalo/mambaforge/envs/marss2_vm/lib/python3.10/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</code>\n</pre> <pre>\n<code>File is located at: gs://gcp-public-data-sentinel-2/tiles/49/S/GV/S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE\nCPU times: user 1.82 s, sys: 1.56 s, total: 3.38 s\nWall time: 8.29 s\n</code>\n</pre> <pre>\n<code> \n         gs://gcp-public-data-sentinel-2/tiles/49/S/GV/S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE\n         Transform: | 10.00, 0.00, 699960.00|\n| 0.00,-10.00, 4000020.00|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 10980, 10980)\n         Resolution: (10.0, 10.0)\n         Bounds: (699960.0, 3890220.0, 809760.0, 4000020.0)\n         CRS: EPSG:32649\n         bands: ['B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B8A', 'B09', 'B10', 'B11', 'B12']\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>footprint = s2obj.footprint(crs=\"epsg:4326\")\nfootprint\n</code></pre> <pre><code>s2obj.metadata_msi\n</code></pre> <pre>\n<code>'gs://gcp-public-data-sentinel-2/tiles/49/S/GV/S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE/MTD_MSIL1C.xml'</code>\n</pre> <pre><code>s2obj.solar_irradiance()\n</code></pre> <pre>\n<code>{'B01': 1.8742999999999999,\n 'B02': 1.95975,\n 'B03': 1.8249300000000002,\n 'B04': 1.5127899999999999,\n 'B05': 1.42578,\n 'B06': 1.29113,\n 'B07': 1.17557,\n 'B08': 1.04128,\n 'B8A': 0.95393,\n 'B09': 0.8175800000000001,\n 'B10': 0.36541,\n 'B11': 0.24708000000000002,\n 'B12': 0.08775}</code>\n</pre> <pre><code>s2obj.scale_factor_U()\n</code></pre> <pre>\n<code>0.975631110815927</code>\n</pre> <pre><code>s2obj.quantification_value()\n</code></pre> <pre>\n<code>10000</code>\n</pre> <p>When reading the data we automatically apply the radio offsets</p> <pre><code>s2obj.radio_add_offsets()\n</code></pre> <pre>\n<code>{'B01': -1000,\n 'B02': -1000,\n 'B03': -1000,\n 'B04': -1000,\n 'B05': -1000,\n 'B06': -1000,\n 'B07': -1000,\n 'B08': -1000,\n 'B8A': -1000,\n 'B09': -1000,\n 'B10': -1000,\n 'B11': -1000,\n 'B12': -1000}</code>\n</pre> <pre><code>s2obj.metadata_tl\n</code></pre> <pre>\n<code>'gs://gcp-public-data-sentinel-2/tiles/49/S/GV/S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE/GRANULE/L1C_T49SGV_A027271_20220527T031740/MTD_TL.xml'</code>\n</pre> <pre><code># Trigger reading of metadata to inspect angles\ns2obj.read_metadata_tl()\n</code></pre> <pre><code>s2obj.mean_saa\n</code></pre> <pre>\n<code>131.536377934938</code>\n</pre> <pre><code>s2obj.mean_sza\n</code></pre> <pre>\n<code>19.9963398909342</code>\n</pre> <pre><code>s2obj.mean_vaa\n</code></pre> <pre>\n<code>{'B01': 126.71626827978,\n 'B02': 134.025373678555,\n 'B03': 131.374351951736,\n 'B04': 129.400002573406,\n 'B05': 128.353590682291,\n 'B06': 127.731729632175,\n 'B07': 127.498142587193,\n 'B08': 132.434175716618,\n 'B8A': 127.053148498046,\n 'B09': 126.379870378688,\n 'B10': 129.861408742839,\n 'B11': 127.893230596876,\n 'B12': 126.736610889672}</code>\n</pre> <pre><code>s2obj.mean_vza\n</code></pre> <pre>\n<code>{'B01': 3.68625117058342,\n 'B02': 3.0838728710074,\n 'B03': 3.18946067411809,\n 'B04': 3.29825904111417,\n 'B05': 3.36911102353786,\n 'B06': 3.44180307391012,\n 'B07': 3.52146467178658,\n 'B08': 3.13105485372435,\n 'B8A': 3.60143308327063,\n 'B09': 3.77484901438726,\n 'B10': 3.2696304921444,\n 'B11': 3.42988721523325,\n 'B12': 3.61676668649388}</code>\n</pre> <p>The <code>sza</code> and <code>vza</code> attributes are <code>GeoTensor</code> objects</p> <pre><code>s2obj.sza\n</code></pre> <pre>\n<code> \n         Transform: | 5000.00, 0.00, 699960.00|\n| 0.00,-5000.00, 4000020.00|\n| 0.00, 0.00, 1.00|\n         Shape: (23, 23)\n         Resolution: (5000.0, 5000.0)\n         Bounds: (699960.0, 3885020.0, 814960.0, 4000020.0)\n         CRS: EPSG:32649\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>from georeader.plot import show\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(2,2,figsize=(10,10), tight_layout=True)\nshow(s2obj.vza[\"B12\"], add_colorbar_next_to=True, add_scalebar=True,\n    ax=ax[0,0],title=\"VZA B12\")\nshow(s2obj.vaa[\"B12\"], add_colorbar_next_to=True, add_scalebar=True,\n    ax=ax[0,1],title=\"VAA B12\")\nshow(s2obj.sza, add_colorbar_next_to=True, add_scalebar=True,\n    ax=ax[1,0],title=\"SZA\")\nshow(s2obj.saa, add_colorbar_next_to=True, add_scalebar=True,\n    ax=ax[1,1],title=\"SAA\")\n</code></pre> <pre>\n<code>&lt;Axes: title={'center': 'SAA'}&gt;</code>\n</pre> <pre><code># reads SRF from S2_SAFE_reader.SRF_FILE_DEFAULT\nsrf = S2_SAFE_reader.read_srf(s2obj.mission)\nsrf\n</code></pre> <pre>\n<code>/home/gonzalo/mambaforge/envs/marss2_vm/lib/python3.10/site-packages/openpyxl/worksheet/_reader.py:329: UserWarning: Unknown extension is not supported and will be removed\n  warn(msg)\n</code>\n</pre> B01 B02 B03 B04 B05 B06 B07 B08 B8A B09 B10 B11 B12 SR_WL 411 0.006241 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 412 0.010240 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 413 0.004030 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 414 0.006422 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 415 0.005528 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000000 ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2299 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.020036 2300 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.013846 2301 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.008505 2302 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.004435 2303 0.000000 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.000853 <p>877 rows \u00d7 13 columns</p> <pre><code>fig, ax = plt.subplots(1,1,figsize=(14,4))\n\nfor idx, b in enumerate(S2_SAFE_reader.BANDS_S2):\n    mask_zero = srf[b] &amp;lt;=1e-4\n    ax.plot(srf.index[~mask_zero], \n            srf[b][~mask_zero], label=f\"{s2obj.mission}_{b}\")\n\n\nax.legend()\nax.set_xlabel(\"wavelength (nm)\")\n</code></pre> <pre>\n<code>Text(0.5, 0, 'wavelength (nm)')</code>\n</pre> <pre><code>%%time\nfrom georeader import read\n\ns2obj.bands = [\"B04\",\"B08\", \"B12\"]\n\ntensor = read.read_from_center_coords(s2obj, footprint.centroid.coords[0],shape=(512, 1024), crs_center_coords=\"epsg:4326\", trigger_load=True)\ntensor_toa = tensor / 10_000.\n</code></pre> <pre>\n<code>CPU times: user 1.35 s, sys: 199 ms, total: 1.55 s\nWall time: 27.9 s\n</code>\n</pre> <pre><code>tensor_toa = tensor / 10_000.\nshow(tensor_toa)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>tensor_radiance = s2obj.DN_to_radiance(tensor)\ntensor_radiance.values\n</code></pre> <pre>\n<code>array([[[0.04348571, 0.04286764, 0.0406161 , ..., 0.04503088,\n         0.04269105, 0.04330912],\n        [0.04463355, 0.04269105, 0.03973313, ..., 0.04335326,\n         0.0436623 , 0.04361815],\n        [0.04441281, 0.04277934, 0.04114586, ..., 0.04520747,\n         0.04432452, 0.04273519],\n        ...,\n        [0.05620031, 0.05633275, 0.05527321, ..., 0.07010691,\n         0.06953299, 0.0693564 ],\n        [0.05518491, 0.05514076, 0.05522906, ..., 0.07050425,\n         0.07028349, 0.06997447],\n        [0.05522906, 0.05465514, 0.05558224, ..., 0.07059254,\n         0.07041594, 0.07041594]],\n\n       [[0.08320179, 0.08605824, 0.09405023, ..., 0.09356403,\n         0.09705862, 0.09936808],\n        [0.08782074, 0.09228774, 0.09256123, ..., 0.09456682,\n         0.09484031, 0.09490108],\n        [0.08894508, 0.08900585, 0.08289791, ..., 0.09429333,\n         0.09113299, 0.08943128],\n        ...,\n        [0.07010465, 0.06761285, 0.06600229, ..., 0.0859063 ,\n         0.08529855, 0.08456924],\n        [0.06691393, 0.06569842, 0.06621501, ..., 0.08560242,\n         0.08435652, 0.08423498],\n        [0.06536415, 0.06545531, 0.06670122, ..., 0.08675715,\n         0.08554165, 0.08481235]],\n\n       [[0.00283995, 0.00273495, 0.00261716, ..., 0.00309603,\n         0.00300896, 0.00296031],\n        [0.0029347 , 0.00278617, 0.00264533, ..., 0.00299104,\n         0.00291165, 0.00286812],\n        [0.00306274, 0.002863  , 0.00269142, ..., 0.00290141,\n         0.00282202, 0.00276824],\n        ...,\n        [0.00334443, 0.0033265 , 0.00332138, ..., 0.00334699,\n         0.00336235, 0.0033854 ],\n        [0.00332394, 0.00330346, 0.00329577, ..., 0.00335979,\n         0.00337516, 0.00339821],\n        [0.00330858, 0.00329065, 0.00329321, ..., 0.00336492,\n         0.00337516, 0.00339565]]], dtype=float32)</code>\n</pre> <pre><code># Make sense since radiance in B12 is much lower than in B04\ntensor_radiance.values[:, 100, 100]\n</code></pre> <pre>\n<code>array([0.04211712, 0.09052525, 0.00289629], dtype=float32)</code>\n</pre>"},{"location":"Sentinel-2/explore_metadata_s2/#metadata-files-in-s2-images","title":"Metadata files in S2 images","text":"<p>There are two metadata files in Sentinel-2 images, these are saved in the attributes:  * <code>s2obj.metadata_msi</code>. In this file we have the solar irradiance, scale factor U, quantification values and radio add offsets.  * <code>s2obj.metadata_tl</code>. Here we have the solar and viewing angles. This file is specific of L1C images</p>"},{"location":"Sentinel-2/explore_metadata_s2/#load-spectral-response-function","title":"Load Spectral Response function","text":""},{"location":"Sentinel-2/explore_metadata_s2/#reflectance-to-radiance-conversion","title":"Reflectance to radiance conversion","text":"<p>We want the pixels of our images in spectral radiances with units \\(W\u00b7sr^{-1}\u00b7m^{\u22122}\u00b7nm^{\u22121}\\). Spectral raciances are (watts per steradian per square meter per nanometer).</p> <p>According to this https://gis.stackexchange.com/questions/285996/convert-sentinel-2-1c-product-from-reflectance-to-radiance the formula to convert digital numbers (DN) in ToA images is:</p> <p>toaBandX = (pixelValueBandX + radioAddOffsetBandX ) / 10000</p> <p>radianceBandX = ((toaBandX * cos(incidenceAngle) * solarIrradianceBandX) / (pi * d2))</p> <p>where d2 is the earth-sun distance correction. d2 is 1.0/U</p> <p>The values for incidenceAngle, solarIrradianceBandX and U can be found in the 2 metadata files included in the download.</p> <ul> <li>In <code>metadata_msi</code> we can find the <code>solarIrradianceBandX</code>, the <code>radioAddOffsetBandX</code> and <code>U</code>. See xml content bellow!</li> <li>In <code>metadata_tl</code> we can find the <code>incidenceAngle</code> (which I assume is the solar zenith angle). </li> </ul> <p>If \\(J\\) is the Julian day of the day of acquisition (day of the year), d2 can be computed as:</p> <p>d2 = (1-e* cos(0.9856 * (J-4) * pi/180))^2</p> <p>Where e=0.01673 is the Earth's orbit eccentricity</p> <p>We're going to read an small crop of the image and convert it to radiances</p>"},{"location":"Sentinel-2/explore_metadata_s2/#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite:</p> <pre><code>@article{portales-julia_global_2023,\n    title = {Global flood extent segmentation in optical satellite images},\n    volume = {13},\n    issn = {2045-2322},\n    doi = {10.1038/s41598-023-47595-7},\n    number = {1},\n    urldate = {2023-11-30},\n    journal = {Scientific Reports},\n    author = {Portal\u00e9s-Juli\u00e0, Enrique and Mateo-Garc\u00eda, Gonzalo and Purcell, Cormac and G\u00f3mez-Chova, Luis},\n    month = nov,\n    year = {2023},\n    pages = {20316},\n}\n</code></pre>"},{"location":"Sentinel-2/query_mosaic_s2_images/","title":"Mosaic","text":"<pre><code>import os\nimport datetime\nfrom shapely.geometry import box\nimport geopandas as gpd\nfrom georeader.readers import S2_SAFE_reader\n\n# Donwload key from next line link to access the buckets and requester pays requests to public bucket (this is needed to query Sentinel-2 data)\n# This is required to do advaced operations in the GCP bucket\n# os.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"path/to/file.json\"\n# os.environ[\"GS_USER_PROJECT\"] = \"project-name\"\n# S2_SAFE_reader.DEFAULT_REQUESTER_PAYS=True\n\nos.environ[\"GS_NO_SIGN_REQUEST\"] = \"YES\"\n</code></pre> <p>Create a geojson file using geojson.io</p> <pre><code>import geopandas as gpd\n\n# aoi = gpd.read_file(\"/home/gonzalo/Downloads/sagunt_small.geojson\")\naoi = gpd.read_file(\"/home/gonzalo/Downloads/liria.geojson\")\n# aoi.explore()\n</code></pre> <pre><code>from zoneinfo import ZoneInfo\n\ntz = ZoneInfo(\"Europe/Madrid\")\n\npolygon_read = aoi.unary_union\ncrs_polygon = aoi.crs\n\ndatetime_str = \"2019-09-28\"\ndate_of_interest = datetime.datetime.strptime(datetime_str, \"%Y-%m-%d\").replace(tzinfo=tz)\n\ndate_start_search = date_of_interest - datetime.timedelta(days=10)\ndate_end_search = date_of_interest + datetime.timedelta(days=6)\n\nprint(f\"Querying images between {date_start_search} and {date_end_search}\\nArea: {polygon_read}\")\n</code></pre> <pre>\n<code>Querying images between 2019-09-18 00:00:00+02:00 and 2019-10-04 00:00:00+02:00\nArea: POLYGON ((-0.74432373046875 39.52099229357195, -0.383148193359375 39.52099229357195, -0.383148193359375 39.81486542536203, -0.74432373046875 39.81486542536203, -0.74432373046875 39.52099229357195))\n</code>\n</pre> <pre><code>from georeader.readers import scihubcopernicus_query\n\n# from sentinelsat.sentinel import SentinelAPI\n# # 'https://scihub.copernicus.eu/apihub'\n# api = SentinelAPI('gonzmg88', \"yyyyyyy\", api_url='https://scihub.copernicus.eu/dhus/')\n\nproducts_gpd = scihubcopernicus_query.query(polygon_read, date_start_search, date_end_search)\nproducts_gpd[[\"overlappercentage\",\"cloudcoverpercentage\", \"utcdatetime\",\"localdatetime\",\"solardatetime\",\"solarday\"]]\n</code></pre> overlappercentage cloudcoverpercentage utcdatetime localdatetime solardatetime solarday title S2B_MSIL1C_20190918T105029_N0208_R051_T30SYJ_20190918T143346 54.697721 0.7080 2019-09-18 10:50:29.024000+00:00 2019-09-18 12:50:29.024000+02:00 2019-09-18 10:48:13.727369 2019-09-18 S2B_MSIL1C_20190918T105029_N0208_R051_T30TYK_20190918T132356 48.189182 5.3711 2019-09-18 10:50:29.024000+00:00 2019-09-18 12:50:29.024000+02:00 2019-09-18 10:48:13.727369 2019-09-18 S2B_MSIL1C_20190918T105029_N0208_R051_T30SXJ_20190918T143346 36.440780 0.2546 2019-09-18 10:50:29.024000+00:00 2019-09-18 12:50:29.024000+02:00 2019-09-18 10:48:13.727369 2019-09-18 S2B_MSIL1C_20190918T105029_N0208_R051_T30TXK_20190918T132356 32.170540 25.4126 2019-09-18 10:50:29.024000+00:00 2019-09-18 12:50:29.024000+02:00 2019-09-18 10:48:13.727369 2019-09-18 S2B_MSIL1C_20190928T105029_N0208_R051_T30SYJ_20190928T130836 54.697682 10.2055 2019-09-28 10:50:29.024000+00:00 2019-09-28 12:50:29.024000+02:00 2019-09-28 10:48:13.727369 2019-09-28 S2B_MSIL1C_20190928T105029_N0208_R051_T30TYK_20190928T130836 48.189182 12.7102 2019-09-28 10:50:29.024000+00:00 2019-09-28 12:50:29.024000+02:00 2019-09-28 10:48:13.727369 2019-09-28 S2B_MSIL1C_20190928T105029_N0208_R051_T30SXJ_20190928T130836 36.440780 12.5037 2019-09-28 10:50:29.024000+00:00 2019-09-28 12:50:29.024000+02:00 2019-09-28 10:48:13.727369 2019-09-28 S2B_MSIL1C_20190928T105029_N0208_R051_T30TXK_20190928T130836 32.170522 3.4074 2019-09-28 10:50:29.024000+00:00 2019-09-28 12:50:29.024000+02:00 2019-09-28 10:48:13.727369 2019-09-28 S2A_MSIL1C_20191003T105031_N0208_R051_T30SYJ_20191003T111605 54.697682 46.1493 2019-10-03 10:50:31.024000+00:00 2019-10-03 12:50:31.024000+02:00 2019-10-03 10:48:15.727369 2019-10-03 S2A_MSIL1C_20191003T105031_N0208_R051_T30TYK_20191003T111605 48.189182 43.6094 2019-10-03 10:50:31.024000+00:00 2019-10-03 12:50:31.024000+02:00 2019-10-03 10:48:15.727369 2019-10-03 S2A_MSIL1C_20191003T105031_N0208_R051_T30SXJ_20191003T111605 36.440780 35.3732 2019-10-03 10:50:31.024000+00:00 2019-10-03 12:50:31.024000+02:00 2019-10-03 10:48:15.727369 2019-10-03 <pre><code>import folium\n\nproducts_gpd[\"localdatetime_str\"] = products_gpd[\"localdatetime\"].dt.strftime(\"%Y-%m-%d %H:%M:%S\")\nm = products_gpd[[\"geometry\",\"overlappercentage\",\"cloudcoverpercentage\", \"localdatetime_str\",\"solarday\"]].explore(\"solarday\",name=\"S2\")\naoi.explore(m=m,name=\"AoI\",color=\"red\")\nfolium.LayerControl(collapsed=False).add_to(m)\nm\n</code></pre> Make this Notebook Trusted to load map: File -&gt; Trust Notebook <pre><code>%%time\nimport numpy as np\nfrom georeader import read\nfrom georeader import mosaic\nfrom georeader import window_utils\nimport rasterio.plot as rstplt\nimport matplotlib.pyplot as plt\n\nfor day, products_gpd_day in products_gpd.groupby(\"solarday\"):    \n    products_read = products_gpd_day.index\n    print(f\"Selected {products_read.shape[0]} products for solar day {day}\")\n    s2objs = []\n    for product in products_read:\n        s2_safe_folder = S2_SAFE_reader.s2_public_bucket_path(product+\".SAFE\", check_exists=False)\n        s2objs.append(S2_SAFE_reader.s2loader(s2_safe_folder, out_res=10, bands=[\"B04\", \"B03\", \"B02\"]))\n\n    polygon_read_dst_crs = window_utils.polygon_to_crs(polygon_read, crs_polygon=crs_polygon, dst_crs=s2objs[0].crs)\n    data_memory = mosaic.spatial_mosaic(s2objs, polygon=polygon_read_dst_crs, dst_crs= s2objs[0].crs)\n    print(repr(data_memory))\n\n    fig, ax = plt.subplots(1,1,figsize=(8,8))\n    rstplt.show(np.clip((data_memory.values)/3_000,0,1), transform=data_memory.transform, ax=ax)\n    ax.set_title(day)\n    plt.show(fig)\n    plt.close(fig)\n</code></pre> <pre>\n<code>Selected 4 products for solar day 2019-09-18\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\n\n         Transform: | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 3347, 3187)\n         Resolution: (10.0, 10.0)\n         Bounds: (693070.0, 4377020.0, 724940.0, 4410490.0)\n         CRS: EPSG:32630\n         fill_value_default: 0\n         &lt;class 'georeader.geotensor.GeoTensor'&gt;\n</code>\n</pre> <pre>\n<code>Selected 4 products for solar day 2019-09-28\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\n\n         Transform: | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 3347, 3187)\n         Resolution: (10.0, 10.0)\n         Bounds: (693070.0, 4377020.0, 724940.0, 4410490.0)\n         CRS: EPSG:32630\n         fill_value_default: 0\n         &lt;class 'georeader.geotensor.GeoTensor'&gt;\n</code>\n</pre> <pre>\n<code>Selected 3 products for solar day 2019-10-03\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\nWindow(col_off=0, row_off=0, width=3187, height=3347) | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\n\n         Transform: | 10.00, 0.00, 693070.00|\n| 0.00,-10.00, 4410490.00|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 3347, 3187)\n         Resolution: (10.0, 10.0)\n         Bounds: (693070.0, 4377020.0, 724940.0, 4410490.0)\n         CRS: EPSG:32630\n         fill_value_default: 0\n         &lt;class 'georeader.geotensor.GeoTensor'&gt;\n</code>\n</pre> <pre>\n<code>CPU times: user 2min 39s, sys: 27.3 s, total: 3min 7s\nWall time: 7min 35s\n</code>\n</pre> <p>In the last day there's a missing image (for that reason we have a black square in the top left corner). We inspect the available products in the cell bellow.</p> <pre><code>import geopandas as gpd\n\npol_mosaic = data_memory.footprint(crs=crs_polygon)\n\nprint(f\"Overlap {pol_mosaic.intersection(polygon_read).area / polygon_read.area*100:.2f}%\")\n\nfootprint_downloaded = gpd.GeoDataFrame({\"geometry\": [pol_mosaic], \n                                         \"title\": [\"footprint mosaic\"], \n                                         \"group\": [\"footprint mosaic\"]},\n                                        crs=crs_polygon)\n\nm = footprint_downloaded.explore(name=\"footprint\",color=\"green\")\nm = aoi.explore(m=m,name=\"AoI\",color=\"red\")\n</code></pre> <pre>\n<code>Overlap 100.00%\n</code>\n</pre>"},{"location":"Sentinel-2/query_mosaic_s2_images/#query-sentinel-2-images","title":"Query Sentinel-2 images","text":"<p>In this notebook we will show how to query Sentinel-2 images over an area between two given dates. We will use the <code>sentinelsat</code> package to obtain the Sentinel-2 product names and we will read those from the public GCP bucket (<code>gs://gcp-public-data-sentinel-2/tiles</code>).</p> <p>Set the env variables to be able to read from the Google bucket. This  will incur in reading costs.</p>"},{"location":"Sentinel-2/query_mosaic_s2_images/#install-package-with-google-dependecies","title":"Install package with Google dependecies","text":"<p>This is needed to read image from S2 bucket and to query to Copernicus SciHub <pre><code>pip install georeader-spaceml fsspec gcsfs sentinelsat\n</code></pre></p>"},{"location":"Sentinel-2/query_mosaic_s2_images/#step-1-select-dates-and-area-of-interest-to-read","title":"Step 1: Select dates and area of interest to read","text":""},{"location":"Sentinel-2/query_mosaic_s2_images/#step-2-query-the-products","title":"Step 2: Query the products","text":""},{"location":"Sentinel-2/query_mosaic_s2_images/#show-products-queried","title":"Show products queried","text":""},{"location":"Sentinel-2/query_mosaic_s2_images/#step-3-read-plot-the-data","title":"Step 3: Read  &amp; plot the data","text":"<p>Here we will loop over the solar days querying and mosaicking the images over the AoI.</p>"},{"location":"Sentinel-2/query_mosaic_s2_images/#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite:</p> <pre><code>@article{portales-julia_global_2023,\n    title = {Global flood extent segmentation in optical satellite images},\n    volume = {13},\n    issn = {2045-2322},\n    doi = {10.1038/s41598-023-47595-7},\n    number = {1},\n    urldate = {2023-11-30},\n    journal = {Scientific Reports},\n    author = {Portal\u00e9s-Juli\u00e0, Enrique and Mateo-Garc\u00eda, Gonzalo and Purcell, Cormac and G\u00f3mez-Chova, Luis},\n    month = nov,\n    year = {2023},\n    pages = {20316},\n}\n</code></pre>"},{"location":"Sentinel-2/run_in_gee_image/","title":"From Google Earth Engine","text":"<pre><code>pip install georeader-spaceml earthengine-api cloudsen12_models\n</code></pre> <pre><code>from cloudsen12_models import cloudsen12\nimport ee\nimport matplotlib.pyplot as plt\nfrom georeader import plot\nfrom shapely.geometry import box\nfrom georeader.readers import ee_image\n</code></pre> <pre><code>ee.Authenticate()\nee.Initialize()\n</code></pre> <pre><code>collection_name = \"COPERNICUS/S2_HARMONIZED\"\ntile = \"S2A_MSIL1C_20240417T064631_N0510_R020_T40RCN_20240417T091941\"\nimg_col = ee.ImageCollection(collection_name)\nimage = img_col.filter(ee.Filter.eq(\"PRODUCT_ID\", tile)).first()\ninfo_img = image.getInfo()\n# info_img\n</code></pre> <pre><code>%%time\n\nfrom rasterio import Affine\n# projgee = image.select(\"B2\").projection().getInfo()\n\naoi = box(55.325, 25.225, 55.415, 25.28)\n\nbands = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B8A', 'B9', 'B10', 'B11', 'B12']\ncrs = info_img[\"bands\"][1][\"crs\"]\ntransform = Affine(*info_img[\"bands\"][1][\"crs_transform\"])\nimg_local = ee_image.export_image(info_img['id'],\n                                  crs=crs, transform=transform,\n                                  bands_gee=bands,\n                                  geometry=aoi)\nimg_local\n</code></pre> <pre>\n<code>Warning 1: TIFFReadDirectory:Sum of Photometric type-related color channels and ExtraSamples doesn't match SamplesPerPixel. Defining non-color channels as ExtraSamples.\n</code>\n</pre> <pre>\n<code>CPU times: user 421 ms, sys: 86.6 ms, total: 508 ms\nWall time: 4.18 s\n</code>\n</pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 331260.00|\n| 0.00,-10.00, 2797010.00|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 622, 916)\n         Resolution: (10.0, 10.0)\n         Bounds: (331260.0, 2790790.0, 340420.0, 2797010.0)\n         CRS: EPSG:32640\n         fill_value_default: 0.0\n        </code>\n</pre> <pre><code>swirnirred = (img_local.isel({\"band\": [bands.index(b) for b in [\"B11\",\"B8\",\"B4\"]]}) / 4_500.).clip(0,1)\n\nplot.show(swirnirred)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>model = cloudsen12.load_model_by_name(name=\"UNetMobV2_V1\", weights_folder=\"cloudsen12_models\")\n</code></pre> <pre>\n<code>/home/gonzalo/git/cloudsen12_models/cloudsen12_models/cloudsen12.py:189: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.\n  weights = torch.load(weights_file, map_location=device)\n</code>\n</pre> <pre><code>cloudsen12.MODELS_CLOUDSEN12.keys()\n</code></pre> <pre>\n<code>dict_keys(['cloudsen12', 'UNetMobV2_V1', 'UNetMobV2_V2', 'cloudsen12l2a', 'dtacs4bands', 'landsat30'])</code>\n</pre> <pre><code>cloudmask = model.predict(img_local/10_000)\n</code></pre> <pre><code>fig, ax = plt.subplots(1,2,figsize=(14,5),sharey=True, tight_layout=True)\n\nplot.show(swirnirred,ax=ax[0])\ncloudsen12.plot_cloudSEN12mask(cloudmask,ax=ax[1])\nfig.savefig(\"example_flood_dubai_2024.png\")\n</code></pre> <pre><code>modelv2 = cloudsen12.load_model_by_name(name=\"UNetMobV2_V2\", weights_folder=\"cloudsen12_models\")\ncloudmaskv2 = modelv2.predict(img_local/10_000)\nfig, ax = plt.subplots(1,2,figsize=(14,5),sharey=True, tight_layout=True)\n\nplot.show(swirnirred,ax=ax[0])\ncloudsen12.plot_cloudSEN12mask(cloudmaskv2,ax=ax[1])\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>from shapely.geometry import mapping\ncollection_name = \"COPERNICUS/S2_SR_HARMONIZED\"\ntile = \"S2A_MSIL2A_20240417T064631_N0510_R020_T40RCN_20240417T091941\"\naoi_ee = ee.Geometry(mapping(aoi))\nimg_col = ee.ImageCollection(collection_name).filterDate('2024-04-17', '2024-04-18').filterBounds(aoi_ee)\nimage = img_col.first()\ninfo_imgl2a = image.getInfo()\n# info_imgl2a\n</code></pre> <pre><code>bandsl2a = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B8A', 'B9', 'B11', 'B12']\ncrs = info_imgl2a[\"bands\"][1][\"crs\"]\ntransform = Affine(*info_imgl2a[\"bands\"][1][\"crs_transform\"])\nimg_local_l2a = ee_image.export_image(info_imgl2a['id'],\n                                  crs=crs, transform=transform,\n                                  bands_gee=bandsl2a,\n                                  geometry=aoi)\nimg_local_l2a\n</code></pre> <pre>\n<code>Warning 1: TIFFReadDirectory:Sum of Photometric type-related color channels and ExtraSamples doesn't match SamplesPerPixel. Defining non-color channels as ExtraSamples.\n</code>\n</pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 331260.00|\n| 0.00,-10.00, 2797010.00|\n| 0.00, 0.00, 1.00|\n         Shape: (12, 622, 916)\n         Resolution: (10.0, 10.0)\n         Bounds: (331260.0, 2790790.0, 340420.0, 2797010.0)\n         CRS: EPSG:32640\n         fill_value_default: 0.0\n        </code>\n</pre> <pre><code>swirnirred_l2a = (img_local_l2a.isel({\"band\": [bandsl2a.index(b) for b in [\"B11\",\"B8\",\"B4\"]]}) / 4_500.).clip(0,1)\n\nplot.show(swirnirred_l2a)\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code>modell2a = cloudsen12.load_model_by_name(name=\"cloudsen12l2a\", weights_folder=\"cloudsen12_models\")\ncloudmask_l2a = modell2a.predict(img_local_l2a/10_000)\nfig, ax = plt.subplots(1,2,figsize=(14,5),sharey=True, tight_layout=True)\n\nplot.show(swirnirred_l2a,ax=ax[0])\ncloudsen12.plot_cloudSEN12mask(cloudmask_l2a,ax=ax[1])\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre>"},{"location":"Sentinel-2/run_in_gee_image/#run-inference-on-a-sentinel-2-image-from-the-google-earth-engine","title":"Run inference on a Sentinel-2 image from the Google Earth Engine","text":"<ul> <li>Last Modified: 30-08-2024</li> <li>Author: Gonzalo Mateo-Garc\u00eda</li> </ul>"},{"location":"Sentinel-2/run_in_gee_image/#cloudsen12","title":"CloudSEN12","text":"<p>This notebook shows how to run the CloudSEN12 model over an image downloaded from the Google Earth Engine. Hence to run this notebook you a Google Earth Engine account. </p> <p>We will run the models UnetMobV2_V1 and UnetMobV2_V2 with all bands proposed in:</p> <p>Aybar, C., Ysuhuaylas, L., Loja, J., Gonzales, K., Herrera, F., Bautista, L., Yali, R., Flores, A., Diaz, L., Cuenca, N., Espinoza, W., Prudencio, F., Llactayo, V., Montero, D., Sudmanns, M., Tiede, D., Mateo-Garc\u00eda, G., &amp; G\u00f3mez-Chova, L. (2022). CloudSEN12, a global dataset for semantic understanding of cloud and cloud shadow in Sentinel-2. Scientific Data, 9(1), Article 1. DOI: 10.1038/s41597-022-01878-2</p> <p>Aybar, C., Bautista, L., Montero, D., Contreras, J., Ayala, D., Prudencio, F., Loja, J., Ysuhuaylas, L., Herrera, F., Gonzales, K., Valladares, J., Flores, L. A., Mamani, E., Qui\u00f1onez, M., Fajardo, R., Espinoza, W., Limas, A., Yali, R., Alc\u00e1ntara, A., Leyva, M., Loayza-Muro, M., Willems, M., Mateo-Garc\u00eda, G. &amp; G\u00f3mez-Chova, L. (2024). CloudSEN12+: The largest dataset of expert-labeled pixels for cloud and cloud shadow detection in Sentinel-2. Data in Brief, 110852. DOI: 10.1016/j.dib.2024.110852</p>"},{"location":"Sentinel-2/run_in_gee_image/#unetmobv2_v1","title":"UNetMobV2_V1","text":"<p>Model trained on the first version of CloudSEN12 Aybar et al. 2022.</p>"},{"location":"Sentinel-2/run_in_gee_image/#unetmobv2_v2","title":"UnetMobV2_V2","text":"<p>Model trained on the second version of CloudSEN12 (called CloudSEN12+) Aybar et al. 2024.</p>"},{"location":"Sentinel-2/run_in_gee_image/#sentinel-2-l2a","title":"Sentinel-2 L2A","text":"<p>Run the model for L2A images.</p>"},{"location":"Sentinel-2/run_in_gee_image/#licence","title":"Licence","text":"<p>The <code>cloudsen12_models</code> package is published under a GNU Lesser GPL v3 licence</p> <p>The CloudSEN12 database and all pre-trained models are released under a Creative Commons non-commercial licence. For using the models in comercial pipelines written consent by the authors must be provided.</p> <p>This notebook is released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite: <pre><code>@article{aybar_cloudsen12_2024,\n    title = {{CloudSEN12}+: {The} largest dataset of expert-labeled pixels for cloud and cloud shadow detection in {Sentinel}-2},\n    issn = {2352-3409},\n    url = {https://www.sciencedirect.com/science/article/pii/S2352340924008163},\n    doi = {10.1016/j.dib.2024.110852},\n    journal = {Data in Brief},\n    author = {Aybar, Cesar and Bautista, Lesly and Montero, David and Contreras, Julio and Ayala, Daryl and Prudencio, Fernando and Loja, Jhomira and Ysuhuaylas, Luis and Herrera, Fernando and Gonzales, Karen and Valladares, Jeanett and Flores, Lucy A. and Mamani, Evelin and Qui\u00f1onez, Maria and Fajardo, Rai and Espinoza, Wendy and Limas, Antonio and Yali, Roy and Alc\u00e1ntara, Alejandro and Leyva, Martin and Loayza-Muro, Rau\u00b4l and Willems, Bram and Mateo-Garc\u00eda, Gonzalo and G\u00f3mez-Chova, Luis},\n    month = aug,\n    year = {2024},\n    pages = {110852},\n}\n\n@article{aybar_cloudsen12_2022,\n    title = {{CloudSEN12}, a global dataset for semantic understanding of cloud and cloud shadow in {Sentinel}-2},\n    volume = {9},\n    issn = {2052-4463},\n    url = {https://www.nature.com/articles/s41597-022-01878-2},\n    doi = {10.1038/s41597-022-01878-2},\n    number = {1},\n    urldate = {2023-01-02},\n    journal = {Scientific Data},\n    author = {Aybar, Cesar and Ysuhuaylas, Luis and Loja, Jhomira and Gonzales, Karen and Herrera, Fernando and Bautista, Lesly and Yali, Roy and Flores, Angie and Diaz, Lissette and Cuenca, Nicole and Espinoza, Wendy and Prudencio, Fernando and Llactayo, Valeria and Montero, David and Sudmanns, Martin and Tiede, Dirk and Mateo-Garc\u00eda, Gonzalo and G\u00f3mez-Chova, Luis},\n    month = dec,\n    year = {2022},\n    pages = {782},\n}\n</code></pre></p>"},{"location":"Sentinel-2/s2_mosaic_from_gee/","title":"Mosaic from GEE","text":"<pre><code>from shapely.geometry import shape, mapping\nfrom datetime import datetime, timedelta\nimport ee\n\nee.Authenticate()\nee.Initialize()\n\nfootprint = shape({'type': 'Polygon',\n 'coordinates': (((58.21132510761841, 40.391771861041725),\n   (58.205632677871314, 40.07155762141618),\n   (58.649475248490724, 40.06608738064447),\n   (58.65726127535553, 40.38623968067468),\n   (58.21132510761841, 40.391771861041725)),)})\n\ndate_search = datetime.fromisoformat(\"2024-10-09T06:54:26+00:00\")\ndate_search\n</code></pre> <pre>\n<code>*** Earth Engine *** Share your feedback by taking our Annual Developer Satisfaction Survey: https://google.qualtrics.com/jfe/form/SV_0JLhFqfSY1uiEaW?source=Init\n</code>\n</pre> <pre>\n<code>datetime.datetime(2024, 10, 9, 6, 54, 26, tzinfo=datetime.timezone.utc)</code>\n</pre> <p>Earth Engine code adapted from This blog post.</p> <pre><code>s2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')\ncsPlus = ee.ImageCollection('GOOGLE/CLOUD_SCORE_PLUS/V1/S2_HARMONIZED')\n\n\nROI = ee.Geometry(mapping(footprint))\n# ROI = ee.Geometry.Point(-119.9087, 37.4159)\n\nQA_BAND = 'cs'\nCLEAR_THRESHOLD = 0.60\n\ndate_search_min = date_search - timedelta(days=30)\ndate_search_max = date_search + timedelta(days=30)\ncomposite = s2.filterBounds(ROI)\\\n    .filterDate(date_search_min.strftime('%Y-%m-%d'), date_search_max.strftime('%Y-%m-%d'))\\\n    .linkCollection(csPlus, [QA_BAND])\\\n    .map(lambda img: img.updateMask(img.select(QA_BAND).gte(CLEAR_THRESHOLD)))\\\n    .median()\n\ncomposite\n</code></pre> <pre>\n<code>&lt;ee.image.Image at 0x7efee73ebf70&gt;</code>\n</pre> <pre><code>from georeader import get_utm_epsg\nfrom georeader import window_utils\n\ncrs_utm = get_utm_epsg(footprint)\nfootprint_utm = window_utils.polygon_to_crs(footprint, \"EPSG:4326\", crs_utm)\n\ntransform = window_utils.figure_out_transform(bounds=footprint_utm.bounds, resolution_dst=30)\ntransform\n</code></pre> <pre>\n<code>Affine(30.0, 0.0, 602806.2544585154,\n       0.0, -30.0, 4471945.817948307)</code>\n</pre> <pre><code>%%time\nfrom georeader.readers import ee_image\nimport numpy as np\n\nmosaic = ee_image.export_image(composite, footprint, transform=transform, crs=crs_utm, \n                               bands_gee=[\"B4\",\"B3\",\"B2\"])\nmosaic\n</code></pre> <pre>\n<code>CPU times: user 473 ms, sys: 50.6 ms, total: 523 ms\nWall time: 1min 8s\n</code>\n</pre> <pre>\n<code> \n         Transform: | 30.00, 0.00, 602806.25|\n| 0.00,-30.00, 4471945.82|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 1186, 1263)\n         Resolution: (30.0, 30.0)\n         Bounds: (602806.2544585154, 4436365.817948307, 640696.2544585154, 4471945.817948307)\n         CRS: EPSG:32640\n         fill_value_default: None\n        </code>\n</pre> <pre><code>from georeader import plot\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(1,1, figsize=(8,8))\n\nmosaic = mosaic.pad({\"x\": (5,5), \"y\": (5,5)})\nmosaic_rgb = (mosaic / 5_500).clip(0,1)\nplot.show(mosaic_rgb, ax=ax)\n\nplot.add_shape_to_plot(footprint, ax=ax, crs_plot=mosaic_rgb.crs, polygon_no_fill=True, crs_shape=\"EPSG:4326\",\n                       kwargs_geopandas_plot={\"color\":\"red\"})\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre> <pre><code># https://medium.com/@nst11/annual-landsat-cloud-free-composite-in-google-earth-engine-c623b69749f7\ndef maskL8KH(image):\n  # Bits 3 and 5 are cloud shadow and cloud, respectively.\n  cloudShadowBitMask = (1 &amp;lt;&amp;lt; 3)\n  cloudsBitMask = (1 &amp;lt;&amp;lt; 5)\n  # Get the pixel QA band.\n  qa = image.select('QA_PIXEL')\n  # Both flags should be set to zero, indicating clear conditions.\n  mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0).And(qa.bitwiseAnd(cloudsBitMask).eq(0))\n  return image.updateMask(mask)\n\ncols = [\"LANDSAT/LC09/C02/T1_TOA\", \"LANDSAT/LC08/C02/T1_RT_TOA\", \"LANDSAT/LC08/C02/T2_TOA\",\"LANDSAT/LC09/C02/T2_TOA\"]\nl89col = ee.ImageCollection(cols[0])\nfor c in cols[1:]:\n    l89col.merge(ee.ImageCollection(c))\n\n\nROI = ee.Geometry(mapping(footprint))\n# ROI = ee.Geometry.Point(-119.9087, 37.4159)\n\ndate_search_min = date_search - timedelta(days=30)\ndate_search_max = date_search + timedelta(days=30)\ncomposite_l8 = l89col.filterBounds(ROI)\\\n    .filterDate(date_search_min.strftime('%Y-%m-%d'), date_search_max.strftime('%Y-%m-%d'))\\\n    .map(lambda img: maskL8KH(img))\\\n    .median()\n\ncomposite_l8\n</code></pre> <pre>\n<code>&lt;ee.image.Image at 0x7efed8dcbeb0&gt;</code>\n</pre> <pre><code>%%time\nmosaic_l8 = ee_image.export_image(composite, footprint, transform=transform, crs=crs_utm, \n                                  bands_gee=[\"B4\",\"B3\",\"B2\"])\nmosaic_l8\n</code></pre> <pre>\n<code> \n         Transform: | 30.00, 0.00, 602806.25|\n| 0.00,-30.00, 4471945.82|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 1186, 1263)\n         Resolution: (30.0, 30.0)\n         Bounds: (602806.2544585154, 4436365.817948307, 640696.2544585154, 4471945.817948307)\n         CRS: EPSG:32640\n         fill_value_default: None\n        </code>\n</pre> <pre><code>fig, ax = plt.subplots(1,1, figsize=(8,8))\n\nmosaic_l8 = mosaic_l8.pad({\"x\": (5,5), \"y\": (5,5)})\nmosaic_l8_rgb = (mosaic_l8 / 5_500).clip(0,1)\nplot.show(mosaic_l8_rgb, ax=ax)\n\nplot.add_shape_to_plot(footprint, ax=ax, crs_plot=mosaic_l8_rgb.crs, polygon_no_fill=True, crs_shape=\"EPSG:4326\",\n                       kwargs_geopandas_plot={\"color\":\"red\"})\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre>"},{"location":"Sentinel-2/s2_mosaic_from_gee/#query-a-spatial-mosaic-from-the-google-earth-engine","title":"Query a spatial mosaic from the Google Earth Engine","text":"<ul> <li>Last Modified: 3-12-2024</li> <li>Author: Gonzalo Mateo-Garc\u00eda</li> </ul> <p>This tutorial shows how to use the <code>georeaders.readers.ee_image</code> module to download an spatial composite with Sentinel-2 or Landsat. </p>"},{"location":"Sentinel-2/s2_mosaic_from_gee/#composite-for-landsat-8-and-9","title":"Composite for Landsat-8 and 9","text":"<p>Earth Engine code adapted from This blog post.</p>"},{"location":"Sentinel-2/s2_mosaic_from_gee/#licence","title":"Licence","text":"<p>The georeader package is published under a GNU Lesser GPL v3 licence</p> <p><code>georeader</code> tutorials and notebooks are released under a Creative Commons non-commercial licence.</p> <p>If you find this work useful please cite:</p> <pre><code>@article{portales-julia_global_2023,\n    title = {Global flood extent segmentation in optical satellite images},\n    volume = {13},\n    issn = {2045-2322},\n    doi = {10.1038/s41598-023-47595-7},\n    number = {1},\n    urldate = {2023-11-30},\n    journal = {Scientific Reports},\n    author = {Portal\u00e9s-Juli\u00e0, Enrique and Mateo-Garc\u00eda, Gonzalo and Purcell, Cormac and G\u00f3mez-Chova, Luis},\n    month = nov,\n    year = {2023},\n    pages = {20316},\n}\n</code></pre>"},{"location":"advanced/error_read_write_in_remote_path/","title":"Reading from remote location: GDAL VSIL caching issue","text":"<p>Reading a raster from a remote location (e.g. Google, Amazon or Azure bucket) fails if the file is read and modified by other (non-GDAL) function/process. This happens even if the file is closed after reading and then modified. This is because GDAL has a global cache when reading data from remote locations. This notebook shows this problem and a fix implemented in <code>RasterioReader</code> to skip the caching (called <code>read_with_CPL_VSIL_CURL_NON_CACHED</code>). A direct fix in GDAL would be to call <code>VSICurlClearCache</code> or <code>VSICurlPartialClearCache</code> C functions; however these are not mapped in <code>rasterio</code>. </p> <p>The solution implemented with <code>rasterio</code> consists of setting the <code>CPL_VSIL_CURL_NON_CACHED</code> GDAL option before opening the file with <code>rasterio</code>; see the fix in <code>georeader.rasterio_reader.RasterioReader._rio_open</code> function.</p> <pre><code>import os\nimport fsspec\n\nos.environ[\"AZURE_STORAGE_CONNECTION_STRING\"] = \"????\"\nfs = fsspec.filesystem(\"az\")\n</code></pre> <p>This example will read a 3-band rgb COG and modify it by a one band COG with a different shape. We will see that when the COG is modified we can't read the file again if we don't set the <code>read_with_CPL_VSIL_CURL_NON_CACHED</code> option. We will see either a read error (if we haven't loaded the data) or we will see the old cached data (if we have load the data).</p> <pre><code># Set up the files\n# rasterio_reader.RIO_ENV_OPTIONS_DEFAULT[\"CPL_CURL_VERBOSE\"] = \"YES\"\nrgb_file = \"az://mycontainer/rgb.tif\"\none_band_file = \"az://mycontainer/one_band.tif\"\nassert fs.exists(rgb_file)\nassert fs.exists(one_band_file)\n\nfilepath = \"az://mycontainer/removeme.tif\"\nif fs.exists(filepath):\n    fs.delete(filepath)\n</code></pre> <pre><code>from georeader.rasterio_reader import RasterioReader\n\nfs.copy(rgb_file, filepath)\nrst = RasterioReader(filepath)\nrst\n</code></pre> <pre><code>         Paths: ['az://mycontainer/removeme.tif']\n         Transform: | 30.00, 0.00, 740744.72|\n| 0.00,-30.00, 4287081.96|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 1176, 1168)\n         Resolution: (30.0, 30.0)\n         Bounds: (740744.717767204, 4251801.958449183, 775784.717767204, 4287081.958449183)\n         CRS: EPSG:32641\n         nodata: 0.0\n         fill_value_default: 0.0\n</code></pre> <p>Reading now fails (we haven't loaded the data).</p> <pre><code>fs.copy(one_band_file, filepath)\nrst = RasterioReader(filepath)\ndata_rst = rst.load()\ndata_rst\n</code></pre> <pre><code>---------------------------------------------------------------------------\n\nCPLE_AppDefinedError                      Traceback (most recent call last)\n\nCPLE_AppDefinedError: LZWDecode:Corrupted LZW table at scanline 0\n\n\nThe above exception was the direct cause of the following exception:\n\n\nCPLE_AppDefinedError                      Traceback (most recent call last)\n\nCPLE_AppDefinedError: TIFFReadEncodedTile() failed.\n\n\nThe above exception was the direct cause of the following exception:\n\n\nCPLE_AppDefinedError                      Traceback (most recent call last)\n\nFile rasterio/_io.pyx:969, in rasterio._io.DatasetReaderBase._read()\n\n\nFile rasterio/_io.pyx:199, in rasterio._io.io_multi_band()\n\n\nFile rasterio/_io.pyx:205, in rasterio._io.io_multi_band()\n\n\nFile rasterio/_err.pyx:325, in rasterio._err.StackChecker.exc_wrap_int()\n\n\nCPLE_AppDefinedError: removeme.tif, band 1: IReadBlock failed at X offset 0, Y offset 0: TIFFReadEncodedTile() failed.\n\n\nThe above exception was the direct cause of the following exception:\n\n\nRasterioIOError                           Traceback (most recent call last)\n\nCell In[4], line 3\n      1 fs.copy(one_band_file, filepath)\n      2 rst = RasterioReader(filepath)\n----&gt; 3 data_rst = rst.load()\n      4 data_rst\n\n\nFile ~/git/georeader/georeader/rasterio_reader.py:554, in RasterioReader.load(self, boundless)\n    546 def load(self, boundless:bool=True) -&gt; geotensor.GeoTensor:\n    547     \"\"\"\n    548     Load all raster in memory in an GeoTensor object\n    549 \n   (...)\n    552 \n    553     \"\"\"\n--&gt; 554     np_data = self.read(boundless=boundless)\n    555     if boundless:\n    556         transform = self.transform\n\n\nFile ~/git/georeader/georeader/rasterio_reader.py:704, in RasterioReader.read(self, **kwargs)\n    699 for i, p in enumerate(self.paths):\n    700     # with rasterio.Env(**options):\n    701     #     with rasterio.open(p, \"r\", overview_level=self.overview_level) as src:\n    702     with self._rio_open(p, overview_level=self.overview_level) as src:\n    703         # rasterio.read API: https://rasterio.readthedocs.io/en/latest/api/rasterio.io.html#rasterio.io.DatasetReader.read\n--&gt; 704         read_data = src.read(**kwargs)\n    706         # Add pad when reading\n    707         if pad is not None and need_pad:\n\n\nFile rasterio/_io.pyx:644, in rasterio._io.DatasetReaderBase.read()\n\n\nFile rasterio/_io.pyx:972, in rasterio._io.DatasetReaderBase._read()\n\n\nRasterioIOError: Read failed. See previous exception for details.\n</code></pre> <pre><code>rst.rio_env_options\n</code></pre> <pre><code>{'GDAL_DISABLE_READDIR_ON_OPEN': 'EMPTY_DIR',\n 'GDAL_HTTP_MERGE_CONSECUTIVE_RANGES': 'YES',\n 'GDAL_CACHEMAX': 2000000000,\n 'GDAL_HTTP_MULTIPLEX': 'YES'}\n</code></pre> <pre><code>fs.delete(filepath)\n</code></pre> <p>Reading and loading the data will return the old data instead of the new one. (The rgb raster had 3 bands and the other one only one).</p> <pre><code>filepath = \"az://mycontainer/removeme2.tif\"\nif fs.exists(filepath):\n    fs.delete(filepath)\n\nfs.copy(rgb_file, filepath)\nrst_mem = RasterioReader(filepath).load()\nrst_mem\n</code></pre> <pre><code>         Transform: | 30.00, 0.00, 740744.72|\n| 0.00,-30.00, 4287081.96|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 1176, 1168)\n         Resolution: (30.0, 30.0)\n         Bounds: (740744.717767204, 4251801.958449183, 775784.717767204, 4287081.958449183)\n         CRS: EPSG:32641\n         fill_value_default: 0.0\n</code></pre> <pre><code>fs.copy(one_band_file, filepath)\nrst = RasterioReader(filepath)\ndata_rst = rst.load()\ndata_rst\n</code></pre> <pre><code>         Transform: | 30.00, 0.00, 740744.72|\n| 0.00,-30.00, 4287081.96|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 1176, 1168)\n         Resolution: (30.0, 30.0)\n         Bounds: (740744.717767204, 4251801.958449183, 775784.717767204, 4287081.958449183)\n         CRS: EPSG:32641\n         fill_value_default: 0.0\n</code></pre> <pre><code>fs.delete(filepath)\n</code></pre> <p>Adding option  <code>read_with_CPL_VSIL_CURL_NON_CACHED</code> fixes the problem, we see that after the second copy the raster has 1 channel instead of 3.</p> <pre><code>from georeader import rasterio_reader\nrasterio_reader.RIO_ENV_OPTIONS_DEFAULT[\"read_with_CPL_VSIL_CURL_NON_CACHED\"] = True\n</code></pre> <pre><code>filepath = \"az://mycontainer/removeme3.tif\"\nif fs.exists(filepath):\n    fs.delete(filepath)\n\nfs.copy(rgb_file, filepath)\nrst_mem = RasterioReader(filepath).load()\nrst_mem\n</code></pre> <pre><code>         Transform: | 30.00, 0.00, 740744.72|\n| 0.00,-30.00, 4287081.96|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 1176, 1168)\n         Resolution: (30.0, 30.0)\n         Bounds: (740744.717767204, 4251801.958449183, 775784.717767204, 4287081.958449183)\n         CRS: EPSG:32641\n         fill_value_default: 0.0\n</code></pre> <pre><code>fs.copy(one_band_file, filepath)\nrst = RasterioReader(filepath)\ndata_rst = rst.load()\ndata_rst\n</code></pre> <pre><code>         Transform: | 30.00, 0.00, 255639.31|\n| 0.00,-30.00, 3165851.00|\n| 0.00, 0.00, 1.00|\n         Shape: (1, 1262, 1369)\n         Resolution: (30.0, 30.0)\n         Bounds: (255639.3130302397, 3127990.9952690094, 296709.31303023966, 3165850.9952690094)\n         CRS: EPSG:32640\n         fill_value_default: -1.0\n</code></pre> <pre><code>fs.delete(filepath)\n</code></pre> <p>If we don't load the data we don't have the error and the file is correctly readed too:</p> <pre><code>filepath = \"az://mycontainer/removeme3.tif\"\nif fs.exists(filepath):\n    fs.delete(filepath)\n\nfs.copy(rgb_file, filepath)\nrst = RasterioReader(filepath)\nrst\n</code></pre> <pre><code>         Paths: ['az://mycontainer/removeme3.tif']\n         Transform: | 30.00, 0.00, 740744.72|\n| 0.00,-30.00, 4287081.96|\n| 0.00, 0.00, 1.00|\n         Shape: (3, 1176, 1168)\n         Resolution: (30.0, 30.0)\n         Bounds: (740744.717767204, 4251801.958449183, 775784.717767204, 4287081.958449183)\n         CRS: EPSG:32641\n         nodata: 0.0\n         fill_value_default: 0.0\n</code></pre> <pre><code>fs.copy(one_band_file, filepath)\nrst = RasterioReader(filepath)\ndata_rst = rst.load()\ndata_rst\n</code></pre> <pre><code>         Transform: | 30.00, 0.00, 255639.31|\n| 0.00,-30.00, 3165851.00|\n| 0.00, 0.00, 1.00|\n         Shape: (1, 1262, 1369)\n         Resolution: (30.0, 30.0)\n         Bounds: (255639.3130302397, 3127990.9952690094, 296709.31303023966, 3165850.9952690094)\n         CRS: EPSG:32640\n         fill_value_default: -1.0\n</code></pre> <pre><code>rst.rio_env_options\n</code></pre> <pre><code>{'GDAL_DISABLE_READDIR_ON_OPEN': 'EMPTY_DIR',\n 'GDAL_HTTP_MERGE_CONSECUTIVE_RANGES': 'YES',\n 'GDAL_CACHEMAX': 2000000000,\n 'GDAL_HTTP_MULTIPLEX': 'YES',\n 'read_with_CPL_VSIL_CURL_NON_CACHED': True}\n</code></pre>"},{"location":"advanced/tiling_and_stitching/","title":"Tile and stitch AI predictions","text":"<pre><code>import os\nfrom georeader.readers import S2_SAFE_reader\nfrom georeader import read\nfrom shapely.geometry import box\nfrom georeader import plot\nfrom cloudsen12_models import cloudsen12\nfrom georeader import slices\nfrom rasterio import windows\nfrom georeader.geotensor import GeoTensor\nfrom georeader import window_utils\nimport numpy as np\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\n\nos.environ[\"GS_NO_SIGN_REQUEST\"] = \"YES\"\n</code></pre> <pre>\n<code>/home/gonzalo/mambaforge/envs/marsmlpy312/lib/python3.12/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</code>\n</pre> <pre><code>%%time\n\n# Download a S2 product\nsafe_file = \"S2A_MSIL1C_20240417T064631_N0510_R020_T40RCN_20240417T091941.SAFE\"\ns2_safe_folder = S2_SAFE_reader.s2_public_bucket_path(safe_file, check_exists=False)\n\nprint(f\"File is located at: {s2_safe_folder}\")\n\ns2obj = S2_SAFE_reader.s2loader(s2_safe_folder, out_res=10)\n\ntempfolder = \"../../deleteme\"\nos.makedirs(tempfolder,exist_ok=True)\ns2obj = s2obj.cache_product_to_local_dir(tempfolder)\n\ns2obj\n</code></pre> <pre>\n<code>File is located at: gs://gcp-public-data-sentinel-2/tiles/40/R/CN/S2A_MSIL1C_20240417T064631_N0510_R020_T40RCN_20240417T091941.SAFE\n</code>\n</pre> <pre>\n<code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 13/13 [00:00&lt;00:00, 12409.18it/s]</code>\n</pre> <pre>\n<code>CPU times: user 144 ms, sys: 26.9 ms, total: 170 ms\nWall time: 257 ms\n</code>\n</pre> <pre>\n<code>\n</code>\n</pre> <pre>\n<code> \n         ../../deleteme/S2A_MSIL1C_20240417T064631_N0510_R020_T40RCN_20240417T091941.SAFE\n         Transform: | 10.00, 0.00, 300000.00|\n| 0.00,-10.00, 2800020.00|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 10980, 10980)\n         Resolution: (10.0, 10.0)\n         Bounds: (300000.0, 2690220.0, 409800.0, 2800020.0)\n         CRS: EPSG:32640\n         bands: ['B01', 'B02', 'B03', 'B04', 'B05', 'B06', 'B07', 'B08', 'B8A', 'B09', 'B10', 'B11', 'B12']\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>%%time\naoi = box(55.325, 25.21, 55.515, 25.31)\n\ndata = read.read_from_polygon(s2obj, aoi, crs_polygon=\"EPSG:4326\", trigger_load=True)\ndata\n</code></pre> <pre>\n<code>CPU times: user 25.1 s, sys: 735 ms, total: 25.9 s\nWall time: 12.2 s\n</code>\n</pre> <pre>\n<code> \n         Transform: | 10.00, 0.00, 331240.00|\n| 0.00,-10.00, 2800330.00|\n| 0.00, 0.00, 1.00|\n         Shape: (13, 1131, 1928)\n         Resolution: (10.0, 10.0)\n         Bounds: (331240.0, 2789020.0, 350520.0, 2800330.0)\n         CRS: EPSG:32640\n         fill_value_default: 0\n        </code>\n</pre> <pre><code>model = cloudsen12.load_model_by_name(name=\"UNetMobV2_V2\", \n                                      weights_folder=\"../../cloudsen12_models\")\n</code></pre> <pre><code>overlap_total_pixels = 32 #  on each side!\nwindow_size_predict_nn = 512\n\ninput_tensor = data\n\nwindows_write = slices.create_windows(input_tensor.shape[-2:], \n                                      window_size=(window_size_predict_nn-overlap_total_pixels, \n                                                   window_size_predict_nn-overlap_total_pixels), \n                                      overlap=(0, 0), \n                                      trim_incomplete=True)\n\n\noutput_tensor = GeoTensor(np.full(input_tensor.shape[-2:],fill_value=0,dtype=np.float32), \n                          transform=input_tensor.transform, \n                          crs=input_tensor.crs,\n                          fill_value_default = 0)\n\nfor w_write in tqdm(windows_write):\n    w_read = window_utils.pad_window_to_size(w_write, \n                                             size=(window_size_predict_nn, \n                                                   window_size_predict_nn))\n\n    input_tensor_iter = read.read_from_window(input_tensor, \n                                              window=w_read, \n                                              boundless=True,\n                                             trigger_load=True)\n    valids_iter = np.all(input_tensor_iter.values != input_tensor_iter.fill_value_default, \n                         axis=0)\n\n    if not np.any(valids_iter):\n        # print(\"All invalid\")\n        continue\n\n    slice_save = window_utils.slice_save_for_pred(w_read, w_write)\n\n    out = model.predict(input_tensor_iter.values / 10_000)\n    out[~valids_iter] = output_tensor.fill_value_default\n    out_save = out[slice_save]\n\n    output_tensor.write_from_window(out_save, window=w_write)\n</code></pre> <pre>\n<code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 15/15 [00:05&lt;00:00,  2.76it/s]\n</code>\n</pre> <pre><code># For plotting\nbands = s2obj.bands\nswirnirred = (data.isel({\"band\": [bands.index(b) for b in [\"B11\",\"B08\",\"B04\"]]}) / 4_500.).clip(0,1)\n\nfig, ax = plt.subplots(1,2,figsize=(14,5),sharey=True, tight_layout=True)\nplot.show(swirnirred,ax=ax[0])\ncloudsen12.plot_cloudSEN12mask(output_tensor,ax=ax[1])\n</code></pre> <pre>\n<code>&lt;Axes: &gt;</code>\n</pre>"},{"location":"advanced/tiling_and_stitching/#tiling-and-stitching-segmentation-outputs","title":"Tiling and stitching segmentation outputs","text":"<ul> <li>Author: Gonzalo Mateo-Garc\u00eda</li> </ul> <p>This tutorial shows how to run an AI model by fix-size tiles following the recommendations of Huang et al. 2018:</p> <p>B. Huang, D. Reichman, L. M. Collins, K. Bradbury, and J. M. Malof, Tiling and Stitching Segmentation Output for Remote Sensing: Basic Challenges and Recommendations, arXiv:1805.12219</p> <pre><code>pip install cloudsen12_models georeader-spaceml fsspec gcsfs\n</code></pre>"},{"location":"advanced/tiling_and_stitching/#load-sample-data","title":"Load sample data","text":""},{"location":"advanced/tiling_and_stitching/#load-model","title":"Load model","text":"<p>We will use the CloudSEN12 cloud detection model as sample.</p>"},{"location":"advanced/tiling_and_stitching/#tiling-and-stitching-loop","title":"Tiling and stitching loop","text":""},{"location":"advanced/tiling_and_stitching/#licence","title":"Licence","text":"<p>This notebook is released under a Creative Commons non-commercial licence.</p> <p>The <code>cloudsen12_models</code> package is published under a GNU Lesser GPL v3 licence</p> <p>The CloudSEN12 database and all pre-trained models are released under a Creative Commons non-commercial licence. For using the models in comercial pipelines written consent by the authors must be provided.</p> <p>If you find this work useful please cite: <pre><code>@article{aybar_cloudsen12_2024,\n    title = {{CloudSEN12}+: {The} largest dataset of expert-labeled pixels for cloud and cloud shadow detection in {Sentinel}-2},\n    issn = {2352-3409},\n    url = {https://www.sciencedirect.com/science/article/pii/S2352340924008163},\n    doi = {10.1016/j.dib.2024.110852},\n    journal = {Data in Brief},\n    author = {Aybar, Cesar and Bautista, Lesly and Montero, David and Contreras, Julio and Ayala, Daryl and Prudencio, Fernando and Loja, Jhomira and Ysuhuaylas, Luis and Herrera, Fernando and Gonzales, Karen and Valladares, Jeanett and Flores, Lucy A. and Mamani, Evelin and Qui\u00f1onez, Maria and Fajardo, Rai and Espinoza, Wendy and Limas, Antonio and Yali, Roy and Alc\u00e1ntara, Alejandro and Leyva, Martin and Loayza-Muro, Rau\u00b4l and Willems, Bram and Mateo-Garc\u00eda, Gonzalo and G\u00f3mez-Chova, Luis},\n    month = aug,\n    year = {2024},\n    pages = {110852},\n}\n</code></pre></p>"},{"location":"modules/ee_image/","title":"ee_image","text":""},{"location":"modules/ee_image/#google-earth-engine-functions","title":"Google Earth Engine functions","text":"<p>We have implemented functions to query and export arbitrarly large images from the Google Earth Engine.  Functions to export images or cubes are in module <code>georeader.readers.ee_image</code> and functions to query Sentinel-1, Sentinel-2 and Landsat are available in <code>georeader.readers.ee_query</code>.</p>"},{"location":"modules/ee_image/#georeader.readers.ee_image.export_image","title":"<code>export_image(image_or_asset_id, geometry, transform, crs, bands_gee, dtype_dst=None, pad_add=(0, 0), crs_polygon='EPSG:4326', resolution_dst=None)</code>","text":"<p>Exports an image from the GEE as a GeoTensor.   It uses the <code>ee.data.getPixels</code> or <code>ee.data.computePixels</code> method to export the image.</p> <p>Parameters:</p> Name Type Description Default <code>image_or_asset_id</code> <code>Union[str, Image]</code> <p>Name of the asset or ee.Image object.</p> required <code>geometry</code> <code>Union[Polygon, MultiPolygon]</code> <p>geometry to export</p> required <code>transform</code> <code>Affine</code> <p>transform of the geometry</p> required <code>crs</code> <code>str</code> <p>crs of the geometry</p> required <code>pad_add</code> <code>Tuple[int, int]</code> <p>pad in pixels to add to the resulting <code>window</code> that is read. This is useful when this function  is called for interpolation/CNN prediction.</p> <code>(0, 0)</code> <code>bands_gee</code> <code>List[str]</code> <p>List of bands to export</p> required <code>crs_polygon</code> <code>str</code> <p>crs of the geometry. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>GeoTensor</code> <p>GeoTensor object</p> Source code in <code>georeader/readers/ee_image.py</code> <pre><code>def export_image(image_or_asset_id:Union[str, ee.Image], \n                 geometry:Union[Polygon, MultiPolygon],\n                 transform:Affine, crs:str,\n                 bands_gee:List[str], \n                 dtype_dst:Optional[str]=None,\n                 pad_add:Tuple[int, int]=(0, 0),\n                 crs_polygon:str=\"EPSG:4326\",\n                 resolution_dst: Optional[Union[float, Tuple[float, float]]]=None) -&gt; GeoTensor:\n    \"\"\"\n    Exports an image from the GEE as a GeoTensor. \n     It uses the `ee.data.getPixels` or `ee.data.computePixels` method to export the image.\n\n    Args:\n        image_or_asset_id (Union[str, ee.Image]): Name of the asset or ee.Image object.\n        geometry (Union[Polygon, MultiPolygon]): geometry to export\n        transform (Affine): transform of the geometry\n        crs (str): crs of the geometry\n        pad_add: pad in pixels to add to the resulting `window` that is read. This is useful when this function \n            is called for interpolation/CNN prediction.\n        bands_gee (List[str]): List of bands to export\n        crs_polygon (str, optional): crs of the geometry. Defaults to \"EPSG:4326\".\n\n    Returns:\n        GeoTensor: GeoTensor object\n    \"\"\"\n    if isinstance(image_or_asset_id, str):\n        method = ee.data.getPixels\n        request_params = {\"assetId\": image_or_asset_id}\n    elif isinstance(image_or_asset_id, ee.Image):\n        method = ee.data.computePixels\n        request_params = {\"expression\": image_or_asset_id}\n        # TODO if crs and transform are not provided get it from the image?\n    else:\n        raise ValueError(f\"image_or_asset_id must be a string or ee.Image object found {type(image_or_asset_id)}\")\n\n    geodata = FakeGeoData(crs=crs, transform=transform)\n\n    # Pixel coordinates surrounding the geometry\n    window_polygon = read.window_from_polygon(geodata, geometry, crs_polygon=crs_polygon,\n                                              window_surrounding=True)\n    if any(p &gt; 0 for p in pad_add):\n        window_polygon = window_utils.pad_window(window_polygon, pad_add)\n    window_polygon = window_utils.round_outer_window(window_polygon)\n\n    # Shift the window to the image coordinates\n    transform_window = rasterio.windows.transform(window_polygon, geodata.transform)\n\n    if resolution_dst is not None:\n        transform_window = window_utils.transform_to_resolution_dst(transform_window, resolution_dst)\n\n    request_params.update({\n                    'fileFormat':\"GEO_TIFF\", \n                    'bandIds':  bands_gee,\n                    'grid': {\n                        'dimensions': {\n                            'height': window_polygon.height, \n                            'width': window_polygon.width\n                        },\n                        'affineTransform': {\n                            'scaleX': transform_window.a,\n                            'shearX': transform_window.b,\n                            'translateX': transform_window.c,\n                            'shearY': transform_window.d,\n                            'scaleY': transform_window.e,\n                            'translateY': transform_window.f\n                        },\n                        'crsCode': geodata.crs\n                    }\n                    })\n\n    try:\n        data_raw = method(request_params)\n        data = rasterio.open(BytesIO(data_raw))\n        geotensor = GeoTensor(data.read(), transform=data.transform,\n                             crs=data.crs, fill_value_default=data.nodata)\n        if dtype_dst is not None:\n            geotensor = geotensor.astype(dtype_dst)\n\n    except ee.EEException as e:\n        # Check if the exception starts with Total request size\n        if str(e).startswith(\"Total request size\"):\n            # Split the geometry in two and call recursively\n            pols_execute = []\n            for sb in split_bounds(geometry.bounds):\n                pol = box(*sb)\n                if not geometry.intersects(pol):\n                    continue\n                pols_execute.append(pol.intersection(geometry))\n\n            def process_bound(poly):\n                gt = export_image(image_or_asset_id=image_or_asset_id, geometry=poly, \n                                  crs=crs, transform=transform, \n                                  bands_gee=bands_gee, dtype_dst=dtype_dst, \n                                  crs_polygon=crs_polygon,\n                                  resolution_dst=resolution_dst)\n                return gt\n\n            with ThreadPoolExecutor() as executor:\n                geotensors = list(executor.map(process_bound, pols_execute))\n\n            # Remove None values from the list\n            geotensors = [gt for gt in geotensors if gt is not None]\n\n            dst_crs = geotensors[0].crs\n            aoi_dst_crs = window_utils.polygon_to_crs(geometry, \n                                                      crs_polygon=crs_polygon, \n                                                      dst_crs=dst_crs)\n\n            geotensor = mosaic.spatial_mosaic(geotensors, \n                                              dtype_dst=dtype_dst,\n                                              polygon=aoi_dst_crs, \n                                              dst_crs=dst_crs)\n        else:\n            raise e\n    return geotensor\n</code></pre>"},{"location":"modules/ee_image/#georeader.readers.ee_image.export_cube","title":"<code>export_cube(query, geometry, transform=None, crs=None, dtype_dst=None, bands_gee=None, crs_polygon='EPSG:4326', display_progress=True)</code>","text":"<p>Download all images in the query that intersects the geometry. </p> <p>Note: This function is intended for small areas. If the area is too big that there are several images per day that intesesects the geometry, it will not group the images by day.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>GeoDataFrame</code> <p>dataframe from <code>georeaders.readers.query</code>. Required columns: gee_id, collection_name, bands_gee</p> required <code>geometry</code> <code>Union[Polygon, MultiPolygon]</code> <p>geometry to export</p> required <code>transform</code> <code>Optional[Affine]</code> <p>transform of the geometry. If None it will use the transform of the first image translated to the geometry.  Defaults to None.</p> <code>None</code> <code>crs</code> <code>Optional[str]</code> <p>crs of the geometry. If None it will use the crs of the first image. Defaults to None.</p> <code>None</code> <code>dtype_dst</code> <code>Optional[str]</code> <p>dtype of the output GeoTensor. Defaults to None.</p> <code>None</code> <code>bands_gee</code> <code>Optional[List[str]]</code> <p>List of bands to export. If None it will use the bands_gee column in the query. Defaults to None.</p> <code>None</code> <code>crs_polygon</code> <code>_type_</code> <p>crs of the geometry. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>display_progress</code> <code>bool</code> <p>Display progress bar. Defaults to False.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Optional[GeoTensor]</code> <p>GeoTensor object with 4 dimensions: (time, band, y, x)</p> Source code in <code>georeader/readers/ee_image.py</code> <pre><code>def export_cube(query:gpd.GeoDataFrame, geometry:Union[Polygon, MultiPolygon], \n                transform:Optional[Affine]=None, crs:Optional[str]=None,\n                dtype_dst:Optional[str]=None,\n                bands_gee:Optional[List[str]]=None,\n                crs_polygon:str=\"EPSG:4326\",\n                display_progress:bool=True) -&gt; Optional[GeoTensor]:\n    \"\"\"\n    Download all images in the query that intersects the geometry. \n\n    Note: This function is intended for small areas. If the area is too big that there are several images per day that intesesects the geometry, it will not group the images by day.\n\n    Args:\n        query (gpd.GeoDataFrame): dataframe from `georeaders.readers.query`. Required columns: gee_id, collection_name, bands_gee\n        geometry (Union[Polygon, MultiPolygon]): geometry to export\n        transform (Optional[Affine], optional): transform of the geometry. If None it will use the transform of the first image translated to the geometry. \n            Defaults to None.\n        crs (Optional[str], optional): crs of the geometry. If None it will use the crs of the first image. Defaults to None.\n        dtype_dst (Optional[str], optional): dtype of the output GeoTensor. Defaults to None.\n        bands_gee (Optional[List[str]], optional): List of bands to export. If None it will use the bands_gee column in the query. Defaults to None.\n        crs_polygon (_type_, optional): crs of the geometry. Defaults to \"EPSG:4326\".\n        display_progress (bool, optional): Display progress bar. Defaults to False.\n\n    Returns:\n        GeoTensor: GeoTensor object with 4 dimensions: (time, band, y, x)\n    \"\"\"\n\n    # TODO group by solar_day and satellite??\n    if query.shape[0] == 0:\n        return None\n\n    # Check required columns\n    required_columns = [\"gee_id\", \"collection_name\"]\n    if bands_gee is None:\n        required_columns.append(\"bands_gee\")\n    if not all([col in query.columns for col in required_columns]):\n        raise ValueError(f\"Columns {required_columns} are required in the query dataframe\")\n\n    # Get the first image to get the crs and transform if not provided\n    if crs is None:\n        first_image = query.iloc[0]\n        if \"proj\" not in first_image:\n            raise ValueError(\"proj column is required in the query dataframe if crs is not provided\")\n        crs = first_image[\"proj\"][\"crs\"]\n\n    if transform is None:\n        first_image = query.iloc[0]\n        if \"proj\" not in first_image:\n            raise ValueError(\"proj column is required in the query dataframe if transform is not provided\")\n        transform = Affine(*first_image[\"proj\"][\"transform\"])\n\n\n    # geotensor_list = []\n    # for i, image in query.iterrows():\n    #     asset_id = f'{image[\"collection_name\"]}/{image[\"gee_id\"]}'\n    #     geotensor = export_image_getpixels(asset_id, geometry, proj, image[\"bands_gee\"], crs_polygon=crs_polygon, dtype_dst=dtype_dst)\n    #     geotensor_list.append(geotensor)\n\n    def process_query_image(tuple_row):\n        _, image = tuple_row\n        asset_id = f'{image[\"collection_name\"]}/{image[\"gee_id\"]}'\n        if bands_gee is None:\n            bands_gee_iter = image[\"bands_gee\"]\n        else:\n            bands_gee_iter = bands_gee\n        geotensor = export_image(asset_id, geometry=geometry, crs=crs, transform=transform,\n                                 bands_gee_iter=bands_gee_iter, \n                                 crs_polygon=crs_polygon, dtype_dst=dtype_dst)\n        return geotensor\n\n    with ThreadPoolExecutor() as executor:\n        geotensor_list = list(tqdm(executor.map(process_query_image, query.iterrows()), \n                                   total=query.shape[0], disable=not display_progress))\n\n    return concatenate(geotensor_list)\n</code></pre>"},{"location":"modules/ee_image/#georeader.readers.ee_query.query","title":"<code>query(area, date_start, date_end, producttype='S2', filter_duplicates=True, return_collection=False, add_s2cloudless=False, extra_metadata_keys=None)</code>","text":"<p>Query Landsat and Sentinel-2 products from the Google Earth Engine.</p> <p>Parameters:</p> Name Type Description Default <code>area</code> <code>Union[MultiPolygon, Polygon]</code> <p>area to query images in EPSG:4326</p> required <code>date_start</code> <code>datetime</code> <p>datetime in a given timezone. If tz not provided UTC will be assumed.</p> required <code>date_end</code> <code>datetime</code> <p>datetime in UTC. If tz not provided UTC will be assumed.</p> required <code>producttype</code> <code>str</code> <p>'S2', \"Landsat\"-&gt; {\"L8\", \"L9\"}, \"both\" -&gt; {\"S2\", \"L8\", \"L9\"}, \"S2_SR\", \"L8\", \"L9\"</p> <code>'S2'</code> <code>filter_duplicates</code> <code>bool</code> <p>Filter S2 images that are duplicated</p> <code>True</code> <code>return_collection</code> <code>bool</code> <p>returns also the corresponding image collection</p> <code>False</code> <code>add_s2cloudless</code> <code>bool</code> <p>Adds a column that indicates if the s2cloudless image is available (from collection COPERNICUS/S2_CLOUD_PROBABILITY collection)</p> <code>False</code> <code>extra_metadata_keys</code> <code>Optional[List[str]]</code> <p>list of extra metadata keys to add to the geodataframe.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[GeoDataFrame, Tuple[GeoDataFrame, ImageCollection]]</code> <p>geodataframe with available products in the given area and time range</p> <code>Union[GeoDataFrame, Tuple[GeoDataFrame, ImageCollection]]</code> <p>if <code>return_collection</code> is True it also returns the <code>ee.ImageCollection</code> of available images</p> Source code in <code>georeader/readers/ee_query.py</code> <pre><code>def query(area:Union[MultiPolygon,Polygon],\n          date_start:datetime, date_end:datetime,\n          producttype:str='S2', filter_duplicates:bool=True,\n          return_collection:bool=False,\n          add_s2cloudless:bool=False,\n          extra_metadata_keys:Optional[List[str]]=None\n          )-&gt; Union[gpd.GeoDataFrame, Tuple[gpd.GeoDataFrame, ee.ImageCollection]]:\n    \"\"\"\n    Query Landsat and Sentinel-2 products from the Google Earth Engine.\n\n    Args:\n        area: area to query images in EPSG:4326\n        date_start: datetime in a given timezone. If tz not provided UTC will be assumed.\n        date_end: datetime in UTC. If tz not provided UTC will be assumed.\n        producttype: 'S2', \"Landsat\"-&gt; {\"L8\", \"L9\"}, \"both\" -&gt; {\"S2\", \"L8\", \"L9\"}, \"S2_SR\", \"L8\", \"L9\"\n        filter_duplicates: Filter S2 images that are duplicated\n        return_collection: returns also the corresponding image collection\n        add_s2cloudless: Adds a column that indicates if the s2cloudless image is available (from collection\n            COPERNICUS/S2_CLOUD_PROBABILITY collection)\n        extra_metadata_keys: list of extra metadata keys to add to the geodataframe.\n\n    Returns:\n        geodataframe with available products in the given area and time range\n        if `return_collection` is True it also returns the `ee.ImageCollection` of available images\n    \"\"\"\n\n    pol = ee.Geometry(mapping(area))\n\n    if date_start.tzinfo is not None:\n        tz = date_start.tzinfo\n        if isinstance(tz, ZoneInfo):\n            tz = tz.key\n\n        date_start = date_start.astimezone(timezone.utc)\n        date_end = date_end.astimezone(timezone.utc)\n    else:\n        tz = timezone.utc\n\n    assert date_end &gt;= date_start, f\"Date end: {date_end} prior to date start: {date_start}\"\n\n    if producttype == \"S2_SR\":\n        image_collection_name = \"COPERNICUS/S2_SR_HARMONIZED\"\n        keys_query = {\"PRODUCT_ID\": \"title\", 'CLOUDY_PIXEL_PERCENTAGE': \"cloudcoverpercentage\"}\n    elif producttype == \"S2\":\n        image_collection_name = \"COPERNICUS/S2_HARMONIZED\"\n        keys_query = {\"PRODUCT_ID\": \"title\", 'CLOUDY_PIXEL_PERCENTAGE': \"cloudcoverpercentage\"}\n    elif producttype == \"Landsat\":\n        image_collection_name = \"LANDSAT/LC08/C02/T1_RT_TOA\"\n        keys_query = {\"LANDSAT_PRODUCT_ID\": \"title\", 'CLOUD_COVER': \"cloudcoverpercentage\"}\n    elif producttype == \"L8\":\n        image_collection_name = \"LANDSAT/LC08/C02/T1_RT_TOA\"\n        keys_query = {\"LANDSAT_PRODUCT_ID\": \"title\", 'CLOUD_COVER': \"cloudcoverpercentage\"}\n    elif producttype == \"L9\":\n        image_collection_name = \"LANDSAT/LC09/C02/T1_TOA\"\n        keys_query = {\"LANDSAT_PRODUCT_ID\": \"title\", 'CLOUD_COVER': \"cloudcoverpercentage\"}\n    elif producttype == \"both\":\n        image_collection_name = \"LANDSAT/LC08/C02/T1_RT_TOA\"\n        keys_query = {\"LANDSAT_PRODUCT_ID\": \"title\", 'CLOUD_COVER': \"cloudcoverpercentage\"}\n    else:\n        raise NotImplementedError(f\"Unknown product type {producttype}\")\n\n    img_col = ee.ImageCollection(image_collection_name).filterDate(date_start.replace(tzinfo=None),\n                                                                   date_end.replace(tzinfo=None)).filterBounds(\n        pol)\n    if \"T1\" in image_collection_name:\n        # Add tier 2 data to the query\n        image_collection_name_t2 = image_collection_name.replace(\"T1_RT\", \"T2\").replace(\"T1\", \"T2\")\n        img_col_t1 = ee.ImageCollection(image_collection_name_t2).filterDate(date_start.replace(tzinfo=None),\n                                                                     date_end.replace(tzinfo=None)).filterBounds(\n            pol)\n        img_col = img_col.merge(img_col_t1)\n\n    if (producttype == \"Landsat\") or (producttype == \"both\"):\n        img_col_l9 = ee.ImageCollection(\"LANDSAT/LC09/C02/T1_TOA\").filterDate(date_start.replace(tzinfo=None),\n                                                                   date_end.replace(tzinfo=None)).filterBounds(\n        pol)\n        img_col = img_col.merge(img_col_l9)\n        img_col_l9_t2 = ee.ImageCollection(\"LANDSAT/LC09/C02/T2_TOA\").filterDate(date_start.replace(tzinfo=None),\n                                                                   date_end.replace(tzinfo=None)).filterBounds(\n        pol)\n        img_col = img_col.merge(img_col_l9_t2)\n\n    if extra_metadata_keys is None:\n        extra_metadata_keys = []\n\n    geodf = img_collection_to_feature_collection(img_col,\n                                                 [\"system:time_start\"] + list(keys_query.keys()) + extra_metadata_keys,\n                                                as_geopandas=True, band_crs=\"B2\")\n\n\n    geodf.rename(keys_query, axis=1, inplace=True)\n\n    # Filter tirs only image (title starts with LT08)\n    if geodf.shape[0] &gt; 0:\n        tile_starts_with_lt08 = geodf[\"title\"].str.startswith(\"LT08\")\n        if tile_starts_with_lt08.any():\n            warnings.warn(f\"Found {tile_starts_with_lt08.sum()} images of Landsat-8 TIRS only. Removing them.\")\n            geodf = geodf[~tile_starts_with_lt08].copy()\n        if (producttype == \"Landsat\") or (producttype == \"both\") or (producttype == \"L8\") or (producttype == \"L9\"):\n            geodf[\"collection_name\"] = geodf[\"title\"].apply(figure_out_collection_landsat)\n        else:\n            geodf[\"collection_name\"] = image_collection_name\n\n    img_col = img_col.map(lambda x: _rename_add_properties(x, keys_query))\n\n    if producttype == \"both\":\n        img_col_s2 = ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\").filterDate(date_start.replace(tzinfo=None),\n                                                                              date_end.replace(\n                                                                                  tzinfo=None)).filterBounds(\n            pol)\n        keys_query_s2 = {\"PRODUCT_ID\": \"title\", 'CLOUDY_PIXEL_PERCENTAGE': \"cloudcoverpercentage\"}\n        geodf_s2 = img_collection_to_feature_collection(img_col_s2,\n                                                        [\"system:time_start\"] + list(keys_query_s2.keys()) + extra_metadata_keys,\n                                                        as_geopandas=True, band_crs=\"B2\")\n        geodf_s2[\"collection_name\"] = \"COPERNICUS/S2_HARMONIZED\"\n        geodf_s2.rename(keys_query_s2, axis=1, inplace=True)\n        if geodf_s2.shape[0] &gt; 0:\n            if geodf.shape[0] == 0:\n                geodf = geodf_s2\n            else:\n                geodf = pd.concat([geodf_s2, geodf], ignore_index=True)\n\n            img_col_s2 = img_col_s2.map(lambda x: _rename_add_properties(x, keys_query_s2))\n            img_col = img_col.merge(img_col_s2)\n\n    if geodf.shape[0] == 0:\n        warnings.warn(f\"Not images found of collection {producttype} between dates {date_start} and {date_end}\")\n        if return_collection:\n            return geodf, img_col\n        return geodf\n\n    if add_s2cloudless and producttype in [\"both\", \"S2\"]:\n        values_s2_idx = geodf.title.apply(lambda x: x.startswith(\"S2\"))\n        indexes_s2 = geodf.gee_id[values_s2_idx].tolist()\n        img_col_cloudprob = ee.ImageCollection(\"COPERNICUS/S2_CLOUD_PROBABILITY\").filterDate(date_start.replace(tzinfo=None),\n                                                                              date_end.replace(\n                                                                                  tzinfo=None)).filterBounds(\n            pol)\n        img_col_cloudprob = img_col_cloudprob.filter(ee.Filter.inList(\"system:index\", ee.List(indexes_s2)))\n        geodf_cloudprob = img_collection_to_feature_collection(img_col_cloudprob,\n                                                               [\"system:time_start\"],\n                                                               as_geopandas=True)\n        geodf[\"s2cloudless\"] = False\n        list_geeid = geodf_cloudprob.gee_id.tolist()\n        geodf.loc[values_s2_idx, \"s2cloudless\"] = geodf.loc[values_s2_idx, \"gee_id\"].apply(lambda x: x in list_geeid)\n\n\n    geodf = _add_stuff(geodf, area, tz)\n\n    # Fix ids of Landsat to remove initial shit in the names\n    # projects/earthengine-public/assets/LANDSAT/LC09/C02/T1_TOA/1_2_LO09_037031_20220315\n    if geodf.satellite.str.startswith(\"LC0\").any():\n        geodf.loc[geodf.satellite.str.startswith(\"LC0\"),\"gee_id\"] = geodf.loc[geodf.satellite.str.startswith(\"LC0\"),\"gee_id\"].apply(lambda x: \"LC0\"+x.split(\"LC0\")[1])\n\n    # Fix ids of Landsat to remove initial shit in the names also if satellite starts with LO0\n    if geodf.satellite.str.startswith(\"LO0\").any():\n        geodf.loc[geodf.satellite.str.startswith(\"LO0\"),\"gee_id\"] = geodf.loc[geodf.satellite.str.startswith(\"LO0\"),\"gee_id\"].apply(lambda x: \"LO0\"+x.split(\"LO0\")[1])\n\n\n    if filter_duplicates:\n        # TODO filter prioritizing s2cloudless?\n        geodf = query_utils.filter_products_overlap(area, geodf,\n                                                    groupkey=[\"solarday\", \"satellite\"]).copy()\n        # filter img_col:\n        img_col = img_col.filter(ee.Filter.inList(\"title\", ee.List(geodf.index.tolist())))\n\n    geodf.sort_values(\"utcdatetime\")\n    img_col = img_col.sort(\"system:time_start\")\n\n    if return_collection:\n        return geodf, img_col\n\n    return geodf\n</code></pre>"},{"location":"modules/ee_image/#georeader.readers.ee_query.query_s1","title":"<code>query_s1(area, date_start, date_end, filter_duplicates=True, return_collection=False)</code>","text":"<p>Query S1 products from the Google Earth Engine</p> <p>Parameters:</p> Name Type Description Default <code>area</code> <code>Union[MultiPolygon, Polygon]</code> required <code>date_start</code> <code>datetime</code> required <code>date_end</code> <code>datetime</code> required <code>filter_duplicates</code> <code>bool</code> <code>True</code> <code>return_collection</code> <code>bool</code> <code>False</code> <p>Returns:</p> Source code in <code>georeader/readers/ee_query.py</code> <pre><code>def query_s1(area:Union[MultiPolygon,Polygon],\n             date_start:datetime, date_end:datetime,\n             filter_duplicates:bool=True,\n             return_collection:bool=False)-&gt; Union[gpd.GeoDataFrame, Tuple[gpd.GeoDataFrame, ee.ImageCollection]]:\n    \"\"\"\n    Query S1 products from the Google Earth Engine\n\n    Args:\n        area:\n        date_start:\n        date_end:\n        filter_duplicates:\n        return_collection:\n\n    Returns:\n\n    \"\"\"\n    pol = ee.Geometry(mapping(area))\n\n    if date_start.tzinfo is not None:\n        tz = date_start.tzinfo\n        if isinstance(tz, ZoneInfo):\n            tz = tz.key\n\n        date_start = date_start.astimezone(timezone.utc)\n        date_end = date_end.astimezone(timezone.utc)\n    else:\n        tz = timezone.utc\n\n    assert date_end &gt;= date_start, f\"Date end: {date_end} prior to date start: {date_start}\"\n\n    img_col = ee.ImageCollection('COPERNICUS/S1_GRD').\\\n       filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV')).\\\n       filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH')).\\\n       filter(ee.Filter.eq('instrumentMode', 'IW')).\\\n       filterDate(date_start.replace(tzinfo=None),\n                  date_end.replace(tzinfo=None)).\\\n       filterBounds(pol)\n\n    keys_query = {\"orbitProperties_pass\": \"orbitProperties_pass\"}\n\n    geodf = img_collection_to_feature_collection(img_col,\n                                                 [\"system:time_start\"] + list(keys_query.keys()),\n                                                 as_geopandas=True, band_crs=\"VV\")\n    geodf.rename(keys_query, axis=1, inplace=True)\n    geodf[\"title\"] = geodf[\"gee_id\"]\n    geodf[\"collection_name\"] = \"COPERNICUS/S1_GRD\"\n    geodf = _add_stuff(geodf, area, tz)\n\n    if filter_duplicates:\n        geodf = query_utils.filter_products_overlap(area, geodf,\n                                                    groupkey=[\"solarday\", \"satellite\",\"orbitProperties_pass\"]).copy()\n        # filter img_col:\n        img_col = img_col.filter(ee.Filter.inList(\"system:index\", ee.List(geodf.index.tolist())))\n\n    geodf.sort_values(\"utcdatetime\")\n    img_col = img_col.sort(\"system:time_start\")\n\n    if return_collection:\n        return geodf, img_col\n\n    return geodf\n</code></pre>"},{"location":"modules/ee_image/#georeader.readers.ee_query.query_landsat_457","title":"<code>query_landsat_457(area, date_start, date_end, producttype='all', filter_duplicates=True, return_collection=False, extra_metadata_keys=None)</code>","text":"<p>Query Landsat-7, Landsat-5 or Landsat-4 products from the Google Earth Engine.</p> <p>Parameters:</p> Name Type Description Default <code>area</code> <code>Union[MultiPolygon, Polygon]</code> <p>area to query images in EPSG:4326</p> required <code>date_start</code> <code>datetime</code> <p>datetime in a given timezone. If tz not provided UTC will be assumed.</p> required <code>date_end</code> <code>datetime</code> <p>datetime in UTC. If tz not provided UTC will be assumed.</p> required <code>producttype</code> <code>str</code> <p>'all' -&gt; {\"L4\", \"L5\", \"L7\"}, \"L4\", \"L5\" or \"L7\". Defaults to \"all\".</p> <code>'all'</code> <code>filter_duplicates</code> <code>bool</code> <p>filter duplicate images over the same area. Defaults to True.</p> <code>True</code> <code>return_collection</code> <code>bool</code> <p>returns also the corresponding image collection. Defaults to False.</p> <code>False</code> <code>extra_metadata_keys</code> <code>Optional[List[str]]</code> <p>extra metadata keys to add to the geodataframe. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[GeoDataFrame, Tuple[GeoDataFrame, ImageCollection]]</code> <p>Union[gpd.GeoDataFrame, Tuple[gpd.GeoDataFrame, ee.ImageCollection]]: geodataframe with available products in the given area and time range</p> Source code in <code>georeader/readers/ee_query.py</code> <pre><code>def query_landsat_457(area:Union[MultiPolygon,Polygon],\n                      date_start:datetime, date_end:datetime,\n                      producttype:str=\"all\",\n                      filter_duplicates:bool=True,\n                      return_collection:bool=False,\n                      extra_metadata_keys:Optional[List[str]]=None\n          )-&gt; Union[gpd.GeoDataFrame, Tuple[gpd.GeoDataFrame, ee.ImageCollection]]:\n    \"\"\"\n    Query Landsat-7, Landsat-5 or Landsat-4 products from the Google Earth Engine.\n\n    Args:\n        area (Union[MultiPolygon,Polygon]): area to query images in EPSG:4326\n        date_start (datetime): datetime in a given timezone. If tz not provided UTC will be assumed.\n        date_end (datetime): datetime in UTC. If tz not provided UTC will be assumed.\n        producttype (str, optional): 'all' -&gt; {\"L4\", \"L5\", \"L7\"}, \"L4\", \"L5\" or \"L7\". Defaults to \"all\".\n        filter_duplicates (bool, optional): filter duplicate images over the same area. Defaults to True.\n        return_collection (bool, optional): returns also the corresponding image collection. Defaults to False.\n        extra_metadata_keys (Optional[List[str]], optional): extra metadata keys to add to the geodataframe. Defaults to None.\n\n    Returns:\n        Union[gpd.GeoDataFrame, Tuple[gpd.GeoDataFrame, ee.ImageCollection]]: geodataframe with available products in the given area and time range\n    \"\"\"\n\n    pol = ee.Geometry(mapping(area))\n\n    if date_start.tzinfo is not None:\n        tz = date_start.tzinfo\n        if isinstance(tz, ZoneInfo):\n            tz = tz.key\n\n        date_start = date_start.astimezone(timezone.utc)\n        date_end = date_end.astimezone(timezone.utc)\n    else:\n        tz = timezone.utc\n\n    assert date_end &gt;= date_start, f\"Date end: {date_end} prior to date start: {date_start}\"\n\n    if extra_metadata_keys is None:\n        extra_metadata_keys = []\n\n    if producttype == \"all\" or producttype == \"L5\":\n        image_collection_name = \"LANDSAT/LT05/C02/T1_TOA\"\n    elif producttype == \"L4\":\n        image_collection_name = \"LANDSAT/LT04/C02/T1_TOA\"\n    elif producttype == \"L7\":\n        image_collection_name = \"LANDSAT/LE07/C02/T1_TOA\"\n    else:\n        raise NotImplementedError(f\"Unknown product type {producttype}\")\n\n    keys_query = {\"LANDSAT_PRODUCT_ID\": \"title\", 'CLOUD_COVER': \"cloudcoverpercentage\"}\n    img_col = ee.ImageCollection(image_collection_name).filterDate(date_start.replace(tzinfo=None),\n                                                                   date_end.replace(tzinfo=None)).filterBounds(\n        pol)\n    # Merge T2 collection\n    img_col_t2 = ee.ImageCollection(image_collection_name.replace(\"T1\", \"T2\")).filterDate(date_start.replace(tzinfo=None),\n                                                                   date_end.replace(tzinfo=None)).filterBounds(\n        pol)\n    img_col = img_col.merge(img_col_t2)\n\n    if producttype == \"all\":\n        img_col_l4 = ee.ImageCollection(\"LANDSAT/LT04/C02/T1_TOA\").filterDate(date_start.replace(tzinfo=None),\n                                                                   date_end.replace(tzinfo=None)).filterBounds(\n        pol)\n        img_col_l4_t2 = ee.ImageCollection(\"LANDSAT/LT04/C02/T2_TOA\").filterDate(date_start.replace(tzinfo=None),\n                                                                     date_end.replace(tzinfo=None)).filterBounds(\n            pol)\n        img_col_l4 = img_col_l4.merge(img_col_l4_t2)\n        img_col = img_col.merge(img_col_l4)\n\n        # Add L7 T1 and T2\n        img_col_l7 = ee.ImageCollection(\"LANDSAT/LE07/C02/T1_TOA\").filterDate(date_start.replace(tzinfo=None),\n                                                                   date_end.replace(tzinfo=None)).filterBounds(\n        pol)\n        img_col_l7_t2 = ee.ImageCollection(\"LANDSAT/LE07/C02/T2_TOA\").filterDate(date_start.replace(tzinfo=None),\n                                                                        date_end.replace(tzinfo=None)).filterBounds(\n                pol)\n        img_col_l7 = img_col_l7.merge(img_col_l7_t2)\n        img_col = img_col.merge(img_col_l7)\n\n    geodf = img_collection_to_feature_collection(img_col,\n                                                 [\"system:time_start\"] + list(keys_query.keys()) + extra_metadata_keys,\n                                                as_geopandas=True, band_crs=\"B2\")\n\n    geodf.rename(keys_query, axis=1, inplace=True)\n\n    if geodf.shape[0] == 0:\n        warnings.warn(f\"Not images found of collection {producttype} between dates {date_start} and {date_end}\")\n        if return_collection:\n            return geodf, img_col\n        return geodf\n\n    img_col = img_col.map(lambda x: _rename_add_properties(x, keys_query))\n    geodf[\"collection_name\"] = geodf.title.apply(lambda x: figure_out_collection_landsat(x))\n\n    geodf = _add_stuff(geodf, area, tz)\n\n    # Fix ids of Landsat to remove initial shit in the names\n    geodf[\"gee_id\"] = geodf[\"gee_id\"].apply(lambda x: \"L\"+x.split(\"L\")[1])\n\n    if filter_duplicates:\n        geodf = query_utils.filter_products_overlap(area, geodf,\n                                                    groupkey=[\"solarday\", \"satellite\"]).copy()\n        # filter img_col:\n        img_col = img_col.filter(ee.Filter.inList(\"title\", ee.List(geodf.index.tolist())))\n\n    geodf.sort_values(\"utcdatetime\")\n    img_col = img_col.sort(\"system:time_start\")\n\n    if return_collection:\n        return geodf, img_col\n\n    return geodf\n</code></pre>"},{"location":"modules/geotensor_module/","title":"GeoTensor","text":"<p>The <code>GeoTensor</code> class is a subclass of <code>np.ndarray</code> that stores the spatial affine transform, the coordinate reference system (<code>crs</code>) and no data value (called <code>fill_value_default</code>). When a <code>GeoTensor</code> is sliced, its <code>transform</code> attribute is shifted accordingly. Additionally its transform is also shifted if the <code>GeoTensor</code> is padded. <code>GeoTensor</code>s are restricted to be 2D, 3D or 4D arrays and their two last dimensions are assumed to be the <code>y</code> and <code>x</code> spatial axis.</p> <p><code>GeoTensor</code> implements the GeoData protocol. This makes it fully compatible with all <code>read_*</code> methods in the library, allowing for operations like reprojection, subseting from spatial coordinates, mosaicking or vectorization.</p> <p>For a detailed guide on working with the NumPy API in GeoTensors, see the GeoTensor NumPy API tutorial which covers slicing, operations, masking, and more practical examples.</p> <p>As a subclass of <code>np.ndarray</code>, operations with <code>GeoTensor</code> objects work similar than operations with <code>np.ndarray</code>s. However, there are some restrictions that we have implemented to keep consistency with the <code>GeoTensor</code> concept. If you need to use the <code>numpy</code> implementation you can access the bare <code>numpy</code> object with the <code>.values</code> attribute. Below there's a list with restrictions on <code>numpy</code> operations:</p> <ol> <li> <p>Slicing a <code>GeoTensor</code> is more restrictive than a <code>numpy</code> array. It only allows to slice with <code>lists</code>, numbers or <code>slice</code>s. In particular the spatial dimensions can only be sliced with <code>slice</code>s. Slicing for inplace modification is not restricted (i.e. you can slice with boolean arrays to modify certain values of the object). See isel and getitem methods.</p> </li> <li> <p>Binary operations (such as add add, multiply mul, ==, | etc) check, for <code>GeoTensor</code> inputs, if they have the same_extent; that is, same <code>transform</code> <code>crs</code> and spatial dimensions (<code>width</code> and <code>height</code>).</p> </li> <li> <p>squeeze, expand_dims and transpose make sure spatial dimensions (last two axes) are not modified and kept at the end of the array.</p> </li> <li> <p>concatenate and stack make sure all operated <code>GeoTensor</code>s have <code>same_extent</code> and <code>shape</code>. <code>concatenate</code> does not allow to concatenate on the spatial dims.</p> </li> <li> <p>Reductions (such as <code>np.mean</code> or <code>np.all</code>) return <code>GeoTensor</code> object if the spatial dimensions are preserved and <code>np.ndarray</code> or scalars otherwise. This is handled by the array_ufunc method.</p> </li> </ol>"},{"location":"modules/geotensor_module/#additional-features","title":"Additional Features","text":"<ul> <li>Masking utilities: Methods like validmask() and invalidmask() create boolean masks based on the <code>fill_value_default</code>.</li> <li>Window-based access: read_from_window() and write_from_window() provide window-based operations using rasterio's window system.</li> <li>File I/O: Class methods load_file() and load_bytes() for easily loading GeoTensors from files or memory.</li> <li>Footprint extraction: Methods to extract the valid data footprint as vector geometries (footprint() and valid_footprint()).</li> <li>Coordinate transformation: The meshgrid() method creates coordinate arrays for the spatial dimensions.</li> <li>Resizing: The resize() method changes the spatial resolution while maintaining geospatial information correct (i.e. changing the spatial resolution of the <code>transform</code>).</li> <li>Metadata storage: GeoTensor includes an <code>attrs</code> dictionary for storing additional metadata like tags and band descriptions.</li> </ul>"},{"location":"modules/geotensor_module/#api-reference","title":"API Reference","text":""},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor","title":"<code>GeoTensor</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>This class is a wrapper around a numpy tensor with geospatial information. It can store 2D, 3D or 4D tensors. The last two dimensions are the spatial dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Tensor</code> <p>numpy or torch tensor (2D, 3D or 4D).</p> required <code>transform</code> <code>Affine</code> <p>affine geospatial transform</p> required <code>crs</code> <code>Any</code> <p>coordinate reference system</p> required <code>fill_value_default</code> <code>Optional[Union[int, float]]</code> <p>Value to fill when reading out of bounds. Could be None. Defaults to 0.</p> required <p>Attributes:</p> Name Type Description <code>values</code> <code>NDArray</code> <p>numpy or torch tensor</p> <code>transform</code> <code>Affine</code> <p>affine geospatial transform</p> <code>crs</code> <code>Any</code> <p>coordinate reference system</p> <code>fill_value_default</code> <code>Optional[Union[int, float]]</code> <p>Value to fill when reading out of bounds. Could be None. Defaults to 0.</p> <code>shape</code> <code>Tuple</code> <p>shape of the tensor</p> <code>res</code> <code>Tuple[float, float]</code> <p>resolution of the tensor</p> <code>dtype</code> <p>data type of the tensor</p> <code>height</code> <code>int</code> <p>height of the tensor</p> <code>width</code> <code>int</code> <p>width of the tensor</p> <code>count</code> <code>int</code> <p>number of bands in the tensor</p> <code>bounds</code> <code>Tuple[float, float, float, float]</code> <p>bounds of the tensor</p> <code>dims</code> <code>Tuple[str]</code> <p>names of the dimensions</p> <code>attrs</code> <code>Dict[str, Any]</code> <p>dictionary with the attributes of the GeoTensor</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; transform = rasterio.Affine(1, 0, 0, 0, -1, 0)\n&gt;&gt;&gt; crs = \"EPSG:4326\"\n&gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n</code></pre> Source code in <code>georeader/geotensor.py</code> <pre><code>class GeoTensor(np.ndarray):\n    \"\"\"\n    This class is a wrapper around a numpy tensor with geospatial information.\n    It can store 2D, 3D or 4D tensors. The last two dimensions are the spatial dimensions.\n\n    Args:\n        values (Tensor): numpy or torch tensor (2D, 3D or 4D).\n        transform (rasterio.Affine): affine geospatial transform\n        crs (Any): coordinate reference system\n        fill_value_default (Optional[Union[int, float]], optional): Value to fill when\n            reading out of bounds. Could be None. Defaults to 0.\n\n    Attributes:\n        values (NDArray): numpy or torch tensor\n        transform (rasterio.Affine): affine geospatial transform\n        crs (Any): coordinate reference system\n        fill_value_default (Optional[Union[int, float]], optional): Value to fill when\n            reading out of bounds. Could be None. Defaults to 0.\n        shape (Tuple): shape of the tensor\n        res (Tuple[float, float]): resolution of the tensor\n        dtype: data type of the tensor\n        height (int): height of the tensor\n        width (int): width of the tensor\n        count (int): number of bands in the tensor\n        bounds (Tuple[float, float, float, float]): bounds of the tensor\n        dims (Tuple[str]): names of the dimensions\n        attrs (Dict[str, Any]): dictionary with the attributes of the GeoTensor\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; transform = rasterio.Affine(1, 0, 0, 0, -1, 0)\n        &gt;&gt;&gt; crs = \"EPSG:4326\"\n        &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n\n    \"\"\"\n\n    def __new__(\n        cls,\n        values: NDArray,\n        transform: rasterio.Affine,\n        crs: Any,\n        fill_value_default: Optional[Union[int, float]] = 0,\n        attrs: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"\n        This class is a wrapper around a numpy or torch tensor with geospatial information.\n\n        Args:\n            values (NDArray): numpy or torch tensor\n            transform (rasterio.Affine): affine geospatial transform\n            crs (Any): coordinate reference system\n            fill_value_default (Optional[Union[int, float]], optional): Value to fill when\n                reading out of bounds. Could be None. Defaults to 0.\n            attrs (Optional[Dict[str, Any]], optional): dictionary with the attributes of the GeoTensor\n                Defaults to None.\n\n        Raises:\n            ValueError: when the shape of the tensor is not 2d, 3d or 4d.\n        \"\"\"\n        obj = np.asarray(values).view(cls)\n\n        obj.transform = transform\n        obj.crs = crs\n        obj.fill_value_default = fill_value_default\n        shape = obj.shape\n        if (len(shape) &lt; 2) or (len(shape) &gt; 4):\n            raise ValueError(f\"Expected 2d-4d array found {shape}\")\n\n        obj.attrs = attrs if attrs is not None else {}\n\n        return obj\n\n    def __array_finalize__(self, obj: Optional[Union[np.ndarray, Self]]) -&gt; None:\n        \"\"\"\n        Initialize attributes when a new GeoTensor is created from an existing array.\n\n        This method is called whenever a new array object is created from an existing array\n        (e.g., through slicing, view casting, or copy operations).\n\n        Args:\n            obj (Optional[np.ndarray]): The array object from which the new array is created.\n                                       Can be None if the array is being created from scratch.\n        \"\"\"\n        if obj is None:\n            return\n\n        if hasattr(obj, \"transform\"):\n            self.transform: rasterio.Affine = getattr(obj, \"transform\", None)\n        if hasattr(obj, \"crs\"):\n            self.crs = getattr(obj, \"crs\", None)\n        if hasattr(obj, \"fill_value_default\"):\n            self.fill_value_default = getattr(obj, \"fill_value_default\", None)\n        if hasattr(obj, \"attrs\"):\n            self.attrs = getattr(obj, \"attrs\", None)\n\n    def  __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        \"\"\"\n        Handle NumPy universal functions applied to this GeoTensor.\n\n        This method is called when a NumPy universal function (ufunc) is applied to the GeoTensor.\n        It converts GeoTensor inputs to NumPy arrays, applies the ufunc, and converts array results\n        back to GeoTensor objects with the same geospatial metadata.\n\n        Args:\n            ufunc (np.ufunc): The NumPy universal function being applied\n            method (str): The method of the ufunc ('__call__', 'reduce', etc.)\n            *inputs: The input arrays to the ufunc\n            **kwargs: Additional keyword arguments to the ufunc\n\n        Returns:\n            Union[GeoTensor, NDArray]: If the result is an array, returns a new GeoTensor with the same\n                                  geospatial attributes. Otherwise, returns the original result.\n        \"\"\"\n        # Normal processing for most operations\n        inputs_arr = tuple(\n            x.view(np.ndarray) if isinstance(x, GeoTensor) else x for x in inputs\n        )\n        # Handle 'out' argument if present\n        out = kwargs.pop('out', None)\n        out_arrays = None\n\n        if out:\n            # Convert GeoTensor outputs to regular arrays\n            if isinstance(out, tuple):\n                out_arrays = tuple(\n                    o.view(np.ndarray) if isinstance(o, GeoTensor) else o \n                    for o in out\n                )\n            else:\n                out_arrays = (out.view(np.ndarray),) if isinstance(out, GeoTensor) else (out,)\n            kwargs['out'] = out_arrays\n\n        # Delegate to numpy's implementation\n        result = super().__array_ufunc__(ufunc, method, *inputs_arr, **kwargs)\n\n        cast_to_geotensor = self._preserved_spatial(method, **kwargs)\n\n        # Propagate metadata to output arrays\n        if out_arrays:\n            for o_orig, o_new in zip(out if isinstance(out, tuple) else [out], out_arrays):\n                if cast_to_geotensor and isinstance(o_orig, GeoTensor) and isinstance(o_new, np.ndarray):\n                    o_new = o_orig.array_as_geotensor(o_new)\n\n        # Normal ufunc processing for other cases\n        if cast_to_geotensor:\n            return self.array_as_geotensor(result)\n\n        return result\n\n    def _preserved_spatial(self, method:str,  **kwargs) -&gt; bool:\n        \"\"\"Special handling for reduction operations (sum, mean, max, etc.)\"\"\"\n        # Extract reduction axis (default is flattening)\n        if method != \"reduce\":\n            return True  # No reduction, preserve spatial dims\n\n        axis = kwargs.get(\"axis\", None)\n\n        # Check if reduction preserves spatial structure (last 2 dims untouched)\n        if axis is not None:\n            if isinstance(axis, int):\n                preserve_spatial = axis not in [-1, -2, self.ndim - 1, self.ndim - 2]\n            else:  # tuple of axes\n                preserve_spatial = all(\n                    ax not in [-1, -2, self.ndim - 1, self.ndim - 2] for ax in axis\n                )\n        else:\n            preserve_spatial = False  # Full reduction eliminates all dims\n\n        # For full reductions or spatial dim reductions, return plain array/scalar\n        return preserve_spatial\n\n    def array_as_geotensor(self, result: Union[np.ndarray, Self], \n                           fill_value_default:Optional[numbers.Number]=None) -&gt; Self:\n        \"\"\"\n        Convert a NumPy array result back to a GeoTensor.\n\n        Args:\n            result (Union[np.ndarray, Self]): Any NumPy array or GeoTensor.\n            fill_value_default: fill value for the returned GeoTensor.\n\n        Returns:\n            Self: A new GeoTensor with the same geospatial attributes as the original.\n        \"\"\"\n\n        # Propagate metadata for array results\n        if isinstance(result, np.ndarray):\n            if result.shape[-2:] != self.shape[-2:]:\n                raise ValueError(\"Operation altered spatial dimensions!\")\n\n            if fill_value_default is None:\n                fill_value_default = self.fill_value_default\n\n            result = GeoTensor(\n                result,\n                transform=self.transform,\n                crs=self.crs,\n                fill_value_default=fill_value_default,\n                attrs=self.attrs,\n            )\n\n        return result\n\n    def __array__(self, dtype: Optional[np.dtype] = None) -&gt; np.ndarray:\n        \"\"\"\n        Convert the GeoTensor to a standard NumPy array.\n\n        This method is called by np.asarray() and most NumPy functions to get\n        the underlying NumPy array representation of this object.\n\n        Args:\n            dtype (Optional[np.dtype]): The desired data type for the returned array.\n                                       If None, the array's current dtype is preserved.\n\n        Returns:\n            np.ndarray: A NumPy array view of this GeoTensor.\n        \"\"\"\n        return np.asarray(self.view(np.ndarray), dtype=dtype)\n\n    @property\n    def values(self):\n        \"\"\"Return a view of the array (memory shared with original)\"\"\"\n        return self.view(np.ndarray)\n\n    @property\n    def dims(self) -&gt; Tuple[str]:\n        # TODO allow different ordering of dimensions?\n        shape = self.shape\n        if len(shape) == 2:\n            dims = (\"y\", \"x\")\n        elif len(shape) == 3:\n            dims = (\"band\", \"y\", \"x\")\n        elif len(shape) == 4:\n            dims = (\"time\", \"band\", \"y\", \"x\")\n        else:\n            raise ValueError(f\"Unexpected 2d-4d array found {shape}\")\n\n        return dims\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        return {\n            \"values\": self.values.tolist(),\n            \"transform\": [\n                self.transform.a,\n                self.transform.b,\n                self.transform.c,\n                self.transform.d,\n                self.transform.e,\n                self.transform.f,\n            ],\n            \"crs\": str(self.crs),\n            \"fill_value_default\": self.fill_value_default,\n        }\n\n    @classmethod\n    def from_json(cls, json: Dict[str, Any]) -&gt; Self:\n        return cls(\n            np.array(json[\"values\"]),\n            rasterio.Affine(*json[\"transform\"]),\n            json[\"crs\"],\n            json[\"fill_value_default\"],\n        )\n\n    @property\n    def res(self) -&gt; Tuple[float, float]:\n        return window_utils.res(self.transform)\n\n    @property\n    def dtype(self):\n        return self.values.dtype\n\n    @property\n    def height(self) -&gt; int:\n        return self.shape[-2]\n\n    @property\n    def width(self) -&gt; int:\n        return self.shape[-1]\n\n    @property\n    def count(self) -&gt; int:\n        return self.shape[-3]\n\n    @property\n    def bounds(self) -&gt; Tuple[float, float, float, float]:\n        return window_bounds(\n            rasterio.windows.Window(\n                row_off=0, col_off=0, height=self.height, width=self.width\n            ),\n            self.transform,\n        )\n\n    def set_dtype(self, dtype):\n        self.values = self.values.astype(dtype=dtype)\n\n    # Not needed due to ufunc implementation?\n    # def astype(self, dtype) -&gt; Self:\n    #     return GeoTensor(\n    #         self.values.astype(dtype), self.transform, self.crs, self.fill_value_default\n    #     )\n\n    def meshgrid(self, dst_crs: Optional[Any] = None) -&gt; Tuple[NDArray, NDArray]:\n        \"\"\"\n        Create a meshgrid of spatial dimensions of the GeoTensor.\n\n        Args:\n            dst_crs (Optional[Any], optional): output coordinate reference system. Defaults to None.\n\n        Returns:\n            Tuple[NDArray, NDArray]: 2D arrays of xs and ys coordinates.\n        \"\"\"\n        from georeader import griddata\n\n        return griddata.meshgrid(\n            self.transform,\n            self.width,\n            self.height,\n            source_crs=self.crs,\n            dst_crs=dst_crs,\n        )\n\n    def load(self) -&gt; Self:\n        return self\n\n    def __copy__(self) -&gt; Self:\n        return GeoTensor(\n            self.values.copy(), self.transform, self.crs, self.fill_value_default\n        )\n\n    def copy(self) -&gt; Self:\n        return self.__copy__()\n\n    def same_extent(self, other: Self, precision: float = 1e-3) -&gt; bool:\n        \"\"\"\n        Check if two GeoTensors have the same georeferencing (crs, transform and spatial dimensions).\n\n        Args:\n            other (GeoTensor | GeoData): GeoTensor to compare with. Other GeoData object can be passed (it requires crs, transform and shape attributes)\n            precision (float, optional): precision to compare the transform. Defaults to 1e-3.\n\n        Returns:\n            bool: True if both GeoTensors have the same georeferencing.\n        \"\"\"\n        return (\n            self.transform.almost_equals(other.transform, precision=precision)\n            and window_utils.compare_crs(self.crs, other.crs)\n            and (self.shape[-2:] == other.shape[-2:])\n        )\n\n    def __add__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Add two GeoTensors. The georeferencing must match.\n\n        Args:\n            other (GeoTensor): GeoTensor to add.\n\n        Raises:\n            ValueError: if the georeferencing does not match.\n            TypeError: if other is not a GeoTensor.\n\n        Returns:\n            GeoTensor: GeoTensor with the result of the addition.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for addition. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values + other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def __sub__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Substract two GeoTensors. The georeferencing must match.\n\n        Args:\n            other (GeoTensor): GeoTensor to add.\n\n        Raises:\n            ValueError: if the georeferencing does not match.\n            TypeError: if other is not a GeoTensor.\n\n        Returns:\n            GeoTensor: GeoTensor with the result of the substraction.\n\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for substraction. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values - other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def __mul__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Multiply two GeoTensors. The georeferencing must match.\n\n        Args:\n            other (GeoTensor): GeoTensor to add.\n\n        Raises:\n            ValueError: if the georeferencing does not match.\n            TypeError: if other is not a GeoTensor.\n\n        Returns:\n            GeoTensor: GeoTensor with the result of the multiplication.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for multiplication. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values * other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def __truediv__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Divide two GeoTensors. The georeferencing must match.\n\n        Args:\n            other (GeoTensor): GeoTensor to add.\n\n        Raises:\n            ValueError: if the georeferencing does not match.\n            TypeError: if other is not a GeoTensor.\n\n        Returns:\n            GeoTensor: GeoTensor with the result of the division.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for division. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values / other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def __and__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Perform bitwise AND operation between two GeoTensors. The georeferencing must match.\n\n        Args:\n            other (Union[numbers.Number, NDArray, GeoTensor]): GeoTensor or array-like to AND with.\n\n        Raises:\n            ValueError: if the georeferencing does not match when other is a GeoTensor.\n\n        Returns:\n            GeoTensor: GeoTensor with the result of the bitwise AND operation.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for bitwise AND. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values &amp; other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def __or__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Perform bitwise OR operation between two GeoTensors. The georeferencing must match.\n\n        Args:\n            other (Union[numbers.Number, NDArray, GeoTensor]): GeoTensor or array-like to OR with.\n\n        Raises:\n            ValueError: if the georeferencing does not match when other is a GeoTensor.\n\n        Returns:\n            GeoTensor: GeoTensor with the result of the bitwise OR operation.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for bitwise OR. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values | other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def __eq__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Element-wise equality comparison between GeoTensors or with a scalar/array.\n        The georeferencing must match if comparing with another GeoTensor.\n\n        Args:\n            other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n        Raises:\n            ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n        Returns:\n            GeoTensor: GeoTensor with boolean values indicating equality.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for comparison. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values == other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=False,\n            attrs=self.attrs,\n        )\n\n    def __ne__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Element-wise inequality comparison between GeoTensors or with a scalar/array.\n        The georeferencing must match if comparing with another GeoTensor.\n\n        Args:\n            other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n        Raises:\n            ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n        Returns:\n            GeoTensor: GeoTensor with boolean values indicating inequality.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for comparison. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values != other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=False,\n            attrs=self.attrs,\n        )\n\n    def __lt__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Element-wise less than comparison between GeoTensors or with a scalar/array.\n        The georeferencing must match if comparing with another GeoTensor.\n\n        Args:\n            other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n        Raises:\n            ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n        Returns:\n            GeoTensor: GeoTensor with boolean values indicating less than relationship.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for comparison. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values &lt; other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=False,\n            attrs=self.attrs,\n        )\n\n    def __le__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Element-wise less than or equal comparison between GeoTensors or with a scalar/array.\n        The georeferencing must match if comparing with another GeoTensor.\n\n        Args:\n            other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n        Raises:\n            ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n        Returns:\n            GeoTensor: GeoTensor with boolean values indicating less than or equal relationship.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for comparison. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values &lt;= other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=False,\n            attrs=self.attrs,\n        )\n\n    def __gt__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Element-wise greater than comparison between GeoTensors or with a scalar/array.\n        The georeferencing must match if comparing with another GeoTensor.\n\n        Args:\n            other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n        Raises:\n            ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n        Returns:\n            GeoTensor: GeoTensor with boolean values indicating greater than relationship.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for comparison. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values &gt; other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=False,\n            attrs=self.attrs,\n        )\n\n    def __ge__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n        \"\"\"\n        Element-wise greater than or equal comparison between GeoTensors or with a scalar/array.\n        The georeferencing must match if comparing with another GeoTensor.\n\n        Args:\n            other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n        Raises:\n            ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n        Returns:\n            GeoTensor: GeoTensor with boolean values indicating greater than or equal relationship.\n        \"\"\"\n        if isinstance(other, GeoTensor):\n            if self.same_extent(other):\n                other = other.values\n            else:\n                raise ValueError(\n                    \"GeoTensor georref must match for comparison. \"\n                    \"Use `read.read_reproject_like(other, self)` to \"\n                    \"to reproject `other` to `self` georreferencing.\"\n                )\n\n        result_values = self.values &gt;= other\n\n        return GeoTensor(\n            result_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=False,\n            attrs=self.attrs,\n        )\n\n    def squeeze(self, axis=None) -&gt; Self:\n        \"\"\"\n        Remove single-dimensional entries from the shape of the GeoTensor values.\n        It does not squeeze the spatial dimensions (last two dimensions).\n\n        Returns:\n            GeoTensor: GeoTensor with the squeezed values.\n        \"\"\"\n        if axis is None:\n            axis = tuple(range(self.values.ndim - 2))\n        else:\n            if isinstance(axis, int):\n                axis = (axis,)\n            # Check if spatial dimesions will be squeezed\n            if self.width == 1:\n                if any(a in (-1, self.values.ndim - 1) for a in axis):\n                    raise ValueError(\n                        \"Cannot squeeze spatial dimensions. \"\n                        \"Use `squeeze(axis=0)` to squeeze the first dimension.\"\n                    )\n            elif self.height == 1:\n                if any(a in (-2, self.values.ndim - 2) for a in axis):\n                    raise ValueError(\n                        \"Cannot squeeze spatial dimensions. \"\n                        \"Use `squeeze(axis=0)` to squeeze the first dimension.\"\n                    )\n\n        # squeeze all but last two dimensions\n        squeezed_values = np.squeeze(self.values, axis=axis)\n\n        return GeoTensor(\n            squeezed_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def expand_dims(self, axis: Union[int, tuple]) -&gt; Self:\n        \"\"\"\n        Expand the dimensions of the GeoTensor values while preserving the spatial dimensions.\n\n        This method ensures that no dimensions are added after or in between the spatial dimensions\n        (which are always the last two dimensions).\n\n        Args:\n            axis (Union[int, tuple]): Position or positions where new axes should be inserted.\n                Must be less than the number of dimensions minus 2 (to preserve spatial dims).\n                Positions are counted from the first dimension.\n\n        Returns:\n            GeoTensor: GeoTensor with the expanded values.\n\n        Raises:\n            ValueError: If trying to add dimensions at or after the spatial dimensions.\n\n        Examples:\n            &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; # Add a new dimension at axis 0\n            &gt;&gt;&gt; gt_expanded = gt.expand_dims(0)\n            &gt;&gt;&gt; assert gt_expanded.shape == (1, 3, 100, 100)\n        \"\"\"\n        ndim = len(self.shape)\n\n        # Check if axis is valid (not interfering with spatial dimensions)\n        if isinstance(axis, int):\n            if axis &gt;= ndim - 2 or axis &lt; -ndim:\n                raise ValueError(\n                    f\"Cannot add dimension at or after spatial dimensions. \"\n                    f\"Axis must be &lt; {ndim - 2} or &gt;= {-ndim}, got {axis}\"\n                )\n            # Convert negative axis to positive\n            if axis &lt; 0:\n                axis = ndim + axis\n        else:  # tuple of axes\n            for ax in axis:\n                if ax &gt;= ndim - 2 or ax &lt; -ndim:\n                    raise ValueError(\n                        f\"Cannot add dimension at or after spatial dimensions. \"\n                        f\"All axes must be &lt; {ndim - 2} or &gt;= {-ndim}, got {ax}\"\n                    )\n\n        # Use numpy expand_dims to add the new dimensions\n        expanded_values = np.expand_dims(self.values, axis=axis)\n\n        return GeoTensor(\n            expanded_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def clip(self, a_min: Optional[np.array], a_max: Optional[np.array]) -&gt; Self:\n        \"\"\"\n        Clip the GeoTensor values between the GeoTensor min and max values.\n\n        Args:\n            a_min (float): Minimum value.\n            a_max (float): Maximum value.\n\n        Returns:\n            GeoTensor: GeoTensor with the clipped values.\n        \"\"\"\n        clipped_values = np.clip(self.values, a_min, a_max)\n        return GeoTensor(\n            clipped_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def __getitem__(self, key):\n        \"\"\"\n        Get the values of the GeoTensor using the given key.\n\n        Args:\n            key: Key to index the GeoTensor.\n\n        Returns:\n            GeoTensor: GeoTensor with the selected values.\n        \"\"\"\n        if not isinstance(key, tuple):\n            key = (key,)\n\n        sel_dict = {}\n        for i, k in enumerate(self.dims):\n            if i &lt; len(key):\n                if key[i] is None:\n                    raise NotImplementedError(f\"Adding axis is not permitted to GeoTensors. Use `expand_dims`\")\n                elif isinstance(key[i], type(...)):\n                    raise NotImplementedError(f\"Using elipsis is not permitted with GeoTensors. Use `values` attribute\")\n                sel_dict[k] = key[i]\n            else:\n                sel_dict[k] = slice(None)\n\n        return self.isel(sel_dict)\n\n    def isel(self, sel: Dict[str, Union[slice, list, int]]) -&gt; Self:\n        \"\"\"\n        Slicing with dict. Spatial dimensions can only be sliced with slices.\n\n        Args:\n            sel: Dict with slice selection; i.e. `{\"x\": slice(10, 20), \"y\": slice(20, 340)}`.\n\n        Returns:\n            GeoTensor: GeoTensor with the sliced values.\n\n        Examples:\n            &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; gt.isel({\"x\": slice(10, 20), \"y\": slice(20, 340)})\n        \"\"\"\n        for k in sel:\n            if k not in self.dims:\n                raise NotImplementedError(f\"Axis {k} not in {self.dims}\")\n\n        slice_tuple = self._slice_tuple(sel)\n\n        # Comp\u00f9te the window to shift the transform\n        slices_window = []\n        for k in [\"y\", \"x\"]:\n            if k in sel:\n                if not isinstance(sel[k], slice):\n                    raise NotImplementedError(\n                        f\"Only slice selection supported for x, y dims, found {sel[k]}\"\n                    )\n                slices_window.append(sel[k])\n            else:\n                size = self.width if (k == \"x\") else self.height\n                slices_window.append(slice(0, size))\n\n        window_current = rasterio.windows.Window.from_slices(\n            *slices_window, boundless=False, height=self.height, width=self.width\n        )\n\n        transform_current = rasterio.windows.transform(\n            window_current, transform=self.transform\n        )\n\n        return GeoTensor(\n            self.values[slice_tuple],\n            transform_current,\n            self.crs,\n            self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def _slice_tuple(self, sel: Dict[str, Union[slice, list, int]]) -&gt; tuple:\n        slice_list = []\n        for k in self.dims:\n            if k in sel:\n                slice_list.append(sel[k])\n            else:\n                slice_list.append(slice(None))\n        return tuple(slice_list)\n\n    def footprint(self, crs: Optional[str] = None) -&gt; Polygon:\n        \"\"\"Returns the footprint of the GeoTensor as a Polygon.\n\n        Args:\n            crs (Optional[str], optional): Coordinate reference system. Defaults to None.\n\n        Returns:\n            Polygon: footprint of the GeoTensor.\n\n        Examples:\n            &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; gt.footprint(crs=\"EPSG:4326\") # returns a Polygon in WGS84\n        \"\"\"\n        pol = window_utils.window_polygon(\n            rasterio.windows.Window(\n                row_off=0, col_off=0, height=self.shape[-2], width=self.shape[-1]\n            ),\n            self.transform,\n        )\n        if (crs is None) or window_utils.compare_crs(self.crs, crs):\n            return pol\n\n        return window_utils.polygon_to_crs(pol, self.crs, crs)\n\n    def valid_footprint(\n        self, crs: Optional[str] = None, method: str = \"all\"\n    ) -&gt; Union[MultiPolygon, Polygon]:\n        \"\"\"\n        vectorizes the valid values of the GeoTensor and returns the footprint as a Polygon.\n\n        Args:\n            crs (Optional[str], optional): Coordinate reference system. Defaults to None.\n            method (str, optional): \"all\" or \"any\" to aggregate the channels of the image. Defaults to \"all\".\n\n        Returns:\n            Polygon or MultiPolygon: footprint of the GeoTensor.\n        \"\"\"\n        valid_values = self.values != self.fill_value_default\n        if len(valid_values.shape) &gt; 2:\n            if method == \"all\":\n                valid_values = np.all(\n                    valid_values,\n                    axis=tuple(np.arange(0, len(valid_values.shape) - 2).tolist()),\n                )\n            elif method == \"any\":\n                valid_values = np.any(\n                    valid_values,\n                    axis=tuple(np.arange(0, len(valid_values.shape) - 2).tolist()),\n                )\n            else:\n                raise NotImplementedError(\n                    f\"Method {method} to aggregate channels not implemented\"\n                )\n\n        from georeader import vectorize\n\n        polygons = vectorize.get_polygons(valid_values, transform=self.transform)\n        if len(polygons) == 0:\n            raise ValueError(\"GeoTensor has no valid values\")\n        elif len(polygons) == 1:\n            pol = polygons[0]\n        else:\n            pol = MultiPolygon(polygons)\n        if crs is None:\n            return pol\n\n        return window_utils.polygon_to_crs(pol, self.crs, crs)\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\" \n         Transform: {self.transform}\n         Shape: {self.shape}\n         Resolution: {self.res}\n         Bounds: {self.bounds}\n         CRS: {self.crs}\n         fill_value_default: {self.fill_value_default}\n        \"\"\"\n\n    def pad(\n        self,\n        pad_width: Union[Dict[str, Tuple[int, int]], List[Tuple[int, int]]],\n        mode: str = \"constant\",\n        **kwargs,\n    ):\n        \"\"\"\n        Pad the GeoTensor.\n\n        Args:\n            pad_width (Union[Dict[str, Tuple[int, int]], List[Tuple[int, int]]]):\n                dictionary with Tuple to pad for each dimension\n                `{\"x\": (pad_x_0, pad_x_1), \"y\": (pad_y_0, pad_y_1)}` or list of tuples\n                `[(pad_x_0, pad_x_1), (pad_y_0, pad_y_1)]`.\n            mode (str, optional): pad mode (see np.pad or torch.nn.functional.pad). Defaults to \"constant\".\n            kwargs: additional arguments for the pad function.\n\n        Returns:\n            GeoTensor: padded GeoTensor.\n        \"\"\"\n        if isinstance(pad_width, list) or isinstance(pad_width, tuple):\n            if len(pad_width) != len(self.dims):\n                raise ValueError(\n                    f\"Expected {len(self.dims)} pad widths found {len(pad_width)}\"\n                )\n            pad_width_dict = {}\n            for i, k in enumerate(self.dims):\n                pad_width_dict[k] = pad_width[i]\n        else:\n            pad_width_dict = pad_width\n        return self.pad_array(pad_width_dict, mode=mode, **kwargs)\n\n    def pad_array(\n        self,\n        pad_width: Dict[str, Tuple[int, int]],\n        mode: str = \"constant\",\n        constant_values: Optional[Any] = None,\n    ) -&gt; Self:\n        \"\"\"\n        Pad the GeoTensor.\n\n        Args:\n            pad_width (_type_, optional):  dictionary with Tuple to pad for each dimension\n                `{\"x\": (pad_x_0, pad_x_1), \"y\": (pad_y_0, pad_y_1)}`.\n            mode (str, optional): pad mode (see np.pad or torch.nn.functional.pad). Defaults to \"constant\".\n            constant_values (Any, optional): _description_. Defaults to `self.fill_value_default`.\n\n        Returns:\n            GeoTensor: padded GeoTensor.\n\n        Examples:\n            &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; gt.pad_array({\"x\": (10, 10), \"y\": (10, 10)})\n            &gt;&gt;&gt; assert gt.shape == (3, 120, 120)\n        \"\"\"\n        if constant_values is None and mode == \"constant\":\n            if self.fill_value_default is None:\n                raise ValueError(f\"Mode constant either requires constant_values passed or fill_value_default not None in current GeoTensor\")\n            constant_values = self.fill_value_default\n\n        pad_list_np = []\n        for k in self.dims:\n            if k in pad_width:\n                pad_list_np.append(pad_width[k])\n            else:\n                pad_list_np.append((0, 0))\n\n        kwargs_extra = {}\n        if mode == \"constant\":\n            kwargs_extra[\"constant_values\"] = constant_values\n        values_new = np.pad(self.values, tuple(pad_list_np), mode=mode, **kwargs_extra)\n\n        # Compute the new transform\n        slices_window = []\n        for k in [\"y\", \"x\"]:\n            size = self.width if (k == \"x\") else self.height\n            if k in pad_width:\n                slices_window.append(slice(-pad_width[k][0], size + pad_width[k][1]))\n            else:\n                slices_window.append(slice(0, size))\n\n        window_current = rasterio.windows.Window.from_slices(\n            *slices_window, boundless=True\n        )\n        transform_current = rasterio.windows.transform(\n            window_current, transform=self.transform\n        )\n        return GeoTensor(\n            values_new,\n            transform_current,\n            self.crs,\n            self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def resize(\n        self,\n        output_shape: Optional[Tuple[int, int]] = None,\n        resolution_dst: Optional[Tuple[float, float]] = None,\n        anti_aliasing: bool = True,\n        anti_aliasing_sigma: Optional[Union[float, np.ndarray]] = None,\n        interpolation: Optional[str] = \"bilinear\",\n        mode_pad: str = \"constant\",\n    ) -&gt; Self:\n        \"\"\"\n        Resize the geotensor to match a certain size output_shape. This function works with GeoTensors of 2D, 3D and 4D.\n        The geoinformation of the output tensor is changed accordingly.\n\n        Args:\n            output_shape: output spatial shape if None resolution_dst must be provided. If not provided,\n                the output shape is computed from the resolution_dst rounding to the closest integer.\n            resolution_dst: output resolution if None output_shape must be provided.\n            anti_aliasing: Whether to apply a Gaussian filter to smooth the image prior to downsampling\n            anti_aliasing_sigma:  anti_aliasing_sigma : {float}, optional\n                Standard deviation for Gaussian filtering used when anti-aliasing.\n                By default, this value is chosen as (s - 1) / 2 where s is the\n                downsampling factor, where s &gt; 1\n            interpolation: Algorithm used for resizing: 'nearest' | 'bilinear' | 'bicubic'\n            mode_pad: mode pad for resize function\n\n        Returns:\n             resized GeoTensor\n\n        Examples:\n            &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; resized = gt.resize((50, 50))\n            &gt;&gt;&gt; assert resized.shape == (3, 50, 50)\n            &gt;&gt;&gt; assert resized.res == (2*gt.res[0], 2*gt.res[1])\n        \"\"\"\n        input_shape = self.shape\n        spatial_shape = input_shape[-2:]\n        resolution_or = self.res\n\n        if output_shape is None:\n            assert (\n                resolution_dst is not None\n            ), f\"Can't have output_shape and resolution_dst as None\"\n            output_shape = int(\n                round(spatial_shape[0] * resolution_or[0] / resolution_dst[0])\n            ), int(round(spatial_shape[1] * resolution_or[1] / resolution_dst[1]))\n        else:\n            assert (\n                resolution_dst is None\n            ), f\"Both output_shape and resolution_dst can't be provided\"\n            assert (\n                len(output_shape) == 2\n            ), f\"Expected output shape to be the spatial dimensions found: {output_shape}\"\n            resolution_dst = (\n                spatial_shape[0] * resolution_or[0] / output_shape[0],\n                spatial_shape[1] * resolution_or[1] / output_shape[1],\n            )\n\n        # Compute output transform\n        transform_scale = rasterio.Affine.scale(\n            resolution_dst[0] / resolution_or[0], resolution_dst[1] / resolution_or[1]\n        )\n        transform = self.transform * transform_scale\n\n        from skimage.transform import resize\n\n        # https://scikit-image.org/docs/stable/api/skimage.transform.html#skimage.transform.resize\n        output_tensor = np.ndarray(input_shape[:-2] + output_shape, dtype=self.dtype)\n        if len(input_shape) == 4:\n            for i, j in product(range(0, input_shape[0]), range(0, input_shape[1])):\n                if (\n                    (not anti_aliasing)\n                    or (anti_aliasing_sigma is None)\n                    or isinstance(anti_aliasing_sigma, numbers.Number)\n                ):\n                    anti_aliasing_sigma_iter = anti_aliasing_sigma\n                else:\n                    anti_aliasing_sigma_iter = anti_aliasing_sigma[i, j]\n                output_tensor[i, j] = resize(\n                    self.values[i, j],\n                    output_shape,\n                    order=ORDERS[interpolation],\n                    anti_aliasing=anti_aliasing,\n                    preserve_range=False,\n                    cval=self.fill_value_default,\n                    mode=mode_pad,\n                    anti_aliasing_sigma=anti_aliasing_sigma_iter,\n                )\n        elif len(input_shape) == 3:\n            for i in range(0, input_shape[0]):\n                if (\n                    (not anti_aliasing)\n                    or (anti_aliasing_sigma is None)\n                    or isinstance(anti_aliasing_sigma, numbers.Number)\n                ):\n                    anti_aliasing_sigma_iter = anti_aliasing_sigma\n                else:\n                    anti_aliasing_sigma_iter = anti_aliasing_sigma[i]\n                output_tensor[i] = resize(\n                    self.values[i],\n                    output_shape,\n                    order=ORDERS[interpolation],\n                    anti_aliasing=anti_aliasing,\n                    preserve_range=False,\n                    cval=self.fill_value_default,\n                    mode=mode_pad,\n                    anti_aliasing_sigma=anti_aliasing_sigma_iter,\n                )\n        else:\n            output_tensor[...] = resize(\n                self.values,\n                output_shape,\n                order=ORDERS[interpolation],\n                anti_aliasing=anti_aliasing,\n                preserve_range=False,\n                cval=self.fill_value_default,\n                mode=mode_pad,\n                anti_aliasing_sigma=anti_aliasing_sigma,\n            )\n\n        return GeoTensor(\n            output_tensor,\n            transform=transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def transpose(self, axes=None) -&gt; Self:\n        \"\"\"\n        Permute the dimensions of the GeoTensor while keeping the spatial dimensions at the end.\n\n        Args:\n            axes (tuple, optional): If specified, it must be a tuple or list of axes. The last two\n                values must be the original spatial dimensions indices (ndim-2, ndim-1).\n                If None, the non-spatial dimensions are reversed while spatial dimensions remain at the end.\n\n        Returns:\n            GeoTensor: A view of the array with dimensions transposed.\n\n        Raises:\n            ValueError: If the spatial dimensions are moved from their last positions.\n\n        Examples:\n            &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 4, 100, 200), transform, crs)\n            &gt;&gt;&gt; # Shape is (3, 4, 100, 200)\n            &gt;&gt;&gt; gt_t = gt.transpose()\n            &gt;&gt;&gt; # Shape is now (4, 3, 100, 200)\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; # You can also specify axes explicitly:\n            &gt;&gt;&gt; gt_t = gt.transpose((1, 0, 2, 3))  # Valid: spatial dims remain at end\n            &gt;&gt;&gt; # But this would raise an error:\n            &gt;&gt;&gt; # gt.transpose((0, 2, 1, 3))  # Invalid: spatial dims must stay at end\n        \"\"\"\n        ndim = len(self.shape)\n\n        if ndim &lt;= 2:\n            # Nothing meaningful to transpose for arrays with only spatial dimensions\n            return self.copy()\n\n        # Original spatial dimensions indices\n        y_dim = ndim - 2\n        x_dim = ndim - 1\n\n        if axes is None:\n            # Reverse all dimensions except the spatial ones which stay at the end\n            non_spatial_axes = list(range(ndim - 2))\n            non_spatial_axes.reverse()\n            axes = tuple(non_spatial_axes + [y_dim, x_dim])\n        else:\n            # Convert to tuple if necessary\n            axes = tuple(axes)\n\n            # Check if axes has the right length\n            if len(axes) != ndim:\n                raise ValueError(f\"axes should contain {ndim} dimensions, got {len(axes)}\")\n\n            # Check if the last two values in axes are the spatial dimensions\n            if axes[-2:] != (y_dim, x_dim):\n                raise ValueError(\n                    \"Cannot change the position of spatial dimensions. \"\n                    f\"The last two axes must be {y_dim} and {x_dim}.\"\n                )\n\n        # Perform the transpose\n        transposed_values = np.transpose(self.values, axes)\n\n        return GeoTensor(\n            transposed_values,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs,\n        )\n\n    def validmask(self) -&gt; Self:\n        \"\"\"\n        Returns a mask of the valid values of the GeoTensor. The mask is a boolean array\n        with the same shape as the GeoTensor values, where True indicates valid values and\n        False indicates invalid values.\n        The mask is created by comparing the values of the GeoTensor with the `self.fill_value_default`.\n\n        Returns:\n            Self: GeoTensor with the valid boolean mask.\n        \"\"\"\n        if self.fill_value_default is None:\n            return GeoTensor(\n                np.ones(self.shape, dtype=bool),\n                transform=self.transform,\n                crs=self.crs,\n                fill_value_default=self.fill_value_default,\n                attrs=self.attrs\n            )\n        return GeoTensor(\n            values=self.values != self.fill_value_default,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=False,\n            attrs=self.attrs\n        )\n\n    def invalidmask(self) -&gt; Self:\n        \"\"\"\n        Returns a mask of the invalid values of the GeoTensor. The mask is a boolean array\n        with the same shape as the GeoTensor values, where True indicates invalid values and\n        False indicates valid values.\n        The mask is created by comparing the values of the GeoTensor with the `self.fill_value_default`.\n\n        Returns:\n            Self: GeoTensor with the invalid boolean mask.\n        \"\"\"\n        if self.fill_value_default is None:\n            return GeoTensor(\n                np.zeros(self.shape, dtype=bool),\n                transform=self.transform,\n                crs=self.crs,\n                fill_value_default=self.fill_value_default,\n            )\n        return GeoTensor(\n            values=self.values == self.fill_value_default,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=False,\n            attrs=self.attrs\n        )\n\n    @classmethod\n    def load_file(\n        cls,\n        path: str,\n        fs: Optional[Any] = None,\n        load_tags: bool = False,\n        load_descriptions: bool = False,\n        rio_env_options: Optional[Dict[str, str]] = None,\n    ) -&gt; Self:\n        \"\"\"\n        Load a GeoTensor from a file. It uses rasterio to read the data. This function\n        loads all the data in memory. For a lazy loading reader use `georeader.rasterio_reader`.\n\n        Args:\n            path (str): Path to the file.\n            fs (Optional[Any], optional): fsspec.Filesystem object. Defaults to None.\n            load_descriptions (bool, optional): If True, load the description of the image. Defaults to False.\n            load_tags (bool, optional): If True, load the tags of the image. Defaults to False.\n            rio_env_options (Optional[Dict[str, str]], optional): Rasterio environment options. Defaults to None.\n\n        Returns:\n            GeoTensor: GeoTensor object with the loaded data.\n        \"\"\"\n\n        if fs is not None:\n            if load_descriptions:\n                raise NotImplementedError(\n                    \"\"\"Description loading not supported with `fsspec`. This is because\n            the `descriptions` attribute cannote be loaded from a byte stream. This is a limitation of `rasterio`.\n            The issue is related to how `rasterio.io.MemoryFile` handles band descriptions \n            compared to direct file access. This is a known limitation when working \n            with in-memory file representations in GDAL (which `rasterio` uses under \n            the hood). If you need to load descriptions, you can use `georeader.rasterio_reader`\n            class.\"\"\"\n                )\n\n            with fs.open(path, \"rb\") as fh:\n                return cls.load_bytes(\n                    fh.read(), load_tags=load_tags, rio_env_options=rio_env_options\n                )\n\n        tags = None\n        descriptions = None\n        rio_env_options = (\n            RIO_ENV_OPTIONS_DEFAULT if rio_env_options is None else rio_env_options\n        )\n        with rasterio.Env(**rio_env_options):\n            with rasterio.open(path) as src:\n                data = src.read()\n                transform = src.transform\n                crs = src.crs\n                fill_value_default = src.nodata\n                if load_tags:\n                    tags = src.tags()\n                if load_descriptions:\n                    descriptions = tuple(src.descriptions)\n\n        attrs = {}\n        if tags is not None:\n            attrs[\"tags\"] = tags\n\n        if descriptions is not None:\n            attrs[\"descriptions\"] = descriptions\n\n        return cls(\n            data, transform, crs, fill_value_default=fill_value_default, attrs=attrs\n        )\n\n    @classmethod\n    def load_bytes(\n        cls,\n        bytes_read: Union[bytes, bytearray, memoryview],\n        load_tags: bool = False,\n        rio_env_options: Optional[Dict[str, str]] = None,\n    ) -&gt; Self:\n        \"\"\"\n        Load a GeoTensor from a byte stream. It uses rasterio to read the data.\n\n\n        Args:\n            bytes_read (Union[bytes, bytearray, memoryview]): Byte stream to read.\n            load_tags (bool, optional): if True, load the tags of the image. Defaults to False.\n            rio_env_options (Optional[Dict[str, str]], optional): Rasterio environment options. Defaults to None.\n\n        Returns:\n            __class__: GeoTensor object with the loaded data.\n\n        Note:\n            The `descriptions` attribute cannote be loaded from a byte stream. This is a limitation of `rasterio`.\n            The issue is related to how `rasterio.io.MemoryFile` handles band descriptions\n            compared to direct file access. This is a known limitation when working\n            with in-memory file representations in GDAL (which `rasterio` uses under\n            the hood). If you need to load descriptions, you should use `georeader.rasterio_reader`\n            class.\n        \"\"\"\n        import rasterio.io\n\n        tags = None\n        rio_env_options = (\n            RIO_ENV_OPTIONS_DEFAULT if rio_env_options is None else rio_env_options\n        )\n        with rasterio.Env(**rio_env_options):\n            with rasterio.io.MemoryFile(bytes_read) as mem:\n                with mem.open() as src:\n                    data = src.read()\n                    transform = src.transform\n                    crs = src.crs\n                    fill_value_default = src.nodata\n                    if load_tags:\n                        tags = src.tags()\n\n        attrs = {}\n        if tags is not None:\n            attrs[\"tags\"] = tags\n\n        return cls(\n            data, transform, crs, fill_value_default=fill_value_default, attrs=attrs\n        )\n\n    def write_from_window(self, data: Tensor, window: rasterio.windows.Window):\n        \"\"\"\n        Writes array to GeoTensor values object at the given window position. If window surpasses the bounds of this\n        object it crops the data to fit the object.\n\n        Args:\n            data: Tensor to write. Expected: spatial dimensions `window.width`, `window.height`. Rest: same as `self`\n            window: Window object that specifies the spatial location to write the data\n\n        Examples:\n            &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; data = np.random.rand(3, 50, 50)\n            &gt;&gt;&gt; window = rasterio.windows.Window(col_off=7, row_off=9, width=50, height=50)\n            &gt;&gt;&gt; gt.write_from_window(data, window)\n\n        \"\"\"\n        window_data = rasterio.windows.Window(\n            col_off=0, row_off=0, width=self.width, height=self.height\n        )\n        if not rasterio.windows.intersect(window, window_data):\n            return\n\n        assert data.shape[-2:] == (\n            window.height,\n            window.width,\n        ), f\"window {window} has different shape than data {data.shape}\"\n        assert (\n            data.shape[:-2] == self.shape[:-2]\n        ), f\"Dimension of data in non-spatial channels found {data.shape} expected: {self.shape}\"\n\n        slice_dict, pad_width = window_utils.get_slice_pad(window_data, window)\n        slice_list = self._slice_tuple(slice_dict)\n        # need_pad = any(p != 0 for p in pad_width[\"x\"] + pad_width[\"y\"])\n\n        slice_data_spatial_x = slice(\n            pad_width[\"x\"][0], None if pad_width[\"x\"][1] == 0 else -pad_width[\"x\"][1]\n        )\n        slice_data_spatial_y = slice(\n            pad_width[\"y\"][0], None if pad_width[\"y\"][1] == 0 else -pad_width[\"y\"][1]\n        )\n        slice_data = self._slice_tuple(\n            {\"x\": slice_data_spatial_x, \"y\": slice_data_spatial_y}\n        )\n        self.values[slice_list] = data[slice_data]\n\n    def read_from_window(\n        self, window: rasterio.windows.Window, boundless: bool = True\n    ) -&gt; Self:\n        \"\"\"\n        returns a new GeoTensor object with the spatial dimensions sliced\n\n        Args:\n            window: window to slice the current GeoTensor\n            boundless: read from window in boundless mode (i.e. if the window is larger or negative it will pad\n                the GeoTensor with `self.fill_value_default`)\n\n        Raises:\n            rasterio.windows.WindowError: if `window` does not intersect the data\n\n        Returns:\n            GeoTensor object with the spatial dimensions sliced\n\n        \"\"\"\n\n        window_data = rasterio.windows.Window(\n            col_off=0, row_off=0, width=self.width, height=self.height\n        )\n        if boundless:\n            slice_dict, pad_width = window_utils.get_slice_pad(window_data, window)\n            need_pad = any(p != 0 for p in pad_width[\"x\"] + pad_width[\"y\"])\n            X_sliced = self.isel(slice_dict)\n            if need_pad:\n                X_sliced = X_sliced.pad(\n                    pad_width=pad_width,\n                    mode=\"constant\",\n                    constant_values=self.fill_value_default,\n                )\n            return X_sliced\n        else:\n            window_read = rasterio.windows.intersection(window, window_data)\n            slice_y, slice_x = window_read.toslices()\n            slice_dict = {\"x\": slice_x, \"y\": slice_y}\n            slices_ = self._slice_tuple(slice_dict)\n            transform_current = rasterio.windows.transform(\n                window_read, transform=self.transform\n            )\n            return GeoTensor(\n                self.values[slices_],\n                transform_current,\n                self.crs,\n                self.fill_value_default,\n                attrs=self.attrs,\n            )\n\n    @classmethod\n    def stack(cls, geotensors: List[Self]) -&gt; Self:\n        \"\"\"\n        Stacks a list of geotensors, assert that all of them has same shape, transform and crs.\n\n        Args:\n            geotensors: list of geotensors to concat. All with same shape, transform and crs.\n\n        Returns:\n            geotensor with extra dim at the front: (len(geotensors),) + shape\n\n        Examples:\n            &gt;&gt;&gt; gt1 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; gt2 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; gt3 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; gt = stack([gt1, gt2, gt3])\n            &gt;&gt;&gt; assert gt.shape == (3, 3, 100, 100)\n        \"\"\"\n        assert len(geotensors) &gt; 0, \"Empty list provided can't concat\"\n\n        if len(geotensors) == 1:\n            gt = geotensors[0].copy()\n            gt.values = gt.values[np.newaxis]\n            return gt\n\n        first_geotensor = geotensors[0]\n        array_out = np.zeros(\n            (len(geotensors),) + first_geotensor.shape, dtype=first_geotensor.dtype\n        )\n        array_out[0] = first_geotensor.values\n\n        for i, geo in enumerate(geotensors[1:]):\n            assert geo.same_extent(first_geotensor), f\"Different size in concat {i+1}\"\n            assert (\n                geo.shape == first_geotensor.shape\n            ), f\"Different shape in concat {i+1}\"\n            assert (\n                geo.fill_value_default == first_geotensor.fill_value_default\n            ), \"Different fill_value_default in concat\"\n            array_out[i + 1] = geo.values\n\n        return cls(\n            array_out,\n            transform=first_geotensor.transform,\n            crs=first_geotensor.crs,\n            fill_value_default=first_geotensor.fill_value_default,\n            attrs=first_geotensor.attrs,\n        )\n\n    @classmethod\n    def concatenate(cls, geotensors: List[Self], axis: int = 0) -&gt; Self:\n        \"\"\"\n        Concatenates a list of geotensors along a given axis, assert that all of them has same shape, transform and crs.\n\n        Args:\n            geotensors: list of geotensors to concat. All with same shape, transform and crs.\n            axis: axis to concatenate. Must be less than the number of dimensions of the geotensors minus 2.\n                default is 0.\n\n        Returns:\n            geotensor with extra dim at the front: (len(geotensors),) + shape\n\n        Examples:\n            &gt;&gt;&gt; gt1 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; gt2 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; gt3 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n            &gt;&gt;&gt; gt = concatenate([gt1, gt2, gt3], axis=0)\n            &gt;&gt;&gt; assert gt.shape == (9, 100, 100)\n        \"\"\"\n        assert len(geotensors) &gt; 0, \"Empty list provided can't concat\"\n\n        if len(geotensors) == 1:\n            return geotensors[0].copy()\n\n        first_geotensor = geotensors[0]\n\n        # Assert the axis is NOT an spatial axis\n        assert (\n            axis &lt; len(first_geotensor.shape) - 2\n        ), f\"Can't concatenate along spatial axis\"\n\n        for i, geo in enumerate(geotensors[1:]):\n            assert geo.same_extent(first_geotensor), f\"Different extent in concat {i+1}\"\n            assert (\n                geo.shape == first_geotensor.shape\n            ), f\"Different shape in concat {i+1}\"\n            assert (\n                geo.fill_value_default == first_geotensor.fill_value_default\n            ), \"Different fill_value_default in concat\"\n\n        array_out = np.concatenate([gt.values for gt in geotensors], axis=axis)\n\n        return cls(\n            array_out,\n            transform=first_geotensor.transform,\n            crs=first_geotensor.crs,\n            fill_value_default=first_geotensor.fill_value_default,\n            attrs=first_geotensor.attrs,\n        )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.values","title":"<code>values</code>  <code>property</code>","text":"<p>Return a view of the array (memory shared with original)</p>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__add__","title":"<code>__add__(other)</code>","text":"<p>Add two GeoTensors. The georeferencing must match.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>GeoTensor</code> <p>GeoTensor to add.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the georeferencing does not match.</p> <code>TypeError</code> <p>if other is not a GeoTensor.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with the result of the addition.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __add__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Add two GeoTensors. The georeferencing must match.\n\n    Args:\n        other (GeoTensor): GeoTensor to add.\n\n    Raises:\n        ValueError: if the georeferencing does not match.\n        TypeError: if other is not a GeoTensor.\n\n    Returns:\n        GeoTensor: GeoTensor with the result of the addition.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for addition. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values + other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__and__","title":"<code>__and__(other)</code>","text":"<p>Perform bitwise AND operation between two GeoTensors. The georeferencing must match.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[Number, NDArray, GeoTensor]</code> <p>GeoTensor or array-like to AND with.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the georeferencing does not match when other is a GeoTensor.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with the result of the bitwise AND operation.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __and__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Perform bitwise AND operation between two GeoTensors. The georeferencing must match.\n\n    Args:\n        other (Union[numbers.Number, NDArray, GeoTensor]): GeoTensor or array-like to AND with.\n\n    Raises:\n        ValueError: if the georeferencing does not match when other is a GeoTensor.\n\n    Returns:\n        GeoTensor: GeoTensor with the result of the bitwise AND operation.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for bitwise AND. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values &amp; other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Convert the GeoTensor to a standard NumPy array.</p> <p>This method is called by np.asarray() and most NumPy functions to get the underlying NumPy array representation of this object.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>Optional[dtype]</code> <p>The desired data type for the returned array.                        If None, the array's current dtype is preserved.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A NumPy array view of this GeoTensor.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __array__(self, dtype: Optional[np.dtype] = None) -&gt; np.ndarray:\n    \"\"\"\n    Convert the GeoTensor to a standard NumPy array.\n\n    This method is called by np.asarray() and most NumPy functions to get\n    the underlying NumPy array representation of this object.\n\n    Args:\n        dtype (Optional[np.dtype]): The desired data type for the returned array.\n                                   If None, the array's current dtype is preserved.\n\n    Returns:\n        np.ndarray: A NumPy array view of this GeoTensor.\n    \"\"\"\n    return np.asarray(self.view(np.ndarray), dtype=dtype)\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__array_finalize__","title":"<code>__array_finalize__(obj)</code>","text":"<p>Initialize attributes when a new GeoTensor is created from an existing array.</p> <p>This method is called whenever a new array object is created from an existing array (e.g., through slicing, view casting, or copy operations).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Optional[ndarray]</code> <p>The array object from which the new array is created.                        Can be None if the array is being created from scratch.</p> required Source code in <code>georeader/geotensor.py</code> <pre><code>def __array_finalize__(self, obj: Optional[Union[np.ndarray, Self]]) -&gt; None:\n    \"\"\"\n    Initialize attributes when a new GeoTensor is created from an existing array.\n\n    This method is called whenever a new array object is created from an existing array\n    (e.g., through slicing, view casting, or copy operations).\n\n    Args:\n        obj (Optional[np.ndarray]): The array object from which the new array is created.\n                                   Can be None if the array is being created from scratch.\n    \"\"\"\n    if obj is None:\n        return\n\n    if hasattr(obj, \"transform\"):\n        self.transform: rasterio.Affine = getattr(obj, \"transform\", None)\n    if hasattr(obj, \"crs\"):\n        self.crs = getattr(obj, \"crs\", None)\n    if hasattr(obj, \"fill_value_default\"):\n        self.fill_value_default = getattr(obj, \"fill_value_default\", None)\n    if hasattr(obj, \"attrs\"):\n        self.attrs = getattr(obj, \"attrs\", None)\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__array_ufunc__","title":"<code>__array_ufunc__(ufunc, method, *inputs, **kwargs)</code>","text":"<p>Handle NumPy universal functions applied to this GeoTensor.</p> <p>This method is called when a NumPy universal function (ufunc) is applied to the GeoTensor. It converts GeoTensor inputs to NumPy arrays, applies the ufunc, and converts array results back to GeoTensor objects with the same geospatial metadata.</p> <p>Parameters:</p> Name Type Description Default <code>ufunc</code> <code>ufunc</code> <p>The NumPy universal function being applied</p> required <code>method</code> <code>str</code> <p>The method of the ufunc ('call', 'reduce', etc.)</p> required <code>*inputs</code> <p>The input arrays to the ufunc</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to the ufunc</p> <code>{}</code> <p>Returns:</p> Type Description <p>Union[GeoTensor, NDArray]: If the result is an array, returns a new GeoTensor with the same                   geospatial attributes. Otherwise, returns the original result.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def  __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n    \"\"\"\n    Handle NumPy universal functions applied to this GeoTensor.\n\n    This method is called when a NumPy universal function (ufunc) is applied to the GeoTensor.\n    It converts GeoTensor inputs to NumPy arrays, applies the ufunc, and converts array results\n    back to GeoTensor objects with the same geospatial metadata.\n\n    Args:\n        ufunc (np.ufunc): The NumPy universal function being applied\n        method (str): The method of the ufunc ('__call__', 'reduce', etc.)\n        *inputs: The input arrays to the ufunc\n        **kwargs: Additional keyword arguments to the ufunc\n\n    Returns:\n        Union[GeoTensor, NDArray]: If the result is an array, returns a new GeoTensor with the same\n                              geospatial attributes. Otherwise, returns the original result.\n    \"\"\"\n    # Normal processing for most operations\n    inputs_arr = tuple(\n        x.view(np.ndarray) if isinstance(x, GeoTensor) else x for x in inputs\n    )\n    # Handle 'out' argument if present\n    out = kwargs.pop('out', None)\n    out_arrays = None\n\n    if out:\n        # Convert GeoTensor outputs to regular arrays\n        if isinstance(out, tuple):\n            out_arrays = tuple(\n                o.view(np.ndarray) if isinstance(o, GeoTensor) else o \n                for o in out\n            )\n        else:\n            out_arrays = (out.view(np.ndarray),) if isinstance(out, GeoTensor) else (out,)\n        kwargs['out'] = out_arrays\n\n    # Delegate to numpy's implementation\n    result = super().__array_ufunc__(ufunc, method, *inputs_arr, **kwargs)\n\n    cast_to_geotensor = self._preserved_spatial(method, **kwargs)\n\n    # Propagate metadata to output arrays\n    if out_arrays:\n        for o_orig, o_new in zip(out if isinstance(out, tuple) else [out], out_arrays):\n            if cast_to_geotensor and isinstance(o_orig, GeoTensor) and isinstance(o_new, np.ndarray):\n                o_new = o_orig.array_as_geotensor(o_new)\n\n    # Normal ufunc processing for other cases\n    if cast_to_geotensor:\n        return self.array_as_geotensor(result)\n\n    return result\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Element-wise equality comparison between GeoTensors or with a scalar/array. The georeferencing must match if comparing with another GeoTensor.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[Number, NDArray, GeoTensor]</code> <p>Value to compare with.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If comparing with a GeoTensor and the georeferencing doesn't match.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with boolean values indicating equality.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __eq__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Element-wise equality comparison between GeoTensors or with a scalar/array.\n    The georeferencing must match if comparing with another GeoTensor.\n\n    Args:\n        other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n    Raises:\n        ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n    Returns:\n        GeoTensor: GeoTensor with boolean values indicating equality.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for comparison. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values == other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=False,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Element-wise greater than or equal comparison between GeoTensors or with a scalar/array. The georeferencing must match if comparing with another GeoTensor.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[Number, NDArray, GeoTensor]</code> <p>Value to compare with.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If comparing with a GeoTensor and the georeferencing doesn't match.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with boolean values indicating greater than or equal relationship.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __ge__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Element-wise greater than or equal comparison between GeoTensors or with a scalar/array.\n    The georeferencing must match if comparing with another GeoTensor.\n\n    Args:\n        other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n    Raises:\n        ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n    Returns:\n        GeoTensor: GeoTensor with boolean values indicating greater than or equal relationship.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for comparison. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values &gt;= other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=False,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get the values of the GeoTensor using the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>Key to index the GeoTensor.</p> required <p>Returns:</p> Name Type Description <code>GeoTensor</code> <p>GeoTensor with the selected values.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"\n    Get the values of the GeoTensor using the given key.\n\n    Args:\n        key: Key to index the GeoTensor.\n\n    Returns:\n        GeoTensor: GeoTensor with the selected values.\n    \"\"\"\n    if not isinstance(key, tuple):\n        key = (key,)\n\n    sel_dict = {}\n    for i, k in enumerate(self.dims):\n        if i &lt; len(key):\n            if key[i] is None:\n                raise NotImplementedError(f\"Adding axis is not permitted to GeoTensors. Use `expand_dims`\")\n            elif isinstance(key[i], type(...)):\n                raise NotImplementedError(f\"Using elipsis is not permitted with GeoTensors. Use `values` attribute\")\n            sel_dict[k] = key[i]\n        else:\n            sel_dict[k] = slice(None)\n\n    return self.isel(sel_dict)\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Element-wise greater than comparison between GeoTensors or with a scalar/array. The georeferencing must match if comparing with another GeoTensor.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[Number, NDArray, GeoTensor]</code> <p>Value to compare with.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If comparing with a GeoTensor and the georeferencing doesn't match.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with boolean values indicating greater than relationship.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __gt__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Element-wise greater than comparison between GeoTensors or with a scalar/array.\n    The georeferencing must match if comparing with another GeoTensor.\n\n    Args:\n        other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n    Raises:\n        ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n    Returns:\n        GeoTensor: GeoTensor with boolean values indicating greater than relationship.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for comparison. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values &gt; other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=False,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__le__","title":"<code>__le__(other)</code>","text":"<p>Element-wise less than or equal comparison between GeoTensors or with a scalar/array. The georeferencing must match if comparing with another GeoTensor.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[Number, NDArray, GeoTensor]</code> <p>Value to compare with.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If comparing with a GeoTensor and the georeferencing doesn't match.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with boolean values indicating less than or equal relationship.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __le__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Element-wise less than or equal comparison between GeoTensors or with a scalar/array.\n    The georeferencing must match if comparing with another GeoTensor.\n\n    Args:\n        other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n    Raises:\n        ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n    Returns:\n        GeoTensor: GeoTensor with boolean values indicating less than or equal relationship.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for comparison. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values &lt;= other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=False,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Element-wise less than comparison between GeoTensors or with a scalar/array. The georeferencing must match if comparing with another GeoTensor.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[Number, NDArray, GeoTensor]</code> <p>Value to compare with.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If comparing with a GeoTensor and the georeferencing doesn't match.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with boolean values indicating less than relationship.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __lt__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Element-wise less than comparison between GeoTensors or with a scalar/array.\n    The georeferencing must match if comparing with another GeoTensor.\n\n    Args:\n        other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n    Raises:\n        ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n    Returns:\n        GeoTensor: GeoTensor with boolean values indicating less than relationship.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for comparison. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values &lt; other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=False,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiply two GeoTensors. The georeferencing must match.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>GeoTensor</code> <p>GeoTensor to add.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the georeferencing does not match.</p> <code>TypeError</code> <p>if other is not a GeoTensor.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with the result of the multiplication.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __mul__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Multiply two GeoTensors. The georeferencing must match.\n\n    Args:\n        other (GeoTensor): GeoTensor to add.\n\n    Raises:\n        ValueError: if the georeferencing does not match.\n        TypeError: if other is not a GeoTensor.\n\n    Returns:\n        GeoTensor: GeoTensor with the result of the multiplication.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for multiplication. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values * other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Element-wise inequality comparison between GeoTensors or with a scalar/array. The georeferencing must match if comparing with another GeoTensor.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[Number, NDArray, GeoTensor]</code> <p>Value to compare with.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If comparing with a GeoTensor and the georeferencing doesn't match.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with boolean values indicating inequality.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __ne__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Element-wise inequality comparison between GeoTensors or with a scalar/array.\n    The georeferencing must match if comparing with another GeoTensor.\n\n    Args:\n        other (Union[numbers.Number, NDArray, GeoTensor]): Value to compare with.\n\n    Raises:\n        ValueError: If comparing with a GeoTensor and the georeferencing doesn't match.\n\n    Returns:\n        GeoTensor: GeoTensor with boolean values indicating inequality.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for comparison. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values != other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=False,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__new__","title":"<code>__new__(values, transform, crs, fill_value_default=0, attrs=None)</code>","text":"<p>This class is a wrapper around a numpy or torch tensor with geospatial information.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>NDArray</code> <p>numpy or torch tensor</p> required <code>transform</code> <code>Affine</code> <p>affine geospatial transform</p> required <code>crs</code> <code>Any</code> <p>coordinate reference system</p> required <code>fill_value_default</code> <code>Optional[Union[int, float]]</code> <p>Value to fill when reading out of bounds. Could be None. Defaults to 0.</p> <code>0</code> <code>attrs</code> <code>Optional[Dict[str, Any]]</code> <p>dictionary with the attributes of the GeoTensor Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the shape of the tensor is not 2d, 3d or 4d.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __new__(\n    cls,\n    values: NDArray,\n    transform: rasterio.Affine,\n    crs: Any,\n    fill_value_default: Optional[Union[int, float]] = 0,\n    attrs: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"\n    This class is a wrapper around a numpy or torch tensor with geospatial information.\n\n    Args:\n        values (NDArray): numpy or torch tensor\n        transform (rasterio.Affine): affine geospatial transform\n        crs (Any): coordinate reference system\n        fill_value_default (Optional[Union[int, float]], optional): Value to fill when\n            reading out of bounds. Could be None. Defaults to 0.\n        attrs (Optional[Dict[str, Any]], optional): dictionary with the attributes of the GeoTensor\n            Defaults to None.\n\n    Raises:\n        ValueError: when the shape of the tensor is not 2d, 3d or 4d.\n    \"\"\"\n    obj = np.asarray(values).view(cls)\n\n    obj.transform = transform\n    obj.crs = crs\n    obj.fill_value_default = fill_value_default\n    shape = obj.shape\n    if (len(shape) &lt; 2) or (len(shape) &gt; 4):\n        raise ValueError(f\"Expected 2d-4d array found {shape}\")\n\n    obj.attrs = attrs if attrs is not None else {}\n\n    return obj\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__or__","title":"<code>__or__(other)</code>","text":"<p>Perform bitwise OR operation between two GeoTensors. The georeferencing must match.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[Number, NDArray, GeoTensor]</code> <p>GeoTensor or array-like to OR with.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the georeferencing does not match when other is a GeoTensor.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with the result of the bitwise OR operation.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __or__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Perform bitwise OR operation between two GeoTensors. The georeferencing must match.\n\n    Args:\n        other (Union[numbers.Number, NDArray, GeoTensor]): GeoTensor or array-like to OR with.\n\n    Raises:\n        ValueError: if the georeferencing does not match when other is a GeoTensor.\n\n    Returns:\n        GeoTensor: GeoTensor with the result of the bitwise OR operation.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for bitwise OR. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values | other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Substract two GeoTensors. The georeferencing must match.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>GeoTensor</code> <p>GeoTensor to add.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the georeferencing does not match.</p> <code>TypeError</code> <p>if other is not a GeoTensor.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with the result of the substraction.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __sub__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Substract two GeoTensors. The georeferencing must match.\n\n    Args:\n        other (GeoTensor): GeoTensor to add.\n\n    Raises:\n        ValueError: if the georeferencing does not match.\n        TypeError: if other is not a GeoTensor.\n\n    Returns:\n        GeoTensor: GeoTensor with the result of the substraction.\n\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for substraction. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values - other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Divide two GeoTensors. The georeferencing must match.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>GeoTensor</code> <p>GeoTensor to add.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the georeferencing does not match.</p> <code>TypeError</code> <p>if other is not a GeoTensor.</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with the result of the division.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def __truediv__(self, other: Union[numbers.Number, NDArray, Self]) -&gt; Self:\n    \"\"\"\n    Divide two GeoTensors. The georeferencing must match.\n\n    Args:\n        other (GeoTensor): GeoTensor to add.\n\n    Raises:\n        ValueError: if the georeferencing does not match.\n        TypeError: if other is not a GeoTensor.\n\n    Returns:\n        GeoTensor: GeoTensor with the result of the division.\n    \"\"\"\n    if isinstance(other, GeoTensor):\n        if self.same_extent(other):\n            other = other.values\n        else:\n            raise ValueError(\n                \"GeoTensor georref must match for division. \"\n                \"Use `read.read_reproject_like(other, self)` to \"\n                \"to reproject `other` to `self` georreferencing.\"\n            )\n\n    result_values = self.values / other\n\n    return GeoTensor(\n        result_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.array_as_geotensor","title":"<code>array_as_geotensor(result, fill_value_default=None)</code>","text":"<p>Convert a NumPy array result back to a GeoTensor.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Union[ndarray, Self]</code> <p>Any NumPy array or GeoTensor.</p> required <code>fill_value_default</code> <code>Optional[Number]</code> <p>fill value for the returned GeoTensor.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new GeoTensor with the same geospatial attributes as the original.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def array_as_geotensor(self, result: Union[np.ndarray, Self], \n                       fill_value_default:Optional[numbers.Number]=None) -&gt; Self:\n    \"\"\"\n    Convert a NumPy array result back to a GeoTensor.\n\n    Args:\n        result (Union[np.ndarray, Self]): Any NumPy array or GeoTensor.\n        fill_value_default: fill value for the returned GeoTensor.\n\n    Returns:\n        Self: A new GeoTensor with the same geospatial attributes as the original.\n    \"\"\"\n\n    # Propagate metadata for array results\n    if isinstance(result, np.ndarray):\n        if result.shape[-2:] != self.shape[-2:]:\n            raise ValueError(\"Operation altered spatial dimensions!\")\n\n        if fill_value_default is None:\n            fill_value_default = self.fill_value_default\n\n        result = GeoTensor(\n            result,\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=fill_value_default,\n            attrs=self.attrs,\n        )\n\n    return result\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.clip","title":"<code>clip(a_min, a_max)</code>","text":"<p>Clip the GeoTensor values between the GeoTensor min and max values.</p> <p>Parameters:</p> Name Type Description Default <code>a_min</code> <code>float</code> <p>Minimum value.</p> required <code>a_max</code> <code>float</code> <p>Maximum value.</p> required <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with the clipped values.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def clip(self, a_min: Optional[np.array], a_max: Optional[np.array]) -&gt; Self:\n    \"\"\"\n    Clip the GeoTensor values between the GeoTensor min and max values.\n\n    Args:\n        a_min (float): Minimum value.\n        a_max (float): Maximum value.\n\n    Returns:\n        GeoTensor: GeoTensor with the clipped values.\n    \"\"\"\n    clipped_values = np.clip(self.values, a_min, a_max)\n    return GeoTensor(\n        clipped_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.concatenate","title":"<code>concatenate(geotensors, axis=0)</code>  <code>classmethod</code>","text":"<p>Concatenates a list of geotensors along a given axis, assert that all of them has same shape, transform and crs.</p> <p>Parameters:</p> Name Type Description Default <code>geotensors</code> <code>List[Self]</code> <p>list of geotensors to concat. All with same shape, transform and crs.</p> required <code>axis</code> <code>int</code> <p>axis to concatenate. Must be less than the number of dimensions of the geotensors minus 2. default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Self</code> <p>geotensor with extra dim at the front: (len(geotensors),) + shape</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gt1 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; gt2 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; gt3 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; gt = concatenate([gt1, gt2, gt3], axis=0)\n&gt;&gt;&gt; assert gt.shape == (9, 100, 100)\n</code></pre> Source code in <code>georeader/geotensor.py</code> <pre><code>@classmethod\ndef concatenate(cls, geotensors: List[Self], axis: int = 0) -&gt; Self:\n    \"\"\"\n    Concatenates a list of geotensors along a given axis, assert that all of them has same shape, transform and crs.\n\n    Args:\n        geotensors: list of geotensors to concat. All with same shape, transform and crs.\n        axis: axis to concatenate. Must be less than the number of dimensions of the geotensors minus 2.\n            default is 0.\n\n    Returns:\n        geotensor with extra dim at the front: (len(geotensors),) + shape\n\n    Examples:\n        &gt;&gt;&gt; gt1 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; gt2 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; gt3 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; gt = concatenate([gt1, gt2, gt3], axis=0)\n        &gt;&gt;&gt; assert gt.shape == (9, 100, 100)\n    \"\"\"\n    assert len(geotensors) &gt; 0, \"Empty list provided can't concat\"\n\n    if len(geotensors) == 1:\n        return geotensors[0].copy()\n\n    first_geotensor = geotensors[0]\n\n    # Assert the axis is NOT an spatial axis\n    assert (\n        axis &lt; len(first_geotensor.shape) - 2\n    ), f\"Can't concatenate along spatial axis\"\n\n    for i, geo in enumerate(geotensors[1:]):\n        assert geo.same_extent(first_geotensor), f\"Different extent in concat {i+1}\"\n        assert (\n            geo.shape == first_geotensor.shape\n        ), f\"Different shape in concat {i+1}\"\n        assert (\n            geo.fill_value_default == first_geotensor.fill_value_default\n        ), \"Different fill_value_default in concat\"\n\n    array_out = np.concatenate([gt.values for gt in geotensors], axis=axis)\n\n    return cls(\n        array_out,\n        transform=first_geotensor.transform,\n        crs=first_geotensor.crs,\n        fill_value_default=first_geotensor.fill_value_default,\n        attrs=first_geotensor.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.expand_dims","title":"<code>expand_dims(axis)</code>","text":"<p>Expand the dimensions of the GeoTensor values while preserving the spatial dimensions.</p> <p>This method ensures that no dimensions are added after or in between the spatial dimensions (which are always the last two dimensions).</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>Union[int, tuple]</code> <p>Position or positions where new axes should be inserted. Must be less than the number of dimensions minus 2 (to preserve spatial dims). Positions are counted from the first dimension.</p> required <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with the expanded values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If trying to add dimensions at or after the spatial dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; # Add a new dimension at axis 0\n&gt;&gt;&gt; gt_expanded = gt.expand_dims(0)\n&gt;&gt;&gt; assert gt_expanded.shape == (1, 3, 100, 100)\n</code></pre> Source code in <code>georeader/geotensor.py</code> <pre><code>def expand_dims(self, axis: Union[int, tuple]) -&gt; Self:\n    \"\"\"\n    Expand the dimensions of the GeoTensor values while preserving the spatial dimensions.\n\n    This method ensures that no dimensions are added after or in between the spatial dimensions\n    (which are always the last two dimensions).\n\n    Args:\n        axis (Union[int, tuple]): Position or positions where new axes should be inserted.\n            Must be less than the number of dimensions minus 2 (to preserve spatial dims).\n            Positions are counted from the first dimension.\n\n    Returns:\n        GeoTensor: GeoTensor with the expanded values.\n\n    Raises:\n        ValueError: If trying to add dimensions at or after the spatial dimensions.\n\n    Examples:\n        &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; # Add a new dimension at axis 0\n        &gt;&gt;&gt; gt_expanded = gt.expand_dims(0)\n        &gt;&gt;&gt; assert gt_expanded.shape == (1, 3, 100, 100)\n    \"\"\"\n    ndim = len(self.shape)\n\n    # Check if axis is valid (not interfering with spatial dimensions)\n    if isinstance(axis, int):\n        if axis &gt;= ndim - 2 or axis &lt; -ndim:\n            raise ValueError(\n                f\"Cannot add dimension at or after spatial dimensions. \"\n                f\"Axis must be &lt; {ndim - 2} or &gt;= {-ndim}, got {axis}\"\n            )\n        # Convert negative axis to positive\n        if axis &lt; 0:\n            axis = ndim + axis\n    else:  # tuple of axes\n        for ax in axis:\n            if ax &gt;= ndim - 2 or ax &lt; -ndim:\n                raise ValueError(\n                    f\"Cannot add dimension at or after spatial dimensions. \"\n                    f\"All axes must be &lt; {ndim - 2} or &gt;= {-ndim}, got {ax}\"\n                )\n\n    # Use numpy expand_dims to add the new dimensions\n    expanded_values = np.expand_dims(self.values, axis=axis)\n\n    return GeoTensor(\n        expanded_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.footprint","title":"<code>footprint(crs=None)</code>","text":"<p>Returns the footprint of the GeoTensor as a Polygon.</p> <p>Parameters:</p> Name Type Description Default <code>crs</code> <code>Optional[str]</code> <p>Coordinate reference system. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Polygon</code> <code>Polygon</code> <p>footprint of the GeoTensor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; gt.footprint(crs=\"EPSG:4326\") # returns a Polygon in WGS84\n</code></pre> Source code in <code>georeader/geotensor.py</code> <pre><code>def footprint(self, crs: Optional[str] = None) -&gt; Polygon:\n    \"\"\"Returns the footprint of the GeoTensor as a Polygon.\n\n    Args:\n        crs (Optional[str], optional): Coordinate reference system. Defaults to None.\n\n    Returns:\n        Polygon: footprint of the GeoTensor.\n\n    Examples:\n        &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; gt.footprint(crs=\"EPSG:4326\") # returns a Polygon in WGS84\n    \"\"\"\n    pol = window_utils.window_polygon(\n        rasterio.windows.Window(\n            row_off=0, col_off=0, height=self.shape[-2], width=self.shape[-1]\n        ),\n        self.transform,\n    )\n    if (crs is None) or window_utils.compare_crs(self.crs, crs):\n        return pol\n\n    return window_utils.polygon_to_crs(pol, self.crs, crs)\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.invalidmask","title":"<code>invalidmask()</code>","text":"<p>Returns a mask of the invalid values of the GeoTensor. The mask is a boolean array with the same shape as the GeoTensor values, where True indicates invalid values and False indicates valid values. The mask is created by comparing the values of the GeoTensor with the <code>self.fill_value_default</code>.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>GeoTensor with the invalid boolean mask.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def invalidmask(self) -&gt; Self:\n    \"\"\"\n    Returns a mask of the invalid values of the GeoTensor. The mask is a boolean array\n    with the same shape as the GeoTensor values, where True indicates invalid values and\n    False indicates valid values.\n    The mask is created by comparing the values of the GeoTensor with the `self.fill_value_default`.\n\n    Returns:\n        Self: GeoTensor with the invalid boolean mask.\n    \"\"\"\n    if self.fill_value_default is None:\n        return GeoTensor(\n            np.zeros(self.shape, dtype=bool),\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n        )\n    return GeoTensor(\n        values=self.values == self.fill_value_default,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=False,\n        attrs=self.attrs\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.isel","title":"<code>isel(sel)</code>","text":"<p>Slicing with dict. Spatial dimensions can only be sliced with slices.</p> <p>Parameters:</p> Name Type Description Default <code>sel</code> <code>Dict[str, Union[slice, list, int]]</code> <p>Dict with slice selection; i.e. <code>{\"x\": slice(10, 20), \"y\": slice(20, 340)}</code>.</p> required <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with the sliced values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; gt.isel({\"x\": slice(10, 20), \"y\": slice(20, 340)})\n</code></pre> Source code in <code>georeader/geotensor.py</code> <pre><code>def isel(self, sel: Dict[str, Union[slice, list, int]]) -&gt; Self:\n    \"\"\"\n    Slicing with dict. Spatial dimensions can only be sliced with slices.\n\n    Args:\n        sel: Dict with slice selection; i.e. `{\"x\": slice(10, 20), \"y\": slice(20, 340)}`.\n\n    Returns:\n        GeoTensor: GeoTensor with the sliced values.\n\n    Examples:\n        &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; gt.isel({\"x\": slice(10, 20), \"y\": slice(20, 340)})\n    \"\"\"\n    for k in sel:\n        if k not in self.dims:\n            raise NotImplementedError(f\"Axis {k} not in {self.dims}\")\n\n    slice_tuple = self._slice_tuple(sel)\n\n    # Comp\u00f9te the window to shift the transform\n    slices_window = []\n    for k in [\"y\", \"x\"]:\n        if k in sel:\n            if not isinstance(sel[k], slice):\n                raise NotImplementedError(\n                    f\"Only slice selection supported for x, y dims, found {sel[k]}\"\n                )\n            slices_window.append(sel[k])\n        else:\n            size = self.width if (k == \"x\") else self.height\n            slices_window.append(slice(0, size))\n\n    window_current = rasterio.windows.Window.from_slices(\n        *slices_window, boundless=False, height=self.height, width=self.width\n    )\n\n    transform_current = rasterio.windows.transform(\n        window_current, transform=self.transform\n    )\n\n    return GeoTensor(\n        self.values[slice_tuple],\n        transform_current,\n        self.crs,\n        self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.load_bytes","title":"<code>load_bytes(bytes_read, load_tags=False, rio_env_options=None)</code>  <code>classmethod</code>","text":"<p>Load a GeoTensor from a byte stream. It uses rasterio to read the data.</p> <p>Parameters:</p> Name Type Description Default <code>bytes_read</code> <code>Union[bytes, bytearray, memoryview]</code> <p>Byte stream to read.</p> required <code>load_tags</code> <code>bool</code> <p>if True, load the tags of the image. Defaults to False.</p> <code>False</code> <code>rio_env_options</code> <code>Optional[Dict[str, str]]</code> <p>Rasterio environment options. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>__class__</code> <code>Self</code> <p>GeoTensor object with the loaded data.</p> Note <p>The <code>descriptions</code> attribute cannote be loaded from a byte stream. This is a limitation of <code>rasterio</code>. The issue is related to how <code>rasterio.io.MemoryFile</code> handles band descriptions compared to direct file access. This is a known limitation when working with in-memory file representations in GDAL (which <code>rasterio</code> uses under the hood). If you need to load descriptions, you should use <code>georeader.rasterio_reader</code> class.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>@classmethod\ndef load_bytes(\n    cls,\n    bytes_read: Union[bytes, bytearray, memoryview],\n    load_tags: bool = False,\n    rio_env_options: Optional[Dict[str, str]] = None,\n) -&gt; Self:\n    \"\"\"\n    Load a GeoTensor from a byte stream. It uses rasterio to read the data.\n\n\n    Args:\n        bytes_read (Union[bytes, bytearray, memoryview]): Byte stream to read.\n        load_tags (bool, optional): if True, load the tags of the image. Defaults to False.\n        rio_env_options (Optional[Dict[str, str]], optional): Rasterio environment options. Defaults to None.\n\n    Returns:\n        __class__: GeoTensor object with the loaded data.\n\n    Note:\n        The `descriptions` attribute cannote be loaded from a byte stream. This is a limitation of `rasterio`.\n        The issue is related to how `rasterio.io.MemoryFile` handles band descriptions\n        compared to direct file access. This is a known limitation when working\n        with in-memory file representations in GDAL (which `rasterio` uses under\n        the hood). If you need to load descriptions, you should use `georeader.rasterio_reader`\n        class.\n    \"\"\"\n    import rasterio.io\n\n    tags = None\n    rio_env_options = (\n        RIO_ENV_OPTIONS_DEFAULT if rio_env_options is None else rio_env_options\n    )\n    with rasterio.Env(**rio_env_options):\n        with rasterio.io.MemoryFile(bytes_read) as mem:\n            with mem.open() as src:\n                data = src.read()\n                transform = src.transform\n                crs = src.crs\n                fill_value_default = src.nodata\n                if load_tags:\n                    tags = src.tags()\n\n    attrs = {}\n    if tags is not None:\n        attrs[\"tags\"] = tags\n\n    return cls(\n        data, transform, crs, fill_value_default=fill_value_default, attrs=attrs\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.load_file","title":"<code>load_file(path, fs=None, load_tags=False, load_descriptions=False, rio_env_options=None)</code>  <code>classmethod</code>","text":"<p>Load a GeoTensor from a file. It uses rasterio to read the data. This function loads all the data in memory. For a lazy loading reader use <code>georeader.rasterio_reader</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file.</p> required <code>fs</code> <code>Optional[Any]</code> <p>fsspec.Filesystem object. Defaults to None.</p> <code>None</code> <code>load_descriptions</code> <code>bool</code> <p>If True, load the description of the image. Defaults to False.</p> <code>False</code> <code>load_tags</code> <code>bool</code> <p>If True, load the tags of the image. Defaults to False.</p> <code>False</code> <code>rio_env_options</code> <code>Optional[Dict[str, str]]</code> <p>Rasterio environment options. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor object with the loaded data.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>@classmethod\ndef load_file(\n    cls,\n    path: str,\n    fs: Optional[Any] = None,\n    load_tags: bool = False,\n    load_descriptions: bool = False,\n    rio_env_options: Optional[Dict[str, str]] = None,\n) -&gt; Self:\n    \"\"\"\n    Load a GeoTensor from a file. It uses rasterio to read the data. This function\n    loads all the data in memory. For a lazy loading reader use `georeader.rasterio_reader`.\n\n    Args:\n        path (str): Path to the file.\n        fs (Optional[Any], optional): fsspec.Filesystem object. Defaults to None.\n        load_descriptions (bool, optional): If True, load the description of the image. Defaults to False.\n        load_tags (bool, optional): If True, load the tags of the image. Defaults to False.\n        rio_env_options (Optional[Dict[str, str]], optional): Rasterio environment options. Defaults to None.\n\n    Returns:\n        GeoTensor: GeoTensor object with the loaded data.\n    \"\"\"\n\n    if fs is not None:\n        if load_descriptions:\n            raise NotImplementedError(\n                \"\"\"Description loading not supported with `fsspec`. This is because\n        the `descriptions` attribute cannote be loaded from a byte stream. This is a limitation of `rasterio`.\n        The issue is related to how `rasterio.io.MemoryFile` handles band descriptions \n        compared to direct file access. This is a known limitation when working \n        with in-memory file representations in GDAL (which `rasterio` uses under \n        the hood). If you need to load descriptions, you can use `georeader.rasterio_reader`\n        class.\"\"\"\n            )\n\n        with fs.open(path, \"rb\") as fh:\n            return cls.load_bytes(\n                fh.read(), load_tags=load_tags, rio_env_options=rio_env_options\n            )\n\n    tags = None\n    descriptions = None\n    rio_env_options = (\n        RIO_ENV_OPTIONS_DEFAULT if rio_env_options is None else rio_env_options\n    )\n    with rasterio.Env(**rio_env_options):\n        with rasterio.open(path) as src:\n            data = src.read()\n            transform = src.transform\n            crs = src.crs\n            fill_value_default = src.nodata\n            if load_tags:\n                tags = src.tags()\n            if load_descriptions:\n                descriptions = tuple(src.descriptions)\n\n    attrs = {}\n    if tags is not None:\n        attrs[\"tags\"] = tags\n\n    if descriptions is not None:\n        attrs[\"descriptions\"] = descriptions\n\n    return cls(\n        data, transform, crs, fill_value_default=fill_value_default, attrs=attrs\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.meshgrid","title":"<code>meshgrid(dst_crs=None)</code>","text":"<p>Create a meshgrid of spatial dimensions of the GeoTensor.</p> <p>Parameters:</p> Name Type Description Default <code>dst_crs</code> <code>Optional[Any]</code> <p>output coordinate reference system. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[NDArray, NDArray]</code> <p>Tuple[NDArray, NDArray]: 2D arrays of xs and ys coordinates.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def meshgrid(self, dst_crs: Optional[Any] = None) -&gt; Tuple[NDArray, NDArray]:\n    \"\"\"\n    Create a meshgrid of spatial dimensions of the GeoTensor.\n\n    Args:\n        dst_crs (Optional[Any], optional): output coordinate reference system. Defaults to None.\n\n    Returns:\n        Tuple[NDArray, NDArray]: 2D arrays of xs and ys coordinates.\n    \"\"\"\n    from georeader import griddata\n\n    return griddata.meshgrid(\n        self.transform,\n        self.width,\n        self.height,\n        source_crs=self.crs,\n        dst_crs=dst_crs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.pad","title":"<code>pad(pad_width, mode='constant', **kwargs)</code>","text":"<p>Pad the GeoTensor.</p> <p>Parameters:</p> Name Type Description Default <code>pad_width</code> <code>Union[Dict[str, Tuple[int, int]], List[Tuple[int, int]]]</code> <p>dictionary with Tuple to pad for each dimension <code>{\"x\": (pad_x_0, pad_x_1), \"y\": (pad_y_0, pad_y_1)}</code> or list of tuples <code>[(pad_x_0, pad_x_1), (pad_y_0, pad_y_1)]</code>.</p> required <code>mode</code> <code>str</code> <p>pad mode (see np.pad or torch.nn.functional.pad). Defaults to \"constant\".</p> <code>'constant'</code> <code>kwargs</code> <p>additional arguments for the pad function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <p>padded GeoTensor.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def pad(\n    self,\n    pad_width: Union[Dict[str, Tuple[int, int]], List[Tuple[int, int]]],\n    mode: str = \"constant\",\n    **kwargs,\n):\n    \"\"\"\n    Pad the GeoTensor.\n\n    Args:\n        pad_width (Union[Dict[str, Tuple[int, int]], List[Tuple[int, int]]]):\n            dictionary with Tuple to pad for each dimension\n            `{\"x\": (pad_x_0, pad_x_1), \"y\": (pad_y_0, pad_y_1)}` or list of tuples\n            `[(pad_x_0, pad_x_1), (pad_y_0, pad_y_1)]`.\n        mode (str, optional): pad mode (see np.pad or torch.nn.functional.pad). Defaults to \"constant\".\n        kwargs: additional arguments for the pad function.\n\n    Returns:\n        GeoTensor: padded GeoTensor.\n    \"\"\"\n    if isinstance(pad_width, list) or isinstance(pad_width, tuple):\n        if len(pad_width) != len(self.dims):\n            raise ValueError(\n                f\"Expected {len(self.dims)} pad widths found {len(pad_width)}\"\n            )\n        pad_width_dict = {}\n        for i, k in enumerate(self.dims):\n            pad_width_dict[k] = pad_width[i]\n    else:\n        pad_width_dict = pad_width\n    return self.pad_array(pad_width_dict, mode=mode, **kwargs)\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.pad_array","title":"<code>pad_array(pad_width, mode='constant', constant_values=None)</code>","text":"<p>Pad the GeoTensor.</p> <p>Parameters:</p> Name Type Description Default <code>pad_width</code> <code>_type_</code> <p>dictionary with Tuple to pad for each dimension <code>{\"x\": (pad_x_0, pad_x_1), \"y\": (pad_y_0, pad_y_1)}</code>.</p> required <code>mode</code> <code>str</code> <p>pad mode (see np.pad or torch.nn.functional.pad). Defaults to \"constant\".</p> <code>'constant'</code> <code>constant_values</code> <code>Any</code> <p>description. Defaults to <code>self.fill_value_default</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>padded GeoTensor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; gt.pad_array({\"x\": (10, 10), \"y\": (10, 10)})\n&gt;&gt;&gt; assert gt.shape == (3, 120, 120)\n</code></pre> Source code in <code>georeader/geotensor.py</code> <pre><code>def pad_array(\n    self,\n    pad_width: Dict[str, Tuple[int, int]],\n    mode: str = \"constant\",\n    constant_values: Optional[Any] = None,\n) -&gt; Self:\n    \"\"\"\n    Pad the GeoTensor.\n\n    Args:\n        pad_width (_type_, optional):  dictionary with Tuple to pad for each dimension\n            `{\"x\": (pad_x_0, pad_x_1), \"y\": (pad_y_0, pad_y_1)}`.\n        mode (str, optional): pad mode (see np.pad or torch.nn.functional.pad). Defaults to \"constant\".\n        constant_values (Any, optional): _description_. Defaults to `self.fill_value_default`.\n\n    Returns:\n        GeoTensor: padded GeoTensor.\n\n    Examples:\n        &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; gt.pad_array({\"x\": (10, 10), \"y\": (10, 10)})\n        &gt;&gt;&gt; assert gt.shape == (3, 120, 120)\n    \"\"\"\n    if constant_values is None and mode == \"constant\":\n        if self.fill_value_default is None:\n            raise ValueError(f\"Mode constant either requires constant_values passed or fill_value_default not None in current GeoTensor\")\n        constant_values = self.fill_value_default\n\n    pad_list_np = []\n    for k in self.dims:\n        if k in pad_width:\n            pad_list_np.append(pad_width[k])\n        else:\n            pad_list_np.append((0, 0))\n\n    kwargs_extra = {}\n    if mode == \"constant\":\n        kwargs_extra[\"constant_values\"] = constant_values\n    values_new = np.pad(self.values, tuple(pad_list_np), mode=mode, **kwargs_extra)\n\n    # Compute the new transform\n    slices_window = []\n    for k in [\"y\", \"x\"]:\n        size = self.width if (k == \"x\") else self.height\n        if k in pad_width:\n            slices_window.append(slice(-pad_width[k][0], size + pad_width[k][1]))\n        else:\n            slices_window.append(slice(0, size))\n\n    window_current = rasterio.windows.Window.from_slices(\n        *slices_window, boundless=True\n    )\n    transform_current = rasterio.windows.transform(\n        window_current, transform=self.transform\n    )\n    return GeoTensor(\n        values_new,\n        transform_current,\n        self.crs,\n        self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.read_from_window","title":"<code>read_from_window(window, boundless=True)</code>","text":"<p>returns a new GeoTensor object with the spatial dimensions sliced</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>Window</code> <p>window to slice the current GeoTensor</p> required <code>boundless</code> <code>bool</code> <p>read from window in boundless mode (i.e. if the window is larger or negative it will pad the GeoTensor with <code>self.fill_value_default</code>)</p> <code>True</code> <p>Raises:</p> Type Description <code>WindowError</code> <p>if <code>window</code> does not intersect the data</p> <p>Returns:</p> Type Description <code>Self</code> <p>GeoTensor object with the spatial dimensions sliced</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def read_from_window(\n    self, window: rasterio.windows.Window, boundless: bool = True\n) -&gt; Self:\n    \"\"\"\n    returns a new GeoTensor object with the spatial dimensions sliced\n\n    Args:\n        window: window to slice the current GeoTensor\n        boundless: read from window in boundless mode (i.e. if the window is larger or negative it will pad\n            the GeoTensor with `self.fill_value_default`)\n\n    Raises:\n        rasterio.windows.WindowError: if `window` does not intersect the data\n\n    Returns:\n        GeoTensor object with the spatial dimensions sliced\n\n    \"\"\"\n\n    window_data = rasterio.windows.Window(\n        col_off=0, row_off=0, width=self.width, height=self.height\n    )\n    if boundless:\n        slice_dict, pad_width = window_utils.get_slice_pad(window_data, window)\n        need_pad = any(p != 0 for p in pad_width[\"x\"] + pad_width[\"y\"])\n        X_sliced = self.isel(slice_dict)\n        if need_pad:\n            X_sliced = X_sliced.pad(\n                pad_width=pad_width,\n                mode=\"constant\",\n                constant_values=self.fill_value_default,\n            )\n        return X_sliced\n    else:\n        window_read = rasterio.windows.intersection(window, window_data)\n        slice_y, slice_x = window_read.toslices()\n        slice_dict = {\"x\": slice_x, \"y\": slice_y}\n        slices_ = self._slice_tuple(slice_dict)\n        transform_current = rasterio.windows.transform(\n            window_read, transform=self.transform\n        )\n        return GeoTensor(\n            self.values[slices_],\n            transform_current,\n            self.crs,\n            self.fill_value_default,\n            attrs=self.attrs,\n        )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.resize","title":"<code>resize(output_shape=None, resolution_dst=None, anti_aliasing=True, anti_aliasing_sigma=None, interpolation='bilinear', mode_pad='constant')</code>","text":"<p>Resize the geotensor to match a certain size output_shape. This function works with GeoTensors of 2D, 3D and 4D. The geoinformation of the output tensor is changed accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>output_shape</code> <code>Optional[Tuple[int, int]]</code> <p>output spatial shape if None resolution_dst must be provided. If not provided, the output shape is computed from the resolution_dst rounding to the closest integer.</p> <code>None</code> <code>resolution_dst</code> <code>Optional[Tuple[float, float]]</code> <p>output resolution if None output_shape must be provided.</p> <code>None</code> <code>anti_aliasing</code> <code>bool</code> <p>Whether to apply a Gaussian filter to smooth the image prior to downsampling</p> <code>True</code> <code>anti_aliasing_sigma</code> <code>Optional[Union[float, ndarray]]</code> <p>anti_aliasing_sigma : {float}, optional Standard deviation for Gaussian filtering used when anti-aliasing. By default, this value is chosen as (s - 1) / 2 where s is the downsampling factor, where s &gt; 1</p> <code>None</code> <code>interpolation</code> <code>Optional[str]</code> <p>Algorithm used for resizing: 'nearest' | 'bilinear' | 'bicubic'</p> <code>'bilinear'</code> <code>mode_pad</code> <code>str</code> <p>mode pad for resize function</p> <code>'constant'</code> <p>Returns:</p> Type Description <code>Self</code> <p>resized GeoTensor</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; resized = gt.resize((50, 50))\n&gt;&gt;&gt; assert resized.shape == (3, 50, 50)\n&gt;&gt;&gt; assert resized.res == (2*gt.res[0], 2*gt.res[1])\n</code></pre> Source code in <code>georeader/geotensor.py</code> <pre><code>def resize(\n    self,\n    output_shape: Optional[Tuple[int, int]] = None,\n    resolution_dst: Optional[Tuple[float, float]] = None,\n    anti_aliasing: bool = True,\n    anti_aliasing_sigma: Optional[Union[float, np.ndarray]] = None,\n    interpolation: Optional[str] = \"bilinear\",\n    mode_pad: str = \"constant\",\n) -&gt; Self:\n    \"\"\"\n    Resize the geotensor to match a certain size output_shape. This function works with GeoTensors of 2D, 3D and 4D.\n    The geoinformation of the output tensor is changed accordingly.\n\n    Args:\n        output_shape: output spatial shape if None resolution_dst must be provided. If not provided,\n            the output shape is computed from the resolution_dst rounding to the closest integer.\n        resolution_dst: output resolution if None output_shape must be provided.\n        anti_aliasing: Whether to apply a Gaussian filter to smooth the image prior to downsampling\n        anti_aliasing_sigma:  anti_aliasing_sigma : {float}, optional\n            Standard deviation for Gaussian filtering used when anti-aliasing.\n            By default, this value is chosen as (s - 1) / 2 where s is the\n            downsampling factor, where s &gt; 1\n        interpolation: Algorithm used for resizing: 'nearest' | 'bilinear' | 'bicubic'\n        mode_pad: mode pad for resize function\n\n    Returns:\n         resized GeoTensor\n\n    Examples:\n        &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; resized = gt.resize((50, 50))\n        &gt;&gt;&gt; assert resized.shape == (3, 50, 50)\n        &gt;&gt;&gt; assert resized.res == (2*gt.res[0], 2*gt.res[1])\n    \"\"\"\n    input_shape = self.shape\n    spatial_shape = input_shape[-2:]\n    resolution_or = self.res\n\n    if output_shape is None:\n        assert (\n            resolution_dst is not None\n        ), f\"Can't have output_shape and resolution_dst as None\"\n        output_shape = int(\n            round(spatial_shape[0] * resolution_or[0] / resolution_dst[0])\n        ), int(round(spatial_shape[1] * resolution_or[1] / resolution_dst[1]))\n    else:\n        assert (\n            resolution_dst is None\n        ), f\"Both output_shape and resolution_dst can't be provided\"\n        assert (\n            len(output_shape) == 2\n        ), f\"Expected output shape to be the spatial dimensions found: {output_shape}\"\n        resolution_dst = (\n            spatial_shape[0] * resolution_or[0] / output_shape[0],\n            spatial_shape[1] * resolution_or[1] / output_shape[1],\n        )\n\n    # Compute output transform\n    transform_scale = rasterio.Affine.scale(\n        resolution_dst[0] / resolution_or[0], resolution_dst[1] / resolution_or[1]\n    )\n    transform = self.transform * transform_scale\n\n    from skimage.transform import resize\n\n    # https://scikit-image.org/docs/stable/api/skimage.transform.html#skimage.transform.resize\n    output_tensor = np.ndarray(input_shape[:-2] + output_shape, dtype=self.dtype)\n    if len(input_shape) == 4:\n        for i, j in product(range(0, input_shape[0]), range(0, input_shape[1])):\n            if (\n                (not anti_aliasing)\n                or (anti_aliasing_sigma is None)\n                or isinstance(anti_aliasing_sigma, numbers.Number)\n            ):\n                anti_aliasing_sigma_iter = anti_aliasing_sigma\n            else:\n                anti_aliasing_sigma_iter = anti_aliasing_sigma[i, j]\n            output_tensor[i, j] = resize(\n                self.values[i, j],\n                output_shape,\n                order=ORDERS[interpolation],\n                anti_aliasing=anti_aliasing,\n                preserve_range=False,\n                cval=self.fill_value_default,\n                mode=mode_pad,\n                anti_aliasing_sigma=anti_aliasing_sigma_iter,\n            )\n    elif len(input_shape) == 3:\n        for i in range(0, input_shape[0]):\n            if (\n                (not anti_aliasing)\n                or (anti_aliasing_sigma is None)\n                or isinstance(anti_aliasing_sigma, numbers.Number)\n            ):\n                anti_aliasing_sigma_iter = anti_aliasing_sigma\n            else:\n                anti_aliasing_sigma_iter = anti_aliasing_sigma[i]\n            output_tensor[i] = resize(\n                self.values[i],\n                output_shape,\n                order=ORDERS[interpolation],\n                anti_aliasing=anti_aliasing,\n                preserve_range=False,\n                cval=self.fill_value_default,\n                mode=mode_pad,\n                anti_aliasing_sigma=anti_aliasing_sigma_iter,\n            )\n    else:\n        output_tensor[...] = resize(\n            self.values,\n            output_shape,\n            order=ORDERS[interpolation],\n            anti_aliasing=anti_aliasing,\n            preserve_range=False,\n            cval=self.fill_value_default,\n            mode=mode_pad,\n            anti_aliasing_sigma=anti_aliasing_sigma,\n        )\n\n    return GeoTensor(\n        output_tensor,\n        transform=transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.same_extent","title":"<code>same_extent(other, precision=0.001)</code>","text":"<p>Check if two GeoTensors have the same georeferencing (crs, transform and spatial dimensions).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>GeoTensor | GeoData</code> <p>GeoTensor to compare with. Other GeoData object can be passed (it requires crs, transform and shape attributes)</p> required <code>precision</code> <code>float</code> <p>precision to compare the transform. Defaults to 1e-3.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both GeoTensors have the same georeferencing.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def same_extent(self, other: Self, precision: float = 1e-3) -&gt; bool:\n    \"\"\"\n    Check if two GeoTensors have the same georeferencing (crs, transform and spatial dimensions).\n\n    Args:\n        other (GeoTensor | GeoData): GeoTensor to compare with. Other GeoData object can be passed (it requires crs, transform and shape attributes)\n        precision (float, optional): precision to compare the transform. Defaults to 1e-3.\n\n    Returns:\n        bool: True if both GeoTensors have the same georeferencing.\n    \"\"\"\n    return (\n        self.transform.almost_equals(other.transform, precision=precision)\n        and window_utils.compare_crs(self.crs, other.crs)\n        and (self.shape[-2:] == other.shape[-2:])\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.squeeze","title":"<code>squeeze(axis=None)</code>","text":"<p>Remove single-dimensional entries from the shape of the GeoTensor values. It does not squeeze the spatial dimensions (last two dimensions).</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>GeoTensor with the squeezed values.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def squeeze(self, axis=None) -&gt; Self:\n    \"\"\"\n    Remove single-dimensional entries from the shape of the GeoTensor values.\n    It does not squeeze the spatial dimensions (last two dimensions).\n\n    Returns:\n        GeoTensor: GeoTensor with the squeezed values.\n    \"\"\"\n    if axis is None:\n        axis = tuple(range(self.values.ndim - 2))\n    else:\n        if isinstance(axis, int):\n            axis = (axis,)\n        # Check if spatial dimesions will be squeezed\n        if self.width == 1:\n            if any(a in (-1, self.values.ndim - 1) for a in axis):\n                raise ValueError(\n                    \"Cannot squeeze spatial dimensions. \"\n                    \"Use `squeeze(axis=0)` to squeeze the first dimension.\"\n                )\n        elif self.height == 1:\n            if any(a in (-2, self.values.ndim - 2) for a in axis):\n                raise ValueError(\n                    \"Cannot squeeze spatial dimensions. \"\n                    \"Use `squeeze(axis=0)` to squeeze the first dimension.\"\n                )\n\n    # squeeze all but last two dimensions\n    squeezed_values = np.squeeze(self.values, axis=axis)\n\n    return GeoTensor(\n        squeezed_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.stack","title":"<code>stack(geotensors)</code>  <code>classmethod</code>","text":"<p>Stacks a list of geotensors, assert that all of them has same shape, transform and crs.</p> <p>Parameters:</p> Name Type Description Default <code>geotensors</code> <code>List[Self]</code> <p>list of geotensors to concat. All with same shape, transform and crs.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>geotensor with extra dim at the front: (len(geotensors),) + shape</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gt1 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; gt2 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; gt3 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; gt = stack([gt1, gt2, gt3])\n&gt;&gt;&gt; assert gt.shape == (3, 3, 100, 100)\n</code></pre> Source code in <code>georeader/geotensor.py</code> <pre><code>@classmethod\ndef stack(cls, geotensors: List[Self]) -&gt; Self:\n    \"\"\"\n    Stacks a list of geotensors, assert that all of them has same shape, transform and crs.\n\n    Args:\n        geotensors: list of geotensors to concat. All with same shape, transform and crs.\n\n    Returns:\n        geotensor with extra dim at the front: (len(geotensors),) + shape\n\n    Examples:\n        &gt;&gt;&gt; gt1 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; gt2 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; gt3 = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; gt = stack([gt1, gt2, gt3])\n        &gt;&gt;&gt; assert gt.shape == (3, 3, 100, 100)\n    \"\"\"\n    assert len(geotensors) &gt; 0, \"Empty list provided can't concat\"\n\n    if len(geotensors) == 1:\n        gt = geotensors[0].copy()\n        gt.values = gt.values[np.newaxis]\n        return gt\n\n    first_geotensor = geotensors[0]\n    array_out = np.zeros(\n        (len(geotensors),) + first_geotensor.shape, dtype=first_geotensor.dtype\n    )\n    array_out[0] = first_geotensor.values\n\n    for i, geo in enumerate(geotensors[1:]):\n        assert geo.same_extent(first_geotensor), f\"Different size in concat {i+1}\"\n        assert (\n            geo.shape == first_geotensor.shape\n        ), f\"Different shape in concat {i+1}\"\n        assert (\n            geo.fill_value_default == first_geotensor.fill_value_default\n        ), \"Different fill_value_default in concat\"\n        array_out[i + 1] = geo.values\n\n    return cls(\n        array_out,\n        transform=first_geotensor.transform,\n        crs=first_geotensor.crs,\n        fill_value_default=first_geotensor.fill_value_default,\n        attrs=first_geotensor.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.transpose","title":"<code>transpose(axes=None)</code>","text":"<p>Permute the dimensions of the GeoTensor while keeping the spatial dimensions at the end.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>tuple</code> <p>If specified, it must be a tuple or list of axes. The last two values must be the original spatial dimensions indices (ndim-2, ndim-1). If None, the non-spatial dimensions are reversed while spatial dimensions remain at the end.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Self</code> <p>A view of the array with dimensions transposed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the spatial dimensions are moved from their last positions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 4, 100, 200), transform, crs)\n&gt;&gt;&gt; # Shape is (3, 4, 100, 200)\n&gt;&gt;&gt; gt_t = gt.transpose()\n&gt;&gt;&gt; # Shape is now (4, 3, 100, 200)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # You can also specify axes explicitly:\n&gt;&gt;&gt; gt_t = gt.transpose((1, 0, 2, 3))  # Valid: spatial dims remain at end\n&gt;&gt;&gt; # But this would raise an error:\n&gt;&gt;&gt; # gt.transpose((0, 2, 1, 3))  # Invalid: spatial dims must stay at end\n</code></pre> Source code in <code>georeader/geotensor.py</code> <pre><code>def transpose(self, axes=None) -&gt; Self:\n    \"\"\"\n    Permute the dimensions of the GeoTensor while keeping the spatial dimensions at the end.\n\n    Args:\n        axes (tuple, optional): If specified, it must be a tuple or list of axes. The last two\n            values must be the original spatial dimensions indices (ndim-2, ndim-1).\n            If None, the non-spatial dimensions are reversed while spatial dimensions remain at the end.\n\n    Returns:\n        GeoTensor: A view of the array with dimensions transposed.\n\n    Raises:\n        ValueError: If the spatial dimensions are moved from their last positions.\n\n    Examples:\n        &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 4, 100, 200), transform, crs)\n        &gt;&gt;&gt; # Shape is (3, 4, 100, 200)\n        &gt;&gt;&gt; gt_t = gt.transpose()\n        &gt;&gt;&gt; # Shape is now (4, 3, 100, 200)\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # You can also specify axes explicitly:\n        &gt;&gt;&gt; gt_t = gt.transpose((1, 0, 2, 3))  # Valid: spatial dims remain at end\n        &gt;&gt;&gt; # But this would raise an error:\n        &gt;&gt;&gt; # gt.transpose((0, 2, 1, 3))  # Invalid: spatial dims must stay at end\n    \"\"\"\n    ndim = len(self.shape)\n\n    if ndim &lt;= 2:\n        # Nothing meaningful to transpose for arrays with only spatial dimensions\n        return self.copy()\n\n    # Original spatial dimensions indices\n    y_dim = ndim - 2\n    x_dim = ndim - 1\n\n    if axes is None:\n        # Reverse all dimensions except the spatial ones which stay at the end\n        non_spatial_axes = list(range(ndim - 2))\n        non_spatial_axes.reverse()\n        axes = tuple(non_spatial_axes + [y_dim, x_dim])\n    else:\n        # Convert to tuple if necessary\n        axes = tuple(axes)\n\n        # Check if axes has the right length\n        if len(axes) != ndim:\n            raise ValueError(f\"axes should contain {ndim} dimensions, got {len(axes)}\")\n\n        # Check if the last two values in axes are the spatial dimensions\n        if axes[-2:] != (y_dim, x_dim):\n            raise ValueError(\n                \"Cannot change the position of spatial dimensions. \"\n                f\"The last two axes must be {y_dim} and {x_dim}.\"\n            )\n\n    # Perform the transpose\n    transposed_values = np.transpose(self.values, axes)\n\n    return GeoTensor(\n        transposed_values,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n        attrs=self.attrs,\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.valid_footprint","title":"<code>valid_footprint(crs=None, method='all')</code>","text":"<p>vectorizes the valid values of the GeoTensor and returns the footprint as a Polygon.</p> <p>Parameters:</p> Name Type Description Default <code>crs</code> <code>Optional[str]</code> <p>Coordinate reference system. Defaults to None.</p> <code>None</code> <code>method</code> <code>str</code> <p>\"all\" or \"any\" to aggregate the channels of the image. Defaults to \"all\".</p> <code>'all'</code> <p>Returns:</p> Type Description <code>Union[MultiPolygon, Polygon]</code> <p>Polygon or MultiPolygon: footprint of the GeoTensor.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def valid_footprint(\n    self, crs: Optional[str] = None, method: str = \"all\"\n) -&gt; Union[MultiPolygon, Polygon]:\n    \"\"\"\n    vectorizes the valid values of the GeoTensor and returns the footprint as a Polygon.\n\n    Args:\n        crs (Optional[str], optional): Coordinate reference system. Defaults to None.\n        method (str, optional): \"all\" or \"any\" to aggregate the channels of the image. Defaults to \"all\".\n\n    Returns:\n        Polygon or MultiPolygon: footprint of the GeoTensor.\n    \"\"\"\n    valid_values = self.values != self.fill_value_default\n    if len(valid_values.shape) &gt; 2:\n        if method == \"all\":\n            valid_values = np.all(\n                valid_values,\n                axis=tuple(np.arange(0, len(valid_values.shape) - 2).tolist()),\n            )\n        elif method == \"any\":\n            valid_values = np.any(\n                valid_values,\n                axis=tuple(np.arange(0, len(valid_values.shape) - 2).tolist()),\n            )\n        else:\n            raise NotImplementedError(\n                f\"Method {method} to aggregate channels not implemented\"\n            )\n\n    from georeader import vectorize\n\n    polygons = vectorize.get_polygons(valid_values, transform=self.transform)\n    if len(polygons) == 0:\n        raise ValueError(\"GeoTensor has no valid values\")\n    elif len(polygons) == 1:\n        pol = polygons[0]\n    else:\n        pol = MultiPolygon(polygons)\n    if crs is None:\n        return pol\n\n    return window_utils.polygon_to_crs(pol, self.crs, crs)\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.validmask","title":"<code>validmask()</code>","text":"<p>Returns a mask of the valid values of the GeoTensor. The mask is a boolean array with the same shape as the GeoTensor values, where True indicates valid values and False indicates invalid values. The mask is created by comparing the values of the GeoTensor with the <code>self.fill_value_default</code>.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>GeoTensor with the valid boolean mask.</p> Source code in <code>georeader/geotensor.py</code> <pre><code>def validmask(self) -&gt; Self:\n    \"\"\"\n    Returns a mask of the valid values of the GeoTensor. The mask is a boolean array\n    with the same shape as the GeoTensor values, where True indicates valid values and\n    False indicates invalid values.\n    The mask is created by comparing the values of the GeoTensor with the `self.fill_value_default`.\n\n    Returns:\n        Self: GeoTensor with the valid boolean mask.\n    \"\"\"\n    if self.fill_value_default is None:\n        return GeoTensor(\n            np.ones(self.shape, dtype=bool),\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n            attrs=self.attrs\n        )\n    return GeoTensor(\n        values=self.values != self.fill_value_default,\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=False,\n        attrs=self.attrs\n    )\n</code></pre>"},{"location":"modules/geotensor_module/#georeader.geotensor.GeoTensor.write_from_window","title":"<code>write_from_window(data, window)</code>","text":"<p>Writes array to GeoTensor values object at the given window position. If window surpasses the bounds of this object it crops the data to fit the object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Tensor</code> <p>Tensor to write. Expected: spatial dimensions <code>window.width</code>, <code>window.height</code>. Rest: same as <code>self</code></p> required <code>window</code> <code>Window</code> <p>Window object that specifies the spatial location to write the data</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n&gt;&gt;&gt; data = np.random.rand(3, 50, 50)\n&gt;&gt;&gt; window = rasterio.windows.Window(col_off=7, row_off=9, width=50, height=50)\n&gt;&gt;&gt; gt.write_from_window(data, window)\n</code></pre> Source code in <code>georeader/geotensor.py</code> <pre><code>def write_from_window(self, data: Tensor, window: rasterio.windows.Window):\n    \"\"\"\n    Writes array to GeoTensor values object at the given window position. If window surpasses the bounds of this\n    object it crops the data to fit the object.\n\n    Args:\n        data: Tensor to write. Expected: spatial dimensions `window.width`, `window.height`. Rest: same as `self`\n        window: Window object that specifies the spatial location to write the data\n\n    Examples:\n        &gt;&gt;&gt; gt = GeoTensor(np.random.rand(3, 100, 100), transform, crs)\n        &gt;&gt;&gt; data = np.random.rand(3, 50, 50)\n        &gt;&gt;&gt; window = rasterio.windows.Window(col_off=7, row_off=9, width=50, height=50)\n        &gt;&gt;&gt; gt.write_from_window(data, window)\n\n    \"\"\"\n    window_data = rasterio.windows.Window(\n        col_off=0, row_off=0, width=self.width, height=self.height\n    )\n    if not rasterio.windows.intersect(window, window_data):\n        return\n\n    assert data.shape[-2:] == (\n        window.height,\n        window.width,\n    ), f\"window {window} has different shape than data {data.shape}\"\n    assert (\n        data.shape[:-2] == self.shape[:-2]\n    ), f\"Dimension of data in non-spatial channels found {data.shape} expected: {self.shape}\"\n\n    slice_dict, pad_width = window_utils.get_slice_pad(window_data, window)\n    slice_list = self._slice_tuple(slice_dict)\n    # need_pad = any(p != 0 for p in pad_width[\"x\"] + pad_width[\"y\"])\n\n    slice_data_spatial_x = slice(\n        pad_width[\"x\"][0], None if pad_width[\"x\"][1] == 0 else -pad_width[\"x\"][1]\n    )\n    slice_data_spatial_y = slice(\n        pad_width[\"y\"][0], None if pad_width[\"y\"][1] == 0 else -pad_width[\"y\"][1]\n    )\n    slice_data = self._slice_tuple(\n        {\"x\": slice_data_spatial_x, \"y\": slice_data_spatial_y}\n    )\n    self.values[slice_list] = data[slice_data]\n</code></pre>"},{"location":"modules/plot_module/","title":"Plotting Functions","text":"<p>The <code>georeader.plot</code> module provides <code>matplotlib</code> visualization functions for working with geospatial data, particularly with <code>GeoTensor</code> objects. These functions build on <code>matplotlib</code> to provide convenient ways to visualize raster data with appropriate geographic context.</p>"},{"location":"modules/plot_module/#plotshow","title":"<code>plot.show</code>","text":"<p>This function displays geospatial data on a matplotlib axis. It's a wrapper around matplotlib's <code>imshow</code> function that handles GeoData objects properly, respecting their coordinate systems.</p> <p>Features: * Automatically handles the extent based on the data's bounds * Optional colorbar display * Optional scale bar showing geographic scale * Can display coordinates in lat/long format * Handles masking of no-data values</p> <p>Example: <pre><code>import matplotlib.pyplot as plt\nfrom georeader import plot\n\n# Display RGB data (3-band image)\nrgb = (s2img[[3,2,1]] / 3_500).clip(0,1)\nplot.show(rgb)\n</code></pre></p> <p></p> <pre><code># With colorbar\ngreyimg = np.mean(rgb, axis=0)\nplot.show(greyimg, add_colorbar_next_to=True)\n</code></pre> <p></p>"},{"location":"modules/plot_module/#plotplot_segmentation_mask","title":"<code>plot.plot_segmentation_mask</code>","text":"<p>This function visualizes discrete segmentation masks (like land cover classifications) with appropriate colors and legend.</p> <p>Features: * Customizable color mapping for different classes * Optional legend with class names * Works with both numeric and categorical data</p> <p>Example: <pre><code># Create a land/water/cloud mask\nwater = mndwi &lt; 0\nland_water_clouds = GeoTensor(np.ones(clouds.shape, dtype=np.uint8),\n                              fill_value_default=0,\n                              crs=clouds.crs,\n                              transform=clouds.transform)\n\nland_water_clouds[water] = 2\nland_water_clouds[clouds] = 3\nland_water_clouds[invalids] = 0\n\nplot.plot_segmentation_mask(land_water_clouds, \n                           interpretation_array=[\"invalids\",\"clear\",\"water\",\"cloud\"], \n                           color_array=[\"#000000\",\"#c66d43\",\"#437cc6\",\"#eeeeee\"])\n</code></pre></p> <p></p>"},{"location":"modules/plot_module/#plotadd_shape_to_plot","title":"<code>plot.add_shape_to_plot</code>","text":"<p>This function adds vector data (like points, lines, polygons) to an existing map.</p> <p>Features: * Works with GeoDataFrame, individual geometries, or lists of geometries * Handles coordinate system transformations * Customizable styling options * Can plot polygon outlines only</p> <p>Example: <pre><code>from georeader import plot\nfrom shapely.geometry import box\n\n# Create a plot with raster data\nax = plot.show(rgb)\nbbox = box(45.43, -19.53, 45.45, -19.58)\n\nplot.add_shape_to_plot(bbox, ax=ax, polygon_no_fill=True, \n                       crs_plot=rgb.crs,\n                       crs_shape=\"EPSG:4326\",\n                       kwargs_geopandas_plot={\"color\": \"red\"})\n</code></pre> </p>"},{"location":"modules/plot_module/#api-reference","title":"API Reference","text":""},{"location":"modules/plot_module/#georeader.plot.show","title":"<code>show(data, add_colorbar_next_to=False, add_scalebar=False, kwargs_scalebar=None, mask=False, bounds_in_latlng=True, **kwargs)</code>","text":"<p>Wrapper around rasterio.plot.show for GeoData objects. It adds options to add a colorbar next to the plot and a scalebar showing the geographic scale.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>GeoData</code> <p>GeoData object to plot with imshow</p> required <code>add_colorbar_next_to</code> <code>bool</code> <p>Defaults to False. Add a colorbar next to the plot</p> <code>False</code> <code>add_scalebar</code> <code>bool</code> <p>Defaults to False. Add a scalebar to the plot</p> <code>False</code> <code>kwargs_scalebar</code> <code>Optional[dict]</code> <p>Defaults to None. Keyword arguments for the scalebar. </p> <code>None</code> <code>See</code> <code>https</code> <p>//github.com/ppinard/matplotlib-scalebar. (install with pip install matplotlib-scalebar)</p> required <code>mask</code> <code>Union[bool, array]</code> <p>Defaults to False. Mask to apply to the data.  If True, the fill_value_default of the GeoData is used.</p> <code>False</code> <code>bounds_in_latlng</code> <code>bool</code> <p>Defaults to True. If True, the x and y ticks are shown in latlng.</p> <code>True</code> <code>**kwargs</code> <p>Keyword arguments for imshow</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>plt.Axes: image object</p> Source code in <code>georeader/plot.py</code> <pre><code>def show(data:GeoData, add_colorbar_next_to:bool=False,\n         add_scalebar:bool=False,\n         kwargs_scalebar:Optional[dict]=None,\n         mask:Union[bool,np.array]= False, bounds_in_latlng:bool=True,\n           **kwargs) -&gt; plt.Axes:\n    \"\"\"\n    Wrapper around rasterio.plot.show for GeoData objects. It adds options to add a colorbar next to the plot\n    and a scalebar showing the geographic scale.\n\n    Args:\n        data (GeoData): GeoData object to plot with imshow\n        add_colorbar_next_to (bool, optional): Defaults to False. Add a colorbar next to the plot\n        add_scalebar (bool, optional): Defaults to False. Add a scalebar to the plot\n        kwargs_scalebar (Optional[dict], optional): Defaults to None. Keyword arguments for the scalebar. \n        See https://github.com/ppinard/matplotlib-scalebar. (install with pip install matplotlib-scalebar)\n        mask (Union[bool,np.array], optional): Defaults to False. Mask to apply to the data. \n            If True, the fill_value_default of the GeoData is used.\n        bounds_in_latlng (bool, optional): Defaults to True. If True, the x and y ticks are shown in latlng.\n        **kwargs: Keyword arguments for imshow\n\n    Returns:\n        plt.Axes: image object\n    \"\"\"\n    if \"ax\" in kwargs:\n        ax = kwargs.pop(\"ax\")\n        if ax is None:\n            ax = plt.gca()\n    else:\n        ax = plt.gca()\n\n    if isinstance(mask, bool):\n        if mask:\n            mask = data.values == data.fill_value_default\n            np_data = np.ma.masked_array(data.values, mask=mask)\n        else:\n            mask = None\n            np_data = data.values\n    else:\n        np_data = np.ma.masked_array(data.values, mask=mask)\n\n    if len(np_data.shape) == 3:\n        if np_data.shape[0] == 1:\n            np_data = np_data[0]\n        else:\n            np_data = np_data.transpose(1, 2, 0)\n\n            if mask is not None:\n                assert len(mask.shape) in (2, 3), f\"mask must be 2D or 3D found shape: {mask.shape}\"\n                if len(mask.shape) == 3:\n                    mask = np.any(mask, axis=0)\n\n                # Convert np_data to RGBA using mask as alpha channel.\n                np_data = np.concatenate([np_data, ~mask[..., None]], axis=-1)\n\n    xmin, ymin, xmax, ymax = data.bounds\n    # kwargs['extent'] = (bounds.left, bounds.right, bounds.bottom, bounds.top)\n    # xmin, ymin, xmax, ymax\n    kwargs['extent'] = (xmin, xmax, ymin, ymax)\n\n    if not data.transform.is_rectilinear:\n        warnings.warn(\"The transform is not rectilinear. The x and y ticks and the scale bar are not going to be correct.\"\n                      \" To discard this warning use: warnings.filterwarnings('ignore', message='The transform is not rectilinear.')\")\n\n    title = None\n    if \"title\" in kwargs:\n        title = kwargs.pop(\"title\")\n\n    ax.imshow(np_data, **kwargs)\n\n    if title is not None:\n        ax.set_title(title)\n\n    if add_colorbar_next_to:\n        im = ax.images[-1]\n        colorbar_next_to(im, ax)\n\n    if add_scalebar:\n        try:\n             from matplotlib_scalebar.scalebar import ScaleBar\n        except ImportError as e:\n            raise ImportError(\"Install matplotlib-scalebar to use scalebar\"\n                              \"pip install matplotlib-scalebar\"\n                              f\"{e}\")\n\n        if kwargs_scalebar is None:\n            kwargs_scalebar = {\"dx\":1}\n        if \"dx\" not in kwargs_scalebar:\n            kwargs_scalebar[\"dx\"] = 1\n        ax.add_artist(ScaleBar(**kwargs_scalebar))\n\n    if bounds_in_latlng:\n        from matplotlib.ticker import FuncFormatter\n\n        xmin, ymin, xmax, ymax = data.bounds\n\n        @FuncFormatter\n        def x_formatter(x, pos):\n            # transform x,ymin to latlng\n            longs, lats = rasterio.warp.transform(data.crs, \"epsg:4326\", [x], [ymin])\n            return f\"{longs[0]:.2f}\"\n\n\n        @FuncFormatter\n        def y_formatter(y, pos):\n            # transform xmin,y to latlng\n            longs, lats = rasterio.warp.transform(data.crs, \"epsg:4326\", [xmin], [y])\n            return f\"{lats[0]:.2f}\"\n\n        ax.xaxis.set_major_formatter(x_formatter)\n        ax.yaxis.set_major_formatter(y_formatter)\n\n\n    return ax\n</code></pre>"},{"location":"modules/plot_module/#georeader.plot.plot_segmentation_mask","title":"<code>plot_segmentation_mask(mask, color_array=None, interpretation_array=None, legend=True, ax=None, add_scalebar=False, kwargs_scalebar=None, bounds_in_latlng=True)</code>","text":"<p>Plots a discrete segmentation mask with a legend.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>GeoData</code> <p>(H, W) np.array with values from 0 to len(color_array)-1</p> required <code>color_array</code> <code>Optional[NDArray]</code> <p>colors for values 0,...,len(color_array)-1 of mask</p> <code>None</code> <code>interpretation_array</code> <code>Optional[List[str]]</code> <p>interpretation for classes 0, ..., len(color_array)-1</p> <code>None</code> <code>legend</code> <code>bool</code> <p>plot the legend</p> <code>True</code> <code>ax</code> <code>Optional[Axes]</code> <p>plt.Axes to plot</p> <code>None</code> <code>add_scalebar</code> <code>bool</code> <p>Defaults to False. Add a scalebar to the plot</p> <code>False</code> <code>kwargs_scalebar</code> <code>Optional[dict]</code> <p>Defaults to None. Keyword arguments for the scalebar. </p> <code>None</code> <code>See</code> <code>https</code> <p>//github.com/ppinard/matplotlib-scalebar. (install with pip install matplotlib-scalebar)</p> required <code>bounds_in_latlng</code> <code>bool</code> <p>Defaults to True. If True, the x and y ticks are shown in latlng.</p> <code>True</code> <p>Returns:</p> Type Description <code>Axes</code> <p>plt.Axes</p> Source code in <code>georeader/plot.py</code> <pre><code>def plot_segmentation_mask(mask:GeoData, color_array:Optional[NDArray]=None,\n                           interpretation_array:Optional[List[str]]=None,\n                           legend:bool=True, ax:Optional[plt.Axes]=None,\n                           add_scalebar:bool=False,\n                           kwargs_scalebar:Optional[dict]=None,\n                           bounds_in_latlng:bool=True) -&gt; plt.Axes:\n    \"\"\"\n    Plots a discrete segmentation mask with a legend.\n\n    Args:\n        mask: (H, W) np.array with values from 0 to len(color_array)-1\n        color_array: colors for values 0,...,len(color_array)-1 of mask\n        interpretation_array: interpretation for classes 0, ..., len(color_array)-1\n        legend: plot the legend\n        ax: plt.Axes to plot\n        add_scalebar (bool, optional): Defaults to False. Add a scalebar to the plot\n        kwargs_scalebar (Optional[dict], optional): Defaults to None. Keyword arguments for the scalebar. \n        See https://github.com/ppinard/matplotlib-scalebar. (install with pip install matplotlib-scalebar)\n        bounds_in_latlng (bool, optional): Defaults to True. If True, the x and y ticks are shown in latlng.\n\n    Returns:\n        plt.Axes\n\n    \"\"\"\n    if color_array is None:\n        if interpretation_array is not None:\n            nlabels = len(interpretation_array)\n        else:\n            nlabels = len(np.unique(mask))\n\n        color_array = plt.cm.tab20.colors[:nlabels]\n\n    cmap_categorical = colors.ListedColormap(color_array)\n    color_array = np.array(color_array)\n    norm_categorical = colors.Normalize(vmin=-.5,\n                                        vmax=color_array.shape[0] - .5)\n\n\n    if interpretation_array is not None:\n        assert len(interpretation_array) == color_array.shape[\n            0], f\"Different numbers of colors and interpretation {len(interpretation_array)} {color_array.shape[0]}\"\n\n\n    ax = show(mask, ax=ax,\n              cmap=cmap_categorical, norm=norm_categorical, \n              interpolation='nearest', add_scalebar=add_scalebar,\n              kwargs_scalebar=kwargs_scalebar, bounds_in_latlng=bounds_in_latlng)\n\n    if legend:\n        if interpretation_array is None:\n            interpretation_array = [str(i) for i in range(color_array.shape[0])]\n        patches = []\n        for c, interp in zip(color_array, interpretation_array):\n            patches.append(mpatches.Patch(color=c, label=interp))\n\n        ax.legend(handles=patches,\n                  loc='upper right')\n\n    return ax\n</code></pre>"},{"location":"modules/plot_module/#georeader.plot.add_shape_to_plot","title":"<code>add_shape_to_plot(shape, ax=None, crs_plot=None, crs_shape=None, polygon_no_fill=False, kwargs_geopandas_plot=None, title=None)</code>","text":"<p>Adds a shape to a plot. It uses geopandas.plot.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Union[GeoDataFrame, List[BaseGeometry], BaseGeometry]</code> <p>geodata to plot</p> required <code>ax</code> <code>Optional[Axes]</code> <p>Defaults to None. Axes to plot the shape</p> <code>None</code> <code>crs_plot</code> <code>Optional[Any]</code> <p>Defaults to None. crs to plot the shape. If None, the crs of the shape is used.</p> <code>None</code> <code>crs_shape</code> <code>Optional[Any]</code> <p>Defaults to None. crs of the shape. If None, the crs of the plot is used.</p> <code>None</code> <code>polygon_no_fill</code> <code>bool</code> <p>If True, the polygons are plotted without fill.</p> <code>False</code> <code>kwargs_geopandas_plot</code> <code>Optional[Any]</code> <p>Defaults to None. Keyword arguments for geopandas.plot</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Defaults to None. Title of the plot.</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>plt.Axes:</p> Source code in <code>georeader/plot.py</code> <pre><code>def add_shape_to_plot(shape:Union[gpd.GeoDataFrame, List[Geometry], Geometry], ax:Optional[plt.Axes]=None,\n                      crs_plot:Optional[Any]=None,\n                      crs_shape:Optional[Any]=None,\n                      polygon_no_fill:bool=False,\n                      kwargs_geopandas_plot:Optional[Any]=None,\n                      title:Optional[str]=None) -&gt; plt.Axes:\n    \"\"\"\n    Adds a shape to a plot. It uses geopandas.plot.\n\n    Args:\n        shape (Union[gpd.GeoDataFrame, List[Geometry], Geometry]): geodata to plot\n        ax (Optional[plt.Axes], optional): Defaults to None. Axes to plot the shape\n        crs_plot (Optional[Any], optional): Defaults to None. crs to plot the shape. If None, the crs of the shape is used.\n        crs_shape (Optional[Any], optional): Defaults to None. crs of the shape. If None, the crs of the plot is used.\n        polygon_no_fill: If True, the polygons are plotted without fill.\n        kwargs_geopandas_plot (Optional[Any], optional): Defaults to None. Keyword arguments for geopandas.plot\n        title (Optional[str], optional): Defaults to None. Title of the plot.\n\n    Returns:\n        plt.Axes: \n    \"\"\"\n    if not isinstance(shape, gpd.GeoDataFrame):\n        if isinstance(shape, Geometry):\n            shape = [shape]\n        shape = gpd.GeoDataFrame(geometry=shape,crs=crs_shape if crs_shape is not None else crs_plot)\n\n    if crs_plot is not None:\n        shape = shape.to_crs(crs_plot)\n\n    # if color is not None:\n    #     if not isinstance(color, str):\n    #         assert len(color) == shape.shape[0], \"The length of color array must be the same as the number of shapes\"\n\n    #     color = pd.Series(color, index=shape.index)\n\n    if ax is None:\n        ax = plt.gca()\n\n    if kwargs_geopandas_plot is None:\n        kwargs_geopandas_plot = {}\n\n    if polygon_no_fill:\n        shape.boundary.plot(ax=ax, **kwargs_geopandas_plot)\n    else:\n        shape.plot(ax=ax, **kwargs_geopandas_plot)\n\n    if title is not None:\n        ax.set_title(title)\n\n    # if legend and color is not None:\n    #     color_unique = color.unique()\n    #     legend_elements = [Patch(facecolor=color_unique,  label=c) for c in color_unique]\n    #     ax.legend(handles=legend_elements)\n\n    return ax\n</code></pre>"},{"location":"modules/rasterio_reader/","title":"RasterioReader","text":""},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader","title":"<code>RasterioReader</code>","text":"<p>Class to read a raster or a set of rasters files (<code>paths</code>). If the path is a single file it will return a 3D np.ndarray  with shape (C, H, W). If <code>paths</code> is a list, the <code>read</code> method will return a 4D np.ndarray with shape (len(paths), C, H, W)</p> <p>It checks that all rasters have same CRS, transform and shape. The <code>read</code> method will open the file every time it is called to work in parallel processing scenario.</p>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader--parameters","title":"Parameters","text":"<ul> <li>paths : <code>Union[List[str], str]</code>     Single path or list of paths of the rasters to read.</li> <li>allow_different_shape : <code>bool</code>     If True, will allow different shapes to be read (still checks that all rasters have same CRS,     transform and number of bands).</li> <li>window_focus : <code>Optional[rasterio.windows.Window]</code>     Window to read from. If provided, all windows in read call will be relative to this window.</li> <li>fill_value_default : <code>Optional[Union[int, float]]</code>     Value to fill when boundless read. It defaults to nodata if it is not None, otherwise it will be     set to zero.</li> <li>stack : <code>bool</code>     If <code>True</code>, returns 4D tensors; otherwise, it returns 3D tensors concatenated over the first dim. If      paths is string this argument is ignored and will be set to False (3D tensor).</li> <li>indexes : <code>Optional[List[int]]</code>     If not None, it will read from each raster only the specified bands. This argument is 1-based as in rasterio.</li> <li>overview_level : <code>Optional[int]</code>     If not None, it will read from the corresponding pyramid level. This argument is 0-based as in rasterio     (None -&gt; default resolution and 0 is the first overview).</li> <li>check : <code>bool</code>     Check all paths are OK.</li> <li>rio_env_options : <code>Optional[Dict[str, str]]</code>     GDAL options for reading. Defaults to: <code>RIO_ENV_OPTIONS_DEFAULT</code>. If you read rasters that might change     from a remote source, you might want to set <code>read_with_CPL_VSIL_CURL_NON_CACHED</code> to True.</li> </ul>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader--attributes","title":"Attributes","text":"<ul> <li>crs : <code>rasterio.crs.CRS</code>     Coordinate reference system.</li> <li>transform : <code>rasterio.Affine</code>     Transform of the rasters. If <code>window_focus</code> is provided, this transform will be relative to the window.</li> <li>dtype : <code>str</code>     Type of the input.</li> <li>count : <code>int</code>     Number of bands of the rasters.</li> <li>nodata : <code>Optional[Union[int, float]]</code>     Nodata value of the first raster in paths.</li> <li>fill_value_default : <code>Union[int, float]</code>     Value to fill when boundless read. Defaults to nodata.</li> <li>res : <code>Tuple[float, float]</code>     Resolution of the rasters.</li> <li>width : <code>int</code>     Width of the rasters. If <code>window_focus</code> is not None, this will be the width of the window.</li> <li>height : <code>int</code>     Height of the rasters. If <code>window_focus</code> is not None, this will be the height of the window.</li> <li>bounds : <code>Tuple[float, float, float, float]</code>     Bounds of the rasters. If <code>window_focus</code> is provided, these bounds will be relative to the window.</li> <li>dims : <code>List[str]</code>     Name of the dims (to make it compatible with xr.DataArray functions).</li> <li>attrs : <code>Dict[str, Any]</code>     Dictionary to store extra attributes.</li> </ul> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>class RasterioReader:\n    \"\"\"\n    Class to read a raster or a set of rasters files (``paths``). If the path is a single file it will return a 3D np.ndarray \n    with shape (C, H, W). If `paths` is a list, the `read` method will return a 4D np.ndarray with shape (len(paths), C, H, W)\n\n    It checks that all rasters have same CRS, transform and shape. The `read` method will open the file every time it\n    is called to work in parallel processing scenario.\n\n    Parameters\n    -------------------\n\n    - paths : `Union[List[str], str]`\n        Single path or list of paths of the rasters to read.\n    - allow_different_shape : `bool`\n        If True, will allow different shapes to be read (still checks that all rasters have same CRS,\n        transform and number of bands).\n    - window_focus : `Optional[rasterio.windows.Window]`\n        Window to read from. If provided, all windows in read call will be relative to this window.\n    - fill_value_default : `Optional[Union[int, float]]`\n        Value to fill when boundless read. It defaults to nodata if it is not None, otherwise it will be\n        set to zero.\n    - stack : `bool`\n        If `True`, returns 4D tensors; otherwise, it returns 3D tensors concatenated over the first dim. If \n        paths is string this argument is ignored and will be set to False (3D tensor).\n    - indexes : `Optional[List[int]]`\n        If not None, it will read from each raster only the specified bands. This argument is 1-based as in rasterio.\n    - overview_level : `Optional[int]`\n        If not None, it will read from the corresponding pyramid level. This argument is 0-based as in rasterio\n        (None -&gt; default resolution and 0 is the first overview).\n    - check : `bool`\n        Check all paths are OK.\n    - rio_env_options : `Optional[Dict[str, str]]`\n        GDAL options for reading. Defaults to: `RIO_ENV_OPTIONS_DEFAULT`. If you read rasters that might change\n        from a remote source, you might want to set `read_with_CPL_VSIL_CURL_NON_CACHED` to True.\n\n    Attributes\n    -------------------\n\n    - crs : `rasterio.crs.CRS`\n        Coordinate reference system.\n    - transform : `rasterio.Affine`\n        Transform of the rasters. If `window_focus` is provided, this transform will be relative to the window.\n    - dtype : `str`\n        Type of the input.\n    - count : `int`\n        Number of bands of the rasters.\n    - nodata : `Optional[Union[int, float]]`\n        Nodata value of the first raster in paths.\n    - fill_value_default : `Union[int, float]`\n        Value to fill when boundless read. Defaults to nodata.\n    - res : `Tuple[float, float]`\n        Resolution of the rasters.\n    - width : `int`\n        Width of the rasters. If `window_focus` is not None, this will be the width of the window.\n    - height : `int`\n        Height of the rasters. If `window_focus` is not None, this will be the height of the window.\n    - bounds : `Tuple[float, float, float, float]`\n        Bounds of the rasters. If `window_focus` is provided, these bounds will be relative to the window.\n    - dims : `List[str]`\n        Name of the dims (to make it compatible with xr.DataArray functions).\n    - attrs : `Dict[str, Any]`\n        Dictionary to store extra attributes.\n    \"\"\"\n    def __init__(self, paths:Union[List[str], str], allow_different_shape:bool=False,\n                 window_focus:Optional[rasterio.windows.Window]=None,\n                 fill_value_default:Optional[Union[int, float]]=None,\n                 stack:bool=True, indexes:Optional[List[int]]=None,\n                 overview_level:Optional[int]=None, check:bool=True,\n                 rio_env_options:Optional[Dict[str, str]]=None):\n\n        # Syntactic sugar\n        if isinstance(paths, str):\n            paths = [paths]\n            stack = False\n\n        if rio_env_options is None:\n            self.rio_env_options = RIO_ENV_OPTIONS_DEFAULT\n        else:\n            self.rio_env_options = rio_env_options\n\n        self.paths = paths\n\n        self.stack = stack\n\n        # TODO keep just a global nodata of size (T,C,) and fill with these values?\n        self.fill_value_default = fill_value_default\n        self.overview_level = overview_level\n        with rasterio.Env(**self._get_rio_options_path(paths[0])):\n            with rasterio.open(paths[0], \"r\", overview_level=overview_level) as src:\n                self.real_transform = src.transform\n                self.crs = src.crs\n                self.dtype = src.profile[\"dtype\"]\n                self.real_count = src.count\n                self.real_indexes = list(range(1, self.real_count + 1))\n                if self.stack:\n                    self.real_shape = (len(self.paths), src.count,) + src.shape\n                else:\n                    self.real_shape = (len(self.paths) * self.real_count, ) + src.shape\n\n                self.real_width = src.width\n                self.real_height = src.height\n\n                self.nodata = src.nodata\n                if self.fill_value_default is None:\n                    self.fill_value_default = self.nodata if (self.nodata is not None) else 0\n\n                self.res = src.res\n\n        # if (abs(self.real_transform.b) &gt; 1e-6) or (abs(self.real_transform.d) &gt; 1e-6):\n        #     warnings.warn(f\"transform of {self.paths[0]} is not rectilinear {self.real_transform}. \"\n        #                   f\"The vast majority of the code expect rectilinear transforms. This transform \"\n        #                   f\"could cause unexpected behaviours\")\n\n        self.attrs = {}\n        self.window_focus = rasterio.windows.Window(row_off=0, col_off=0,\n                                                    width=self.real_width, height=self.real_height)\n        self.real_window = rasterio.windows.Window(row_off=0, col_off=0,\n                                                   width=self.real_width, height=self.real_height)\n        self.set_indexes(self.real_indexes, relative=False)\n        self.set_window(window_focus, relative=False)\n\n        self.allow_different_shape = allow_different_shape\n\n        if self.stack:\n            self.dims = [\"time\", \"band\", \"y\", \"x\"]\n        else:\n            self.dims = [\"band\", \"y\", \"x\"]\n\n        self._coords = None\n\n        # Assert all paths have same tranform and crs\n        #  (checking width and height will not be needed since we're reading with boundless option but I don't see the point to ignore it)\n        if check and len(self.paths) &gt; 1:\n            for p in self.paths:\n                with rasterio.Env(**self._get_rio_options_path(p)):\n                    with rasterio.open(p, \"r\", overview_level=overview_level) as src:\n                        if not src.transform.almost_equals(self.real_transform, 1e-6):\n                            raise ValueError(f\"Different transform in {self.paths[0]} and {p}: {self.real_transform} {src.transform}\")\n                        if not str(src.crs).lower() == str(self.crs).lower():\n                            raise ValueError(f\"Different CRS in {self.paths[0]} and {p}: {self.crs} {src.crs}\")\n                        if self.real_count != src.count:\n                            raise ValueError(f\"Different number of bands in {self.paths[0]} and {p} {self.real_count} {src.count}\")\n                        if src.nodata != self.nodata:\n                            warnings.warn(\n                                f\"Different nodata in {self.paths[0]} and {p}: {self.nodata} {src.nodata}. This might lead to unexpected behaviour\")\n\n                        if (self.real_width != src.width) or (self.real_height != src.height):\n                            if allow_different_shape:\n                                warnings.warn(f\"Different shape in {self.paths[0]} and {p}: ({self.real_height}, {self.real_width}) ({src.height}, {src.width}) Might lead to unexpected behaviour\")\n                            else:\n                                raise ValueError(f\"Different shape in {self.paths[0]} and {p}: ({self.real_height}, {self.real_width}) ({src.height}, {src.width})\")\n\n        self.check = check\n        if indexes is not None:\n            self.set_indexes(indexes)\n\n    def set_indexes(self, indexes:List[int], relative:bool=True)-&gt; None:\n        \"\"\"\n        Set the channels to read. This is useful for processing only some channels of the raster. The indexes\n        passed will be relative to self.indexes\n        Args:\n            indexes: 1-based array to mantain rasterio convention\n            relative: True means the indexes arg will be treated ad relative to the current self.indexes. If false\n                     it sets self.indexes = indexes (and update the count attribute)\n        Examples:\n            &gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\", indexes=[2,3,4]) # Read all bands except the first one.\n            &gt;&gt;&gt; r.set_indexes([2,3], relative=True) # will read bands 2 and 3 of the original raster\n        \"\"\"\n        if relative:\n            new_indexes = [self.indexes[idx - 1] for idx in indexes]\n        else:\n            new_indexes = indexes\n\n        # Check if indexes are valid\n        assert all((s &gt;= 1) and (s &lt;= self.real_count) for s in new_indexes), \\\n               f\"Indexes (1-based) out of real bounds current: {self.indexes} asked: {new_indexes} number of bands:{self.real_count}\"\n\n        self.indexes = new_indexes\n\n        assert all((s &gt;= 1) and (s &lt;= self.real_count) for s in\n                   self.indexes), f\"Indexes out of real bounds current: {self.indexes} asked: {indexes} number of bands:{self.real_count}\"\n\n        self.count = len(self.indexes)\n\n    def set_indexes_by_name(self, names:List[str]) -&gt; None:\n        \"\"\"\n        Function to set the indexes by the name of the band which is stored in the descriptions attribute\n\n        Args:\n            names: List of band names to read\n\n        Examples:\n            &gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\") # Read all bands except the first one.\n            &gt;&gt;&gt; # Assume r.descriptions = [\"B1\", \"B2\", \"B3\"]\n            &gt;&gt;&gt; r.set_indexes_by_name([\"B2\", \"B3\"])\n\n        \"\"\"\n        descriptions = self.descriptions\n        if len(self.paths) == 1:\n            if self.stack:\n                descriptions = descriptions[0]\n        else:\n            assert all(d == descriptions[0] for d in descriptions), \"There are tiffs with different names\"\n            descriptions = descriptions[0]\n\n        bands = [descriptions.index(b) + 1 for b in names]\n        self.set_indexes(bands, relative=False)\n\n    @property\n    def shape(self):\n        if self.stack:\n            return len(self.paths), self.count, self.height, self.width\n        return len(self.paths) * self.count, self.height, self.width\n\n    def same_extent(self, other:Union[GeoData,'RasterioReader'], precision:float=1e-3) -&gt; bool:\n        \"\"\"\n        Check if two GeoData objects have the same extent\n\n        Args:\n            other: GeoData object to compare\n            precision: precision to compare the bounds\n\n        Returns:\n            True if both objects have the same extent\n\n        \"\"\"\n        return same_extent(self, other, precision=precision)\n\n    def set_window(self, window_focus:Optional[rasterio.windows.Window] = None,\n                   relative:bool = True, boundless:bool=True)-&gt;None:\n        \"\"\"\n        Set window to read. This is useful for processing only some part of the raster. The windows passed as\n         arguments in the read calls will be relative to this window.\n\n        Args:\n            window_focus: rasterio window. If None will be set to the full raster tile\n            relative: provided window is relative to current self.window_focus\n            boundless: if boundless is false the windows that do not overlap the total raster will be\n                intersected.\n\n        Examples:\n            &gt;&gt;&gt; # Read the first 1000x1000 pixels of the raster\n            &gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\")\n            &gt;&gt;&gt; r.set_window(rasterio.windows.Window(col_off=0, row_off=0, width=1000, height=1000))\n            &gt;&gt;&gt; r.load() #  returns GeoTensor with shape (1, 1, 1000, 1000)\n\n        \"\"\"\n        if window_focus is None:\n            self.window_focus = rasterio.windows.Window(row_off=0, col_off=0,\n                                                        width=self.real_width, height=self.real_height)\n        elif relative:\n            self.window_focus = rasterio.windows.Window(col_off=window_focus.col_off + self.window_focus.col_off,\n                                                        row_off=window_focus.row_off + self.window_focus.row_off,\n                                                        height=window_focus.height, width=window_focus.width)\n        else:\n            self.window_focus = window_focus\n\n        if not boundless:\n            self.window_focus = rasterio.windows.intersection(self.real_window, self.window_focus)\n\n        self.height = self.window_focus.height\n        self.width = self.window_focus.width\n\n        self.bounds = window_bounds(self.window_focus, self.real_transform)\n        self.transform = rasterio.windows.transform(self.window_focus, self.real_transform)\n\n    def tags(self) -&gt; Union[List[Dict[str, str]], Dict[str, str]]:\n        \"\"\"\n        Returns a list with the tags for each tiff file.\n        If stack and len(self.paths) == 1 it returns just the dictionary of the tags\n\n        \"\"\"\n        tags = []\n        for i, p in enumerate(self.paths):\n            with rasterio.Env(**self._get_rio_options_path(p)):\n                with rasterio.open(p, mode=\"r\") as src:\n                    tags.append(src.tags())\n\n        if (not self.stack) and (len(tags) == 1):\n            return tags[0]\n\n        return tags\n\n    def _get_rio_options_path(self, path:str) -&gt; Dict[str, str]:\n        options = self.rio_env_options\n        if \"read_with_CPL_VSIL_CURL_NON_CACHED\" in options:\n            options = options.copy()\n            if options[\"read_with_CPL_VSIL_CURL_NON_CACHED\"]:\n                options[\"CPL_VSIL_CURL_NON_CACHED\"] = _vsi_path(path)\n            del options[\"read_with_CPL_VSIL_CURL_NON_CACHED\"]\n        return options\n\n    # This function does not work for e.g. returning the descriptions of the bands\n    # @contextmanager\n    # def _rio_open(self, path:str, mode:str=\"r\", overview_level:Optional[int]=None) -&gt; rasterio.DatasetReader:\n    #     with rasterio.Env(**self._get_rio_options_path(path)):\n    #         with rasterio.open(path, mode=mode, overview_level=overview_level) as src:\n    #             yield src\n\n    @property\n    def descriptions(self) -&gt; Union[List[List[str]], List[str]]:\n        \"\"\"\n        Returns a list with the descriptions for each tiff file. (This is usually the name of the bands of the raster)\n\n\n        Returns:\n            If `stack` it returns the flattened list of descriptions for each tiff file. If not `stack` it returns a list of lists.\n\n        Examples:\n            &gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\") # Raster with band names B1, B2, B3\n            &gt;&gt;&gt; r.descriptions # returns [\"B1\", \"B2\", \"B3\"]\n        \"\"\"\n        descriptions_all = []\n        for i, p in enumerate(self.paths):\n            with rasterio.Env(**self._get_rio_options_path(p)):\n                with rasterio.open(p) as src:\n                    desc = src.descriptions\n\n            if self.stack:\n                descriptions_all.append([desc[i-1] for i in self.indexes])\n            else:\n                descriptions_all.extend([desc[i-1] for i in self.indexes])\n\n        return descriptions_all\n\n    def read_from_window(self, window:rasterio.windows.Window, boundless:bool=True) -&gt; '__class__':\n        \"\"\"\n        Returns a new reader with window focus the window `window` relative to `self.window_focus`\n\n        Args:\n            window: rasterio.window.Window to read\n            boundless: if boundless is False if the window do not overlap the total raster  it will be\n                intersected.\n\n        Raises:\n            rasterio.windows.WindowError: if bounless is False and window does not intersects self.window_focus\n\n        Returns:\n            RasterioReader: New reader object\n        \"\"\"\n        rst_reader = RasterioReader(list(self.paths),\n                                    allow_different_shape=self.allow_different_shape,\n                                    window_focus=self.window_focus, \n                                    fill_value_default=self.fill_value_default,\n                                    stack=self.stack, \n                                    overview_level=self.overview_level,\n                                    check=False, \n                                    rio_env_options=self.rio_env_options)\n\n        rst_reader.set_window(window, relative=True, boundless=boundless)\n        rst_reader.set_indexes(self.indexes, relative=False)\n        return rst_reader\n\n    def isel(self, sel: Dict[str, Union[slice, List[int], int]], boundless:bool=True) -&gt; '__class__':\n        \"\"\"\n        Creates a copy of the current RasterioReader slicing the data with a given selection dict. This function\n        mimics ``xr.DataArray.isel()`` method.\n\n        Args:\n            sel: Dict of slices to slice the current reader\n            boundless: If `True` slices in \"x\" and \"y\" are boundless (i.e. negative means negative indexes rather than\n                values from the other side of the array as in numpy).\n\n        Returns:\n            Copy of the current reader\n\n        Examples:\n            &gt;&gt;&gt; r = RasterioReader([\"path/to/raster1.tif\", \"path/to/raster2.tif\"])\n            &gt;&gt;&gt; r.isel({\"time\": 0, \"band\": [0]}) # returns a reader with the first band of the first raster\n            &gt;&gt;&gt; r.isel({\"time\": slice(0, 1), \"band\": [0]}) # returns a reader with the first band of the first raster and second raster\n            &gt;&gt;&gt; r.isel({\"x\": slice(4000, 5000), \"band\": [0, 1]}) # returns a reader slicing the x axis from 4000 to 5000 and the first two bands\n        \"\"\"\n        for k in sel:\n            if k not in self.dims:\n                raise NotImplementedError(f\"Axis {k} not in dims: {self.dims}\")\n\n        stack = self.stack\n        if \"time\" in sel: # time allowed only if self.stack (would have raised error above)\n            if isinstance(sel[\"time\"], Iterable):\n                paths = [self.paths[i] for i in sel[\"time\"]]\n            elif isinstance(sel[\"time\"], slice):\n                paths = self.paths[sel[\"time\"]]\n            elif isinstance(sel[\"time\"], numbers.Number):\n                paths = [self.paths[sel[\"time\"]]]\n                stack = False\n            else:\n                raise NotImplementedError(f\"Don't know how to slice {sel['time']} in dim time\")\n        else:\n            paths = self.paths\n\n        # Band slicing\n        if \"band\" in sel:\n            if not self.stack:\n                # if `True` returns 4D tensors otherwise it returns 3D tensors concatenated over the first dim\n                assert (len(self.paths) == 1) or (len(self.indexes) == 1), f\"Dont know how to slice {self.paths} and {self.indexes}\"\n\n            if self.stack or (len(self.paths) == 1):\n                if isinstance(sel[\"band\"], Iterable):\n                    indexes = [self.indexes[i] for i in sel[\"band\"]] # indexes relative to current indexes\n                elif isinstance(sel[\"band\"], slice):\n                    indexes = self.indexes[sel[\"band\"]]\n                elif isinstance(sel[\"band\"], numbers.Number):\n                    raise NotImplementedError(f\"Slicing band with a single number is not supported (use a list)\")\n                else:\n                    raise NotImplementedError(f\"Don't know how to slice {sel['band']} in dim band\")\n            else:\n                indexes = self.indexes\n                # len(indexes) == 1 and not self.stack in this case band slicing correspond to paths\n                if isinstance(sel[\"band\"], Iterable):\n                    paths = [self.paths[i] for i in sel[\"band\"]]\n                elif isinstance(sel[\"band\"], slice):\n                    paths = self.paths[sel[\"band\"]]\n                elif isinstance(sel[\"band\"], numbers.Number):\n                    paths = [self.paths[sel[\"band\"]]]\n                else:\n                    raise NotImplementedError(f\"Don't know how to slice {sel['time']} in dim time\")\n        else:\n            indexes = self.indexes\n\n        # Spatial slicing\n        slice_ = []\n        spatial_shape = (self.height, self.width)\n        for _i, spatial_name in enumerate([\"y\", \"x\"]):\n            if spatial_name in sel:\n                if not isinstance(sel[spatial_name], slice):\n                    raise NotImplementedError(f\"spatial dimension {spatial_name} only accept slice objects\")\n                slice_.append(sel[spatial_name])\n            else:\n                slice_.append(slice(0, spatial_shape[_i]))\n\n        rst_reader = RasterioReader(paths, allow_different_shape=self.allow_different_shape,\n                                    window_focus=self.window_focus, \n                                    fill_value_default=self.fill_value_default,\n                                    stack=stack, overview_level=self.overview_level,\n                                    check=False,\n                                    rio_env_options=self.rio_env_options)\n        window_current = rasterio.windows.Window.from_slices(*slice_, boundless=boundless,\n                                                             width=self.width, height=self.height)\n\n        # Set bands to read\n        rst_reader.set_indexes(indexes=indexes, relative=False)\n\n        # set window_current relative to self.window_focus\n        rst_reader.set_window(window_current, relative=True)\n\n        return rst_reader\n\n    def __copy__(self) -&gt; '__class__':\n        rst = RasterioReader(self.paths, allow_different_shape=self.allow_different_shape,\n                              window_focus=self.window_focus, \n                              fill_value_default=self.fill_value_default,\n                              stack=self.stack, overview_level=self.overview_level,\n                              check=False, rio_env_options=self.rio_env_options)\n        rst.set_indexes(self.indexes, relative=False)\n        return rst\n\n    def overviews(self, index:int=1, time_index:int=0) -&gt; List[int]:\n        \"\"\"\n        Returns a list of the available overview levels for the current raster.\n        \"\"\"\n        with rasterio.Env(**self._get_rio_options_path(self.paths[time_index])):\n            with rasterio.open(self.paths[time_index]) as src:\n                return src.overviews(index)\n\n    def reader_overview(self, overview_level:int) -&gt; '__class__':\n        \"\"\"\n        Returns a new reader with the overview level specified.\n\n        Args:\n            overview_level (int): overview level to read. \n                If negative it will be relative to the last overview level\n                The higher the number the higher the resolution. -1 is the highest resolution \n                (which is the original one)\n\n        Returns:\n            RasterioReader: new reader with the overview level specified\n        \"\"\"\n        if overview_level &lt; 0:\n            overview_level = len(self.overviews()) + overview_level\n\n        rst = RasterioReader(self.paths, allow_different_shape=self.allow_different_shape,\n                             window_focus=None, \n                             fill_value_default=self.fill_value_default,\n                             stack=self.stack,\n                             indexes=self.indexes,\n                             overview_level=overview_level,\n                             check=False,\n                             rio_env_options=self.rio_env_options)\n\n        # if self.window_focus hasn't been changed we're good\n        if self.window_focus.width == self.real_width and\\\n            self.window_focus.height == self.real_height and\\\n            self.window_focus.col_off == 0 and\\\n            self.window_focus.row_off == 0:\n            return rst\n\n        # TODO we need to convert the self.window_focus to the dst crs\n        # window_utils.\n        warnings.warn(\"Window focus is not supported in overview level. Returning the overview level with the full raster\")\n        return rst\n\n    def block_windows(self, bidx:int=1, time_idx:int=0) -&gt; List[Tuple[int, rasterio.windows.Window]]:\n        \"\"\"\n        return the block windows within the object\n        (see https://rasterio.readthedocs.io/en/latest/api/rasterio.io.html#rasterio.io.DatasetReader.block_windows)\n\n        Args:\n            bidx: band index to read (1-based)\n            time_idx: time index to read (0-based)\n\n        Returns:\n            list of (block_idx, window)\n\n        \"\"\"\n        with rasterio.Env(**self._get_rio_options_path(self.paths[time_idx])):\n            with rasterio.open(self.paths[time_idx]) as src:\n                windows_return = [(block_idx, rasterio.windows.intersection(window, self.window_focus)) for block_idx, window in src.block_windows(bidx) if rasterio.windows.intersect(self.window_focus, window)]\n\n        return windows_return\n\n    def copy(self) -&gt; '__class__':\n        return self.__copy__()\n\n    def load(self, boundless:bool=True) -&gt; geotensor.GeoTensor:\n        \"\"\"\n        Load all raster in memory in an GeoTensor object\n\n        Returns:\n            GeoTensor (wrapper of numpy array with spatial information)\n\n        \"\"\"\n        np_data = self.read(boundless=boundless)\n        if boundless:\n            transform = self.transform\n        else:\n            # update transform, shape and coords\n            window = self.window_focus\n            start_col = max(window.col_off, 0)\n            end_col = min(window.col_off + window.width, self.real_width)\n            start_row = max(window.row_off, 0)\n            end_row = min(window.row_off + window.height, self.real_height)\n            spatial_shape = (end_row - start_row, end_col - start_col)\n            assert np_data.shape[-2:] == spatial_shape, f\"Different shapes {np_data.shape[-2:]} {spatial_shape}\"\n\n            window_real = rasterio.windows.Window(row_off=start_row, col_off=start_col,\n                                                  width=spatial_shape[1], height=spatial_shape[0])\n            transform = rasterio.windows.transform(window_real, self.real_transform)\n\n        return geotensor.GeoTensor(np_data, transform=transform, crs=self.crs, fill_value_default=self.fill_value_default)\n\n    @property\n    def values(self) -&gt; np.ndarray:\n        \"\"\"\n        This property is added to be consistent with xr.DataArray. It reads the whole raster in memory and returns it\n\n        Returns:\n            np.ndarray raster loaded in memory\n        \"\"\"\n        return self.read()\n\n    def footprint(self, crs:Optional[str]=None) -&gt; Polygon:\n        pol = window_utils.window_polygon(rasterio.windows.Window(row_off=0, col_off=0, height=self.shape[-2], width=self.shape[-1]),\n                                          self.transform)\n        if (crs is None) or window_utils.compare_crs(self.crs, crs):\n            return pol\n\n        return window_utils.polygon_to_crs(pol, self.crs, crs)\n\n    def meshgrid(self, dst_crs:Optional[Any]=None) -&gt; Tuple[NDArray, NDArray]:\n        from georeader import griddata\n        return griddata.meshgrid(self.transform, self.width, self.height, source_crs=self.crs, dst_crs=dst_crs)\n\n    def __repr__(self)-&gt;str:\n        return f\"\"\" \n         Paths: {self.paths}\n         Transform: {self.transform}\n         Shape: {self.shape}\n         Resolution: {self.res}\n         Bounds: {self.bounds}\n         CRS: {self.crs}\n         nodata: {self.nodata}\n         fill_value_default: {self.fill_value_default}\n        \"\"\"\n\n    def read(self, **kwargs) -&gt; np.ndarray:\n        \"\"\"\n        Read data from the list of rasters. It reads with boundless=True by default and\n        fill_value=self.fill_value_default by default.\n\n        This function is process safe (opens and closes the rasterio object every time is called).\n\n        For arguments see: https://rasterio.readthedocs.io/en/latest/api/rasterio.io.html#rasterio.io.DatasetReader.read\n\n        Returns:\n            if self.stack:\n                4D np.ndarray with shape (len(paths), C, H, W)\n            if self.stack is False:\n                3D np.ndarray with shape (len(paths)*C, H, W)\n        \"\"\"\n\n        if (\"window\" in kwargs) and kwargs[\"window\"] is not None:\n            window_read = kwargs[\"window\"]\n            if isinstance(window_read, tuple):\n                window_read = rasterio.windows.Window.from_slices(*window_read,\n                                                                  boundless=kwargs.get(\"boundless\", True))\n\n            # Windows are relative to the windows_focus window.\n            window = rasterio.windows.Window(col_off=window_read.col_off + self.window_focus.col_off,\n                                             row_off=window_read.row_off + self.window_focus.row_off,\n                                             height=window_read.height, width=window_read.width)\n        else:\n            window = self.window_focus\n\n        kwargs[\"window\"] = window\n\n        if \"boundless\" not in kwargs:\n            kwargs[\"boundless\"] = True\n\n        if not rasterio.windows.intersect([self.real_window, window]) and not kwargs[\"boundless\"]:\n            return None\n\n        if not kwargs[\"boundless\"]:\n            window = window.intersection(self.real_window)\n\n        if \"fill_value\" not in kwargs:\n            kwargs[\"fill_value\"] = self.fill_value_default\n\n        if  kwargs.get(\"indexes\", None) is not None:\n            # Indexes are relative to the self.indexes window.\n            indexes = kwargs[\"indexes\"]\n            if isinstance(indexes, numbers.Number):\n                n_bands_read = 1\n                kwargs[\"indexes\"] = [self.indexes[kwargs[\"indexes\"] - 1]]\n                flat_channels = True\n            else:\n                n_bands_read = len(indexes)\n                kwargs[\"indexes\"] = [self.indexes[i - 1] for i in kwargs[\"indexes\"]]\n                flat_channels = False\n        else:\n            kwargs[\"indexes\"] = self.indexes\n            n_bands_read = self.count\n            flat_channels = False\n\n        if kwargs.get(\"out_shape\", None) is not None:\n            if len(kwargs[\"out_shape\"]) == 2:\n                kwargs[\"out_shape\"] = (n_bands_read, ) + kwargs[\"out_shape\"]\n            elif len(kwargs[\"out_shape\"]) == 3:\n                assert kwargs[\"out_shape\"][0] == n_bands_read, f\"Expected to read {n_bands_read} but found out_shape: {kwargs['out_shape']}\"\n            else:\n                raise NotImplementedError(f\"Expected out_shape of len 2 or 3 found out_shape: {kwargs['out_shape']}\")\n            spatial_shape = kwargs[\"out_shape\"][1:]\n        else:\n            spatial_shape = (window.height, window.width)\n\n        shape = (len(self.paths), n_bands_read) + spatial_shape\n\n        obj_out = np.full(shape, kwargs[\"fill_value\"], dtype=self.dtype)\n        if rasterio.windows.intersect([self.real_window, window]):\n            pad = None\n            if kwargs[\"boundless\"]:\n                slice_, pad = get_slice_pad(self.real_window, window)\n                need_pad = any(x != 0 for x in pad[\"x\"] + pad[\"y\"])\n\n                #  read and pad instead of using boundless attribute when transform is not rectilinear (otherwise rasterio fails!)\n                if (abs(self.real_transform.b) &gt; 1e-6) or (abs(self.real_transform.d) &gt; 1e-6):\n                    if need_pad:\n                        assert kwargs.get(\"out_shape\", None) is None, \"out_shape not compatible with boundless and non rectilinear transform!\"\n                        kwargs[\"window\"] = rasterio.windows.Window.from_slices(slice_[\"y\"], slice_[\"x\"])\n                        kwargs[\"boundless\"] = False\n                    else:\n                        kwargs[\"boundless\"] = False\n                else:\n                    #  if transform is rectilinear read boundless if needed\n                    kwargs[\"boundless\"] = need_pad\n                    pad = None\n\n            for i, p in enumerate(self.paths):\n                with rasterio.Env(**self._get_rio_options_path(p)):\n                    with rasterio.open(p, \"r\", overview_level=self.overview_level) as src:\n                    # rasterio.read API: https://rasterio.readthedocs.io/en/latest/api/rasterio.io.html#rasterio.io.DatasetReader.read\n                        read_data = src.read(**kwargs)\n\n                        # Add pad when reading\n                        if pad is not None and need_pad:\n                            slice_y = slice(pad[\"y\"][0], -pad[\"y\"][1] if pad[\"y\"][1] !=0 else None)\n                            slice_x = slice(pad[\"x\"][0], -pad[\"x\"][1] if pad[\"x\"][1] !=0 else None)\n                            obj_out[i, :, slice_y, slice_x] = read_data\n                        else:\n                            obj_out[i] = read_data\n                        # pad_list_np = _get_pad_list(pad)\n                    #\n                    # read_data = np.pad(read_data, tuple(pad_list_np), mode=\"constant\",\n                    #                    constant_values=self.fill_value_default)\n\n\n\n        if flat_channels:\n            obj_out = obj_out[:, 0]\n\n        if not self.stack:\n            if obj_out.shape[0] == 1:\n                obj_out = obj_out[0]\n            else:\n                obj_out = np.concatenate([obj_out[i] for i in range(obj_out.shape[0])],\n                                         axis=0)\n\n        return obj_out\n\n    def read_from_tile(self, x:int, y:int, z:int, \n                       out_shape:Tuple[int,int]=(SIZE_DEFAULT, SIZE_DEFAULT),\n                       dst_crs:Optional[Any]=WEB_MERCATOR_CRS) -&gt; geotensor.GeoTensor:\n        \"\"\"\n        Read a web mercator tile from a raster.\n\n        Tiles are TMS tiles defined as: (https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames)\n\n        Args:\n            x (int): x coordinate of the tile in the TMS system.\n            y (int): y coordinate of the tile in the TMS system.\n            z (int): z coordinate of the tile in the TMS system.\n            out_shape (Tuple[int,int]: size of the tile to read. Defaults to (read.SIZE_DEFAULT, read.SIZE_DEFAULT).\n            dst_crs (Optional[Any], optional): CRS of the output tile. Defaults to read.WEB_MERCATOR_CRS.\n\n        Returns:\n            geotensor.GeoTensor: geotensor with the tile data.\n        \"\"\"\n        window = window_from_tile(self, x, y, z)\n        window = window_utils.round_outer_window(window)\n        data = read_out_shape(self, out_shape=out_shape, window=window)\n\n        if window_utils.compare_crs(self.crs, dst_crs):\n            return data\n\n        # window = window_utils.pad_window(window, (1, 1))\n        # data = read_out_shape(self, out_shape=size_out, window=window)\n\n        return read_from_tile(data, x, y, z, dst_crs=dst_crs, out_shape=out_shape)\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.descriptions","title":"<code>descriptions: Union[List[List[str]], List[str]]</code>  <code>property</code>","text":"<p>Returns a list with the descriptions for each tiff file. (This is usually the name of the bands of the raster)</p> <p>Returns:</p> Type Description <code>Union[List[List[str]], List[str]]</code> <p>If <code>stack</code> it returns the flattened list of descriptions for each tiff file. If not <code>stack</code> it returns a list of lists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\") # Raster with band names B1, B2, B3\n&gt;&gt;&gt; r.descriptions # returns [\"B1\", \"B2\", \"B3\"]\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.values","title":"<code>values: np.ndarray</code>  <code>property</code>","text":"<p>This property is added to be consistent with xr.DataArray. It reads the whole raster in memory and returns it</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray raster loaded in memory</p>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.block_windows","title":"<code>block_windows(bidx=1, time_idx=0)</code>","text":"<p>return the block windows within the object (see https://rasterio.readthedocs.io/en/latest/api/rasterio.io.html#rasterio.io.DatasetReader.block_windows)</p> <p>Parameters:</p> Name Type Description Default <code>bidx</code> <code>int</code> <p>band index to read (1-based)</p> <code>1</code> <code>time_idx</code> <code>int</code> <p>time index to read (0-based)</p> <code>0</code> <p>Returns:</p> Type Description <code>List[Tuple[int, Window]]</code> <p>list of (block_idx, window)</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def block_windows(self, bidx:int=1, time_idx:int=0) -&gt; List[Tuple[int, rasterio.windows.Window]]:\n    \"\"\"\n    return the block windows within the object\n    (see https://rasterio.readthedocs.io/en/latest/api/rasterio.io.html#rasterio.io.DatasetReader.block_windows)\n\n    Args:\n        bidx: band index to read (1-based)\n        time_idx: time index to read (0-based)\n\n    Returns:\n        list of (block_idx, window)\n\n    \"\"\"\n    with rasterio.Env(**self._get_rio_options_path(self.paths[time_idx])):\n        with rasterio.open(self.paths[time_idx]) as src:\n            windows_return = [(block_idx, rasterio.windows.intersection(window, self.window_focus)) for block_idx, window in src.block_windows(bidx) if rasterio.windows.intersect(self.window_focus, window)]\n\n    return windows_return\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.isel","title":"<code>isel(sel, boundless=True)</code>","text":"<p>Creates a copy of the current RasterioReader slicing the data with a given selection dict. This function mimics <code>xr.DataArray.isel()</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>sel</code> <code>Dict[str, Union[slice, List[int], int]]</code> <p>Dict of slices to slice the current reader</p> required <code>boundless</code> <code>bool</code> <p>If <code>True</code> slices in \"x\" and \"y\" are boundless (i.e. negative means negative indexes rather than values from the other side of the array as in numpy).</p> <code>True</code> <p>Returns:</p> Type Description <code>__class__</code> <p>Copy of the current reader</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; r = RasterioReader([\"path/to/raster1.tif\", \"path/to/raster2.tif\"])\n&gt;&gt;&gt; r.isel({\"time\": 0, \"band\": [0]}) # returns a reader with the first band of the first raster\n&gt;&gt;&gt; r.isel({\"time\": slice(0, 1), \"band\": [0]}) # returns a reader with the first band of the first raster and second raster\n&gt;&gt;&gt; r.isel({\"x\": slice(4000, 5000), \"band\": [0, 1]}) # returns a reader slicing the x axis from 4000 to 5000 and the first two bands\n</code></pre> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def isel(self, sel: Dict[str, Union[slice, List[int], int]], boundless:bool=True) -&gt; '__class__':\n    \"\"\"\n    Creates a copy of the current RasterioReader slicing the data with a given selection dict. This function\n    mimics ``xr.DataArray.isel()`` method.\n\n    Args:\n        sel: Dict of slices to slice the current reader\n        boundless: If `True` slices in \"x\" and \"y\" are boundless (i.e. negative means negative indexes rather than\n            values from the other side of the array as in numpy).\n\n    Returns:\n        Copy of the current reader\n\n    Examples:\n        &gt;&gt;&gt; r = RasterioReader([\"path/to/raster1.tif\", \"path/to/raster2.tif\"])\n        &gt;&gt;&gt; r.isel({\"time\": 0, \"band\": [0]}) # returns a reader with the first band of the first raster\n        &gt;&gt;&gt; r.isel({\"time\": slice(0, 1), \"band\": [0]}) # returns a reader with the first band of the first raster and second raster\n        &gt;&gt;&gt; r.isel({\"x\": slice(4000, 5000), \"band\": [0, 1]}) # returns a reader slicing the x axis from 4000 to 5000 and the first two bands\n    \"\"\"\n    for k in sel:\n        if k not in self.dims:\n            raise NotImplementedError(f\"Axis {k} not in dims: {self.dims}\")\n\n    stack = self.stack\n    if \"time\" in sel: # time allowed only if self.stack (would have raised error above)\n        if isinstance(sel[\"time\"], Iterable):\n            paths = [self.paths[i] for i in sel[\"time\"]]\n        elif isinstance(sel[\"time\"], slice):\n            paths = self.paths[sel[\"time\"]]\n        elif isinstance(sel[\"time\"], numbers.Number):\n            paths = [self.paths[sel[\"time\"]]]\n            stack = False\n        else:\n            raise NotImplementedError(f\"Don't know how to slice {sel['time']} in dim time\")\n    else:\n        paths = self.paths\n\n    # Band slicing\n    if \"band\" in sel:\n        if not self.stack:\n            # if `True` returns 4D tensors otherwise it returns 3D tensors concatenated over the first dim\n            assert (len(self.paths) == 1) or (len(self.indexes) == 1), f\"Dont know how to slice {self.paths} and {self.indexes}\"\n\n        if self.stack or (len(self.paths) == 1):\n            if isinstance(sel[\"band\"], Iterable):\n                indexes = [self.indexes[i] for i in sel[\"band\"]] # indexes relative to current indexes\n            elif isinstance(sel[\"band\"], slice):\n                indexes = self.indexes[sel[\"band\"]]\n            elif isinstance(sel[\"band\"], numbers.Number):\n                raise NotImplementedError(f\"Slicing band with a single number is not supported (use a list)\")\n            else:\n                raise NotImplementedError(f\"Don't know how to slice {sel['band']} in dim band\")\n        else:\n            indexes = self.indexes\n            # len(indexes) == 1 and not self.stack in this case band slicing correspond to paths\n            if isinstance(sel[\"band\"], Iterable):\n                paths = [self.paths[i] for i in sel[\"band\"]]\n            elif isinstance(sel[\"band\"], slice):\n                paths = self.paths[sel[\"band\"]]\n            elif isinstance(sel[\"band\"], numbers.Number):\n                paths = [self.paths[sel[\"band\"]]]\n            else:\n                raise NotImplementedError(f\"Don't know how to slice {sel['time']} in dim time\")\n    else:\n        indexes = self.indexes\n\n    # Spatial slicing\n    slice_ = []\n    spatial_shape = (self.height, self.width)\n    for _i, spatial_name in enumerate([\"y\", \"x\"]):\n        if spatial_name in sel:\n            if not isinstance(sel[spatial_name], slice):\n                raise NotImplementedError(f\"spatial dimension {spatial_name} only accept slice objects\")\n            slice_.append(sel[spatial_name])\n        else:\n            slice_.append(slice(0, spatial_shape[_i]))\n\n    rst_reader = RasterioReader(paths, allow_different_shape=self.allow_different_shape,\n                                window_focus=self.window_focus, \n                                fill_value_default=self.fill_value_default,\n                                stack=stack, overview_level=self.overview_level,\n                                check=False,\n                                rio_env_options=self.rio_env_options)\n    window_current = rasterio.windows.Window.from_slices(*slice_, boundless=boundless,\n                                                         width=self.width, height=self.height)\n\n    # Set bands to read\n    rst_reader.set_indexes(indexes=indexes, relative=False)\n\n    # set window_current relative to self.window_focus\n    rst_reader.set_window(window_current, relative=True)\n\n    return rst_reader\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.load","title":"<code>load(boundless=True)</code>","text":"<p>Load all raster in memory in an GeoTensor object</p> <p>Returns:</p> Type Description <code>GeoTensor</code> <p>GeoTensor (wrapper of numpy array with spatial information)</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def load(self, boundless:bool=True) -&gt; geotensor.GeoTensor:\n    \"\"\"\n    Load all raster in memory in an GeoTensor object\n\n    Returns:\n        GeoTensor (wrapper of numpy array with spatial information)\n\n    \"\"\"\n    np_data = self.read(boundless=boundless)\n    if boundless:\n        transform = self.transform\n    else:\n        # update transform, shape and coords\n        window = self.window_focus\n        start_col = max(window.col_off, 0)\n        end_col = min(window.col_off + window.width, self.real_width)\n        start_row = max(window.row_off, 0)\n        end_row = min(window.row_off + window.height, self.real_height)\n        spatial_shape = (end_row - start_row, end_col - start_col)\n        assert np_data.shape[-2:] == spatial_shape, f\"Different shapes {np_data.shape[-2:]} {spatial_shape}\"\n\n        window_real = rasterio.windows.Window(row_off=start_row, col_off=start_col,\n                                              width=spatial_shape[1], height=spatial_shape[0])\n        transform = rasterio.windows.transform(window_real, self.real_transform)\n\n    return geotensor.GeoTensor(np_data, transform=transform, crs=self.crs, fill_value_default=self.fill_value_default)\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.overviews","title":"<code>overviews(index=1, time_index=0)</code>","text":"<p>Returns a list of the available overview levels for the current raster.</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def overviews(self, index:int=1, time_index:int=0) -&gt; List[int]:\n    \"\"\"\n    Returns a list of the available overview levels for the current raster.\n    \"\"\"\n    with rasterio.Env(**self._get_rio_options_path(self.paths[time_index])):\n        with rasterio.open(self.paths[time_index]) as src:\n            return src.overviews(index)\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.read","title":"<code>read(**kwargs)</code>","text":"<p>Read data from the list of rasters. It reads with boundless=True by default and fill_value=self.fill_value_default by default.</p> <p>This function is process safe (opens and closes the rasterio object every time is called).</p> <p>For arguments see: https://rasterio.readthedocs.io/en/latest/api/rasterio.io.html#rasterio.io.DatasetReader.read</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>if self.stack: 4D np.ndarray with shape (len(paths), C, H, W)</p> <code>ndarray</code> <p>if self.stack is False: 3D np.ndarray with shape (len(paths)*C, H, W)</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def read(self, **kwargs) -&gt; np.ndarray:\n    \"\"\"\n    Read data from the list of rasters. It reads with boundless=True by default and\n    fill_value=self.fill_value_default by default.\n\n    This function is process safe (opens and closes the rasterio object every time is called).\n\n    For arguments see: https://rasterio.readthedocs.io/en/latest/api/rasterio.io.html#rasterio.io.DatasetReader.read\n\n    Returns:\n        if self.stack:\n            4D np.ndarray with shape (len(paths), C, H, W)\n        if self.stack is False:\n            3D np.ndarray with shape (len(paths)*C, H, W)\n    \"\"\"\n\n    if (\"window\" in kwargs) and kwargs[\"window\"] is not None:\n        window_read = kwargs[\"window\"]\n        if isinstance(window_read, tuple):\n            window_read = rasterio.windows.Window.from_slices(*window_read,\n                                                              boundless=kwargs.get(\"boundless\", True))\n\n        # Windows are relative to the windows_focus window.\n        window = rasterio.windows.Window(col_off=window_read.col_off + self.window_focus.col_off,\n                                         row_off=window_read.row_off + self.window_focus.row_off,\n                                         height=window_read.height, width=window_read.width)\n    else:\n        window = self.window_focus\n\n    kwargs[\"window\"] = window\n\n    if \"boundless\" not in kwargs:\n        kwargs[\"boundless\"] = True\n\n    if not rasterio.windows.intersect([self.real_window, window]) and not kwargs[\"boundless\"]:\n        return None\n\n    if not kwargs[\"boundless\"]:\n        window = window.intersection(self.real_window)\n\n    if \"fill_value\" not in kwargs:\n        kwargs[\"fill_value\"] = self.fill_value_default\n\n    if  kwargs.get(\"indexes\", None) is not None:\n        # Indexes are relative to the self.indexes window.\n        indexes = kwargs[\"indexes\"]\n        if isinstance(indexes, numbers.Number):\n            n_bands_read = 1\n            kwargs[\"indexes\"] = [self.indexes[kwargs[\"indexes\"] - 1]]\n            flat_channels = True\n        else:\n            n_bands_read = len(indexes)\n            kwargs[\"indexes\"] = [self.indexes[i - 1] for i in kwargs[\"indexes\"]]\n            flat_channels = False\n    else:\n        kwargs[\"indexes\"] = self.indexes\n        n_bands_read = self.count\n        flat_channels = False\n\n    if kwargs.get(\"out_shape\", None) is not None:\n        if len(kwargs[\"out_shape\"]) == 2:\n            kwargs[\"out_shape\"] = (n_bands_read, ) + kwargs[\"out_shape\"]\n        elif len(kwargs[\"out_shape\"]) == 3:\n            assert kwargs[\"out_shape\"][0] == n_bands_read, f\"Expected to read {n_bands_read} but found out_shape: {kwargs['out_shape']}\"\n        else:\n            raise NotImplementedError(f\"Expected out_shape of len 2 or 3 found out_shape: {kwargs['out_shape']}\")\n        spatial_shape = kwargs[\"out_shape\"][1:]\n    else:\n        spatial_shape = (window.height, window.width)\n\n    shape = (len(self.paths), n_bands_read) + spatial_shape\n\n    obj_out = np.full(shape, kwargs[\"fill_value\"], dtype=self.dtype)\n    if rasterio.windows.intersect([self.real_window, window]):\n        pad = None\n        if kwargs[\"boundless\"]:\n            slice_, pad = get_slice_pad(self.real_window, window)\n            need_pad = any(x != 0 for x in pad[\"x\"] + pad[\"y\"])\n\n            #  read and pad instead of using boundless attribute when transform is not rectilinear (otherwise rasterio fails!)\n            if (abs(self.real_transform.b) &gt; 1e-6) or (abs(self.real_transform.d) &gt; 1e-6):\n                if need_pad:\n                    assert kwargs.get(\"out_shape\", None) is None, \"out_shape not compatible with boundless and non rectilinear transform!\"\n                    kwargs[\"window\"] = rasterio.windows.Window.from_slices(slice_[\"y\"], slice_[\"x\"])\n                    kwargs[\"boundless\"] = False\n                else:\n                    kwargs[\"boundless\"] = False\n            else:\n                #  if transform is rectilinear read boundless if needed\n                kwargs[\"boundless\"] = need_pad\n                pad = None\n\n        for i, p in enumerate(self.paths):\n            with rasterio.Env(**self._get_rio_options_path(p)):\n                with rasterio.open(p, \"r\", overview_level=self.overview_level) as src:\n                # rasterio.read API: https://rasterio.readthedocs.io/en/latest/api/rasterio.io.html#rasterio.io.DatasetReader.read\n                    read_data = src.read(**kwargs)\n\n                    # Add pad when reading\n                    if pad is not None and need_pad:\n                        slice_y = slice(pad[\"y\"][0], -pad[\"y\"][1] if pad[\"y\"][1] !=0 else None)\n                        slice_x = slice(pad[\"x\"][0], -pad[\"x\"][1] if pad[\"x\"][1] !=0 else None)\n                        obj_out[i, :, slice_y, slice_x] = read_data\n                    else:\n                        obj_out[i] = read_data\n                    # pad_list_np = _get_pad_list(pad)\n                #\n                # read_data = np.pad(read_data, tuple(pad_list_np), mode=\"constant\",\n                #                    constant_values=self.fill_value_default)\n\n\n\n    if flat_channels:\n        obj_out = obj_out[:, 0]\n\n    if not self.stack:\n        if obj_out.shape[0] == 1:\n            obj_out = obj_out[0]\n        else:\n            obj_out = np.concatenate([obj_out[i] for i in range(obj_out.shape[0])],\n                                     axis=0)\n\n    return obj_out\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.read_from_tile","title":"<code>read_from_tile(x, y, z, out_shape=(SIZE_DEFAULT, SIZE_DEFAULT), dst_crs=WEB_MERCATOR_CRS)</code>","text":"<p>Read a web mercator tile from a raster.</p> <p>Tiles are TMS tiles defined as: (https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>x coordinate of the tile in the TMS system.</p> required <code>y</code> <code>int</code> <p>y coordinate of the tile in the TMS system.</p> required <code>z</code> <code>int</code> <p>z coordinate of the tile in the TMS system.</p> required <code>out_shape</code> <code>Tuple[int, int]</code> <p>size of the tile to read. Defaults to (read.SIZE_DEFAULT, read.SIZE_DEFAULT).</p> <code>(SIZE_DEFAULT, SIZE_DEFAULT)</code> <code>dst_crs</code> <code>Optional[Any]</code> <p>CRS of the output tile. Defaults to read.WEB_MERCATOR_CRS.</p> <code>WEB_MERCATOR_CRS</code> <p>Returns:</p> Type Description <code>GeoTensor</code> <p>geotensor.GeoTensor: geotensor with the tile data.</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def read_from_tile(self, x:int, y:int, z:int, \n                   out_shape:Tuple[int,int]=(SIZE_DEFAULT, SIZE_DEFAULT),\n                   dst_crs:Optional[Any]=WEB_MERCATOR_CRS) -&gt; geotensor.GeoTensor:\n    \"\"\"\n    Read a web mercator tile from a raster.\n\n    Tiles are TMS tiles defined as: (https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames)\n\n    Args:\n        x (int): x coordinate of the tile in the TMS system.\n        y (int): y coordinate of the tile in the TMS system.\n        z (int): z coordinate of the tile in the TMS system.\n        out_shape (Tuple[int,int]: size of the tile to read. Defaults to (read.SIZE_DEFAULT, read.SIZE_DEFAULT).\n        dst_crs (Optional[Any], optional): CRS of the output tile. Defaults to read.WEB_MERCATOR_CRS.\n\n    Returns:\n        geotensor.GeoTensor: geotensor with the tile data.\n    \"\"\"\n    window = window_from_tile(self, x, y, z)\n    window = window_utils.round_outer_window(window)\n    data = read_out_shape(self, out_shape=out_shape, window=window)\n\n    if window_utils.compare_crs(self.crs, dst_crs):\n        return data\n\n    # window = window_utils.pad_window(window, (1, 1))\n    # data = read_out_shape(self, out_shape=size_out, window=window)\n\n    return read_from_tile(data, x, y, z, dst_crs=dst_crs, out_shape=out_shape)\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.read_from_window","title":"<code>read_from_window(window, boundless=True)</code>","text":"<p>Returns a new reader with window focus the window <code>window</code> relative to <code>self.window_focus</code></p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>Window</code> <p>rasterio.window.Window to read</p> required <code>boundless</code> <code>bool</code> <p>if boundless is False if the window do not overlap the total raster  it will be intersected.</p> <code>True</code> <p>Raises:</p> Type Description <code>WindowError</code> <p>if bounless is False and window does not intersects self.window_focus</p> <p>Returns:</p> Name Type Description <code>RasterioReader</code> <code>__class__</code> <p>New reader object</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def read_from_window(self, window:rasterio.windows.Window, boundless:bool=True) -&gt; '__class__':\n    \"\"\"\n    Returns a new reader with window focus the window `window` relative to `self.window_focus`\n\n    Args:\n        window: rasterio.window.Window to read\n        boundless: if boundless is False if the window do not overlap the total raster  it will be\n            intersected.\n\n    Raises:\n        rasterio.windows.WindowError: if bounless is False and window does not intersects self.window_focus\n\n    Returns:\n        RasterioReader: New reader object\n    \"\"\"\n    rst_reader = RasterioReader(list(self.paths),\n                                allow_different_shape=self.allow_different_shape,\n                                window_focus=self.window_focus, \n                                fill_value_default=self.fill_value_default,\n                                stack=self.stack, \n                                overview_level=self.overview_level,\n                                check=False, \n                                rio_env_options=self.rio_env_options)\n\n    rst_reader.set_window(window, relative=True, boundless=boundless)\n    rst_reader.set_indexes(self.indexes, relative=False)\n    return rst_reader\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.reader_overview","title":"<code>reader_overview(overview_level)</code>","text":"<p>Returns a new reader with the overview level specified.</p> <p>Parameters:</p> Name Type Description Default <code>overview_level</code> <code>int</code> <p>overview level to read.  If negative it will be relative to the last overview level The higher the number the higher the resolution. -1 is the highest resolution  (which is the original one)</p> required <p>Returns:</p> Name Type Description <code>RasterioReader</code> <code>__class__</code> <p>new reader with the overview level specified</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def reader_overview(self, overview_level:int) -&gt; '__class__':\n    \"\"\"\n    Returns a new reader with the overview level specified.\n\n    Args:\n        overview_level (int): overview level to read. \n            If negative it will be relative to the last overview level\n            The higher the number the higher the resolution. -1 is the highest resolution \n            (which is the original one)\n\n    Returns:\n        RasterioReader: new reader with the overview level specified\n    \"\"\"\n    if overview_level &lt; 0:\n        overview_level = len(self.overviews()) + overview_level\n\n    rst = RasterioReader(self.paths, allow_different_shape=self.allow_different_shape,\n                         window_focus=None, \n                         fill_value_default=self.fill_value_default,\n                         stack=self.stack,\n                         indexes=self.indexes,\n                         overview_level=overview_level,\n                         check=False,\n                         rio_env_options=self.rio_env_options)\n\n    # if self.window_focus hasn't been changed we're good\n    if self.window_focus.width == self.real_width and\\\n        self.window_focus.height == self.real_height and\\\n        self.window_focus.col_off == 0 and\\\n        self.window_focus.row_off == 0:\n        return rst\n\n    # TODO we need to convert the self.window_focus to the dst crs\n    # window_utils.\n    warnings.warn(\"Window focus is not supported in overview level. Returning the overview level with the full raster\")\n    return rst\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.same_extent","title":"<code>same_extent(other, precision=0.001)</code>","text":"<p>Check if two GeoData objects have the same extent</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[GeoData, RasterioReader]</code> <p>GeoData object to compare</p> required <code>precision</code> <code>float</code> <p>precision to compare the bounds</p> <code>0.001</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if both objects have the same extent</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def same_extent(self, other:Union[GeoData,'RasterioReader'], precision:float=1e-3) -&gt; bool:\n    \"\"\"\n    Check if two GeoData objects have the same extent\n\n    Args:\n        other: GeoData object to compare\n        precision: precision to compare the bounds\n\n    Returns:\n        True if both objects have the same extent\n\n    \"\"\"\n    return same_extent(self, other, precision=precision)\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.set_indexes","title":"<code>set_indexes(indexes, relative=True)</code>","text":"<p>Set the channels to read. This is useful for processing only some channels of the raster. The indexes passed will be relative to self.indexes Args:     indexes: 1-based array to mantain rasterio convention     relative: True means the indexes arg will be treated ad relative to the current self.indexes. If false              it sets self.indexes = indexes (and update the count attribute) Examples:     &gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\", indexes=[2,3,4]) # Read all bands except the first one.     &gt;&gt;&gt; r.set_indexes([2,3], relative=True) # will read bands 2 and 3 of the original raster</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def set_indexes(self, indexes:List[int], relative:bool=True)-&gt; None:\n    \"\"\"\n    Set the channels to read. This is useful for processing only some channels of the raster. The indexes\n    passed will be relative to self.indexes\n    Args:\n        indexes: 1-based array to mantain rasterio convention\n        relative: True means the indexes arg will be treated ad relative to the current self.indexes. If false\n                 it sets self.indexes = indexes (and update the count attribute)\n    Examples:\n        &gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\", indexes=[2,3,4]) # Read all bands except the first one.\n        &gt;&gt;&gt; r.set_indexes([2,3], relative=True) # will read bands 2 and 3 of the original raster\n    \"\"\"\n    if relative:\n        new_indexes = [self.indexes[idx - 1] for idx in indexes]\n    else:\n        new_indexes = indexes\n\n    # Check if indexes are valid\n    assert all((s &gt;= 1) and (s &lt;= self.real_count) for s in new_indexes), \\\n           f\"Indexes (1-based) out of real bounds current: {self.indexes} asked: {new_indexes} number of bands:{self.real_count}\"\n\n    self.indexes = new_indexes\n\n    assert all((s &gt;= 1) and (s &lt;= self.real_count) for s in\n               self.indexes), f\"Indexes out of real bounds current: {self.indexes} asked: {indexes} number of bands:{self.real_count}\"\n\n    self.count = len(self.indexes)\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.set_indexes_by_name","title":"<code>set_indexes_by_name(names)</code>","text":"<p>Function to set the indexes by the name of the band which is stored in the descriptions attribute</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>List[str]</code> <p>List of band names to read</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\") # Read all bands except the first one.\n&gt;&gt;&gt; # Assume r.descriptions = [\"B1\", \"B2\", \"B3\"]\n&gt;&gt;&gt; r.set_indexes_by_name([\"B2\", \"B3\"])\n</code></pre> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def set_indexes_by_name(self, names:List[str]) -&gt; None:\n    \"\"\"\n    Function to set the indexes by the name of the band which is stored in the descriptions attribute\n\n    Args:\n        names: List of band names to read\n\n    Examples:\n        &gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\") # Read all bands except the first one.\n        &gt;&gt;&gt; # Assume r.descriptions = [\"B1\", \"B2\", \"B3\"]\n        &gt;&gt;&gt; r.set_indexes_by_name([\"B2\", \"B3\"])\n\n    \"\"\"\n    descriptions = self.descriptions\n    if len(self.paths) == 1:\n        if self.stack:\n            descriptions = descriptions[0]\n    else:\n        assert all(d == descriptions[0] for d in descriptions), \"There are tiffs with different names\"\n        descriptions = descriptions[0]\n\n    bands = [descriptions.index(b) + 1 for b in names]\n    self.set_indexes(bands, relative=False)\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.set_window","title":"<code>set_window(window_focus=None, relative=True, boundless=True)</code>","text":"<p>Set window to read. This is useful for processing only some part of the raster. The windows passed as  arguments in the read calls will be relative to this window.</p> <p>Parameters:</p> Name Type Description Default <code>window_focus</code> <code>Optional[Window]</code> <p>rasterio window. If None will be set to the full raster tile</p> <code>None</code> <code>relative</code> <code>bool</code> <p>provided window is relative to current self.window_focus</p> <code>True</code> <code>boundless</code> <code>bool</code> <p>if boundless is false the windows that do not overlap the total raster will be intersected.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Read the first 1000x1000 pixels of the raster\n&gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\")\n&gt;&gt;&gt; r.set_window(rasterio.windows.Window(col_off=0, row_off=0, width=1000, height=1000))\n&gt;&gt;&gt; r.load() #  returns GeoTensor with shape (1, 1, 1000, 1000)\n</code></pre> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def set_window(self, window_focus:Optional[rasterio.windows.Window] = None,\n               relative:bool = True, boundless:bool=True)-&gt;None:\n    \"\"\"\n    Set window to read. This is useful for processing only some part of the raster. The windows passed as\n     arguments in the read calls will be relative to this window.\n\n    Args:\n        window_focus: rasterio window. If None will be set to the full raster tile\n        relative: provided window is relative to current self.window_focus\n        boundless: if boundless is false the windows that do not overlap the total raster will be\n            intersected.\n\n    Examples:\n        &gt;&gt;&gt; # Read the first 1000x1000 pixels of the raster\n        &gt;&gt;&gt; r = RasterioReader(\"path/to/raster.tif\")\n        &gt;&gt;&gt; r.set_window(rasterio.windows.Window(col_off=0, row_off=0, width=1000, height=1000))\n        &gt;&gt;&gt; r.load() #  returns GeoTensor with shape (1, 1, 1000, 1000)\n\n    \"\"\"\n    if window_focus is None:\n        self.window_focus = rasterio.windows.Window(row_off=0, col_off=0,\n                                                    width=self.real_width, height=self.real_height)\n    elif relative:\n        self.window_focus = rasterio.windows.Window(col_off=window_focus.col_off + self.window_focus.col_off,\n                                                    row_off=window_focus.row_off + self.window_focus.row_off,\n                                                    height=window_focus.height, width=window_focus.width)\n    else:\n        self.window_focus = window_focus\n\n    if not boundless:\n        self.window_focus = rasterio.windows.intersection(self.real_window, self.window_focus)\n\n    self.height = self.window_focus.height\n    self.width = self.window_focus.width\n\n    self.bounds = window_bounds(self.window_focus, self.real_transform)\n    self.transform = rasterio.windows.transform(self.window_focus, self.real_transform)\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.RasterioReader.tags","title":"<code>tags()</code>","text":"<p>Returns a list with the tags for each tiff file. If stack and len(self.paths) == 1 it returns just the dictionary of the tags</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def tags(self) -&gt; Union[List[Dict[str, str]], Dict[str, str]]:\n    \"\"\"\n    Returns a list with the tags for each tiff file.\n    If stack and len(self.paths) == 1 it returns just the dictionary of the tags\n\n    \"\"\"\n    tags = []\n    for i, p in enumerate(self.paths):\n        with rasterio.Env(**self._get_rio_options_path(p)):\n            with rasterio.open(p, mode=\"r\") as src:\n                tags.append(src.tags())\n\n    if (not self.stack) and (len(tags) == 1):\n        return tags[0]\n\n    return tags\n</code></pre>"},{"location":"modules/rasterio_reader/#georeader.rasterio_reader.read_out_shape","title":"<code>read_out_shape(reader, size_read=None, indexes=None, window=None, out_shape=None, fill_value_default=0)</code>","text":"<p>Reads data using the <code>out_shape</code> param of rasterio. This allows to read from the pyramids if the file is a COG. This function returns an xarray with the data with its geographic metadata.</p> <p>Parameters:</p> Name Type Description Default <code>reader</code> <code>Union[RasterioReader, DatasetReader]</code> <p>RasterioReader, rasterio.DatasetReader</p> required <code>size_read</code> <code>Optional[int]</code> <p>if out_shape is None it uses this to compute the size to read that maintains the aspect ratio</p> <code>None</code> <code>indexes</code> <code>Optional[Union[List[int], int]]</code> <p>1-based channels to read</p> <code>None</code> <code>window</code> <code>Optional[Window]</code> <p>window to read</p> <code>None</code> <code>out_shape</code> <code>Optional[Tuple[int, int]]</code> <p>shape of the output to be readed. Conceptually, the function resizes the output to this shape</p> <code>None</code> <code>fill_value_default</code> <code>int</code> <p>if the object is rasterio.DatasetReader and nodata is None it will use this value for the corresponding GeoTensor</p> <code>0</code> <p>Returns:</p> Type Description <code>GeoTensor</code> <p>GeoTensor with geo metadata</p> Source code in <code>georeader/rasterio_reader.py</code> <pre><code>def read_out_shape(reader:Union[RasterioReader, rasterio.DatasetReader],\n                   size_read:Optional[int]=None,\n                   indexes:Optional[Union[List[int], int]]=None,\n                   window:Optional[rasterio.windows.Window]=None,\n                   out_shape:Optional[Tuple[int, int]]=None,\n                   fill_value_default:int=0) -&gt; geotensor.GeoTensor:\n    \"\"\"\n    Reads data using the `out_shape` param of rasterio. This allows to read from the pyramids if the file is a COG.\n    This function returns an xarray with the data with its geographic metadata.\n\n    Args:\n        reader: RasterioReader, rasterio.DatasetReader\n        size_read: if out_shape is None it uses this to compute the size to read that maintains the aspect ratio\n        indexes: 1-based channels to read\n        window: window to read\n        out_shape: shape of the output to be readed. Conceptually, the function resizes the output to this shape\n        fill_value_default: if the object is rasterio.DatasetReader and nodata is None it will use this value for the\n            corresponding GeoTensor\n\n    Returns:\n        GeoTensor with geo metadata\n\n    \"\"\"\n\n    if window is None:\n        shape = reader.shape[-2:]\n    else:\n        shape = window.height, window.width\n\n    if out_shape is None:\n        assert size_read is not None, f\"Both out_shape and size_read are None\"\n        out_shape = get_out_shape(shape, size_read)\n    else:\n        assert len(out_shape) == 2, f\"Expected 2 dimensions found {out_shape}\"\n\n    transform = reader.transform if window is None else rasterio.windows.transform(window, reader.transform)\n\n    if (indexes is not None) and isinstance(indexes, (list, tuple)):\n        if len(out_shape) == 2:\n            out_shape = (len(indexes),) + out_shape\n\n    input_output_factor = (shape[0] / out_shape[-2], shape[1] / out_shape[-1])    \n    transform = transform * rasterio.Affine.scale(input_output_factor[1], input_output_factor[0])\n\n    output = reader.read(indexes=indexes, out_shape=out_shape, window=window)\n\n    return geotensor.GeoTensor(output, transform=transform,\n                               crs=reader.crs, fill_value_default=getattr(reader, \"fill_value_default\",\n                                                                          reader.nodata if reader.nodata else fill_value_default))\n</code></pre>"},{"location":"modules/rasterize_module/","title":"rasterize","text":""},{"location":"modules/rasterize_module/#georeader.rasterize.rasterize_from_geometry","title":"<code>rasterize_from_geometry(geometry, bounds=None, transform=None, resolution=None, window_out=None, value=1, dtype=np.uint8, crs_geom_bounds=None, fill=0, all_touched=False, return_only_data=False)</code>","text":"<p>Rasterise the provided geometry over the bounds with the specified resolution, transform, shape and crs.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Union[Polygon, MultiPolygon, LineString]</code> <p>geometry to rasterise (with crs <code>crs_geom_bounds</code>)</p> required <code>bounds</code> <code>Optional[Tuple[float, float, float, float]]</code> <p>bounds where the polygons will be rasterised. (with crs <code>crs_geom_bounds</code>)</p> <code>None</code> <code>transform</code> <code>Optional[Affine]</code> <p>if transform is provided it will use this instead of <code>resolution</code> (with crs <code>crs_geom_bounds</code>)</p> <code>None</code> <code>resolution</code> <code>Optional[Union[float, Tuple[float, float]]]</code> <p>spatial resolution of the rasterised array. It won't be used if transform is provided (with crs <code>crs_geom_bounds</code>)</p> <code>None</code> <code>window_out</code> <code>Optional[Window]</code> <p>Window out in <code>crs_geom_bounds</code>. If not provided it is computed from the bounds.</p> <code>None</code> <code>value</code> <code>Number</code> <p>column to take the values for rasterisation.</p> <code>1</code> <code>dtype</code> <code>Any</code> <p>dtype of the rasterise raster.</p> <code>uint8</code> <code>crs_geom_bounds</code> <code>Optional[Any]</code> <p>CRS of geometry and bounds</p> <code>None</code> <code>fill</code> <code>Union[int, float]</code> <p>fill option for <code>rasterio.features.rasterize</code>. Value for pixels not covered by the geometries.</p> <code>0</code> <code>all_touched</code> <code>bool</code> <p>all_touched option for <code>rasterio.features.rasterize</code>. If True, all pixels touched  by geometries will be burned in.  If false, only pixels whose center is within the polygon or that are selected by Bresenham's line algorithm will be burned in.</p> <code>False</code> <code>return_only_data</code> <code>bool</code> <p>if <code>True</code> returns only the np.ndarray without georref info.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, ndarray]</code> <p><code>GeoTensor</code> or <code>np.ndarray</code> with shape <code>(H, W)</code> with the rasterised polygon</p> Source code in <code>georeader/rasterize.py</code> <pre><code>def rasterize_from_geometry(geometry:Union[Polygon, MultiPolygon, LineString],\n                            bounds:Optional[Tuple[float, float, float, float]]=None,\n                            transform:Optional[rasterio.Affine]=None,\n                            resolution:Optional[Union[float, Tuple[float, float]]]=None,\n                            window_out:Optional[rasterio.windows.Window]=None,\n                            value:Number=1,\n                            dtype:Any=np.uint8,\n                            crs_geom_bounds:Optional[Any]=None, fill:Union[int, float]=0, all_touched:bool=False,\n                            return_only_data:bool=False)-&gt; Union[GeoTensor, np.ndarray]:\n    \"\"\"\n    Rasterise the provided geometry over the bounds with the specified resolution, transform, shape and crs.\n\n    Args:\n        geometry: geometry to rasterise (with crs `crs_geom_bounds`)\n        bounds: bounds where the polygons will be rasterised. (with crs `crs_geom_bounds`)\n        transform: if transform is provided it will use this instead of `resolution` (with crs `crs_geom_bounds`)\n        resolution: spatial resolution of the rasterised array. It won't be used if transform is provided (with crs `crs_geom_bounds`)\n        window_out: Window out in `crs_geom_bounds`. If not provided it is computed from the bounds.\n        value: column to take the values for rasterisation.\n        dtype: dtype of the rasterise raster.\n        crs_geom_bounds: CRS of geometry and bounds\n        fill: fill option for `rasterio.features.rasterize`. Value for pixels not covered by the geometries.\n        all_touched: all_touched option for `rasterio.features.rasterize`. If True, all pixels touched \n            by geometries will be burned in.  If false, only pixels whose center is within the polygon or that\n            are selected by Bresenham's line algorithm will be burned in.\n        return_only_data: if `True` returns only the np.ndarray without georref info.\n\n    Returns:\n        `GeoTensor` or `np.ndarray` with shape `(H, W)` with the rasterised polygon\n    \"\"\"\n\n    transform = window_utils.figure_out_transform(transform=transform, bounds=bounds,\n                                                  resolution_dst=resolution)\n    if window_out is None:\n        window_out = rasterio.windows.from_bounds(*bounds,\n                                                  transform=transform).round_lengths(op=\"ceil\",\n                                                                                     pixel_precision=PIXEL_PRECISION)\n\n\n    chip_label = rasterio.features.rasterize(shapes=[(geometry, value)],\n                                             out_shape=(window_out.height, window_out.width),\n                                             transform=transform,\n                                             dtype=dtype,\n                                             fill=fill,\n                                             all_touched=all_touched)\n    if return_only_data:\n        return chip_label\n\n    return GeoTensor(chip_label, transform=transform, crs=crs_geom_bounds, fill_value_default=fill)\n</code></pre>"},{"location":"modules/rasterize_module/#georeader.rasterize.rasterize_from_geopandas","title":"<code>rasterize_from_geopandas(dataframe, column, bounds=None, transform=None, window_out=None, resolution=None, crs_out=None, fill=0, all_touched=False, return_only_data=False)</code>","text":"<p>Rasterise the provided geodataframe over the bounds with the specified resolution.</p> <p>Parameters:</p> Name Type Description Default <code>dataframe</code> <code>GeoDataFrame</code> <p><code>GeoDataFrame</code> with columns <code>geometry</code> and <code>column</code>.  The 'geometry' column is expected to have shapely geometries.</p> required <code>bounds</code> <code>Optional[Tuple[float, float, float, float]]</code> <p>bounds where the polygons will be rasterised with CRS <code>crs_out</code>.</p> <code>None</code> <code>transform</code> <code>Optional[Affine]</code> <p>if transform is provided if will use this for the resolution.</p> <code>None</code> <code>resolution</code> <code>Optional[Union[float, Tuple[float, float]]]</code> <p>spatial resolution of the rasterised array</p> <code>None</code> <code>window_out</code> <code>Optional[Window]</code> <p>Window out in <code>crs_geom_bounds</code>. If not provided it is computed from the bounds.</p> <code>None</code> <code>column</code> <code>str</code> <p>column to take the values for rasterisation.</p> required <code>crs_out</code> <code>Optional[Any]</code> <p>defaults to dataframe.crs. This function will transform the geometries from dataframe.crs to this crs before rasterisation. <code>bounds</code> are in this crs.</p> <code>None</code> <code>fill</code> <code>Union[int, float]</code> <p>fill option for <code>rasterio.features.rasterize</code>. Value for pixels not covered by the geometries.</p> <code>0</code> <code>all_touched</code> <code>bool</code> <p>all_touched option for <code>rasterio.features.rasterize</code>. If True, all pixels touched  by geometries will be burned in.  If false, only pixels whose center is within the polygon or that are selected by Bresenham's line algorithm will be burned in.</p> <code>False</code> <code>return_only_data</code> <code>bool</code> <p>if <code>True</code> returns only the <code>np.ndarray</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, ndarray]</code> <p><code>GeoTensor</code> or <code>np.ndarray</code> with shape <code>(H, W)</code> with the rasterised polygons of the dataframe</p> Source code in <code>georeader/rasterize.py</code> <pre><code>def rasterize_from_geopandas(dataframe:gpd.GeoDataFrame,\n                             column:str,\n                             bounds:Optional[Tuple[float, float, float, float]]=None,\n                             transform:Optional[rasterio.Affine]=None,\n                             window_out:Optional[rasterio.windows.Window]=None,\n                             resolution:Optional[Union[float, Tuple[float, float]]]=None,\n                             crs_out:Optional[Any]=None, fill:Union[int, float]=0, all_touched:bool=False,\n                             return_only_data:bool=False) -&gt; Union[GeoTensor, np.ndarray]:\n    \"\"\"\n    Rasterise the provided geodataframe over the bounds with the specified resolution.\n\n    Args:\n        dataframe: `GeoDataFrame` with columns `geometry` and `column`. \n            The 'geometry' column is expected to have shapely geometries.\n        bounds: bounds where the polygons will be rasterised with CRS `crs_out`.\n        transform: if transform is provided if will use this for the resolution.\n        resolution: spatial resolution of the rasterised array\n        window_out: Window out in `crs_geom_bounds`. If not provided it is computed from the bounds.\n        column: column to take the values for rasterisation.\n        crs_out: defaults to dataframe.crs. This function will transform the geometries from dataframe.crs to this crs\n            before rasterisation. `bounds` are in this crs.\n        fill: fill option for `rasterio.features.rasterize`. Value for pixels not covered by the geometries.\n        all_touched: all_touched option for `rasterio.features.rasterize`. If True, all pixels touched \n            by geometries will be burned in.  If false, only pixels whose center is within the polygon or that\n            are selected by Bresenham's line algorithm will be burned in.\n        return_only_data: if `True` returns only the `np.ndarray`.\n\n    Returns:\n        `GeoTensor` or `np.ndarray` with shape `(H, W)` with the rasterised polygons of the dataframe\n    \"\"\"\n\n    if crs_out is None:\n        crs_out = str(dataframe.crs).lower()\n    else:\n        data_crs = str(dataframe.crs).lower()\n        crs_out = str(crs_out).lower().replace(\"+init=\",\"\")\n        if data_crs != crs_out:\n            dataframe = dataframe.to_crs(crs=crs_out)\n\n    transform = window_utils.figure_out_transform(transform=transform, bounds=bounds,\n                                                  resolution_dst=resolution)\n    if window_out is None:\n        window_out = rasterio.windows.from_bounds(*bounds,\n                                                  transform=transform).round_lengths(op=\"ceil\",\n                                                                                     pixel_precision=PIXEL_PRECISION)\n\n    dtype = dataframe[column].dtype\n    chip_label = rasterio.features.rasterize(shapes=zip(dataframe.geometry, dataframe[column]),\n                                             out_shape=(window_out.height, window_out.width),\n                                             transform=transform,\n                                             dtype=dtype,\n                                             fill=fill,\n                                             all_touched=all_touched)\n    if return_only_data:\n        return chip_label\n\n    return GeoTensor(chip_label, transform=transform, crs=crs_out, fill_value_default=fill)\n</code></pre>"},{"location":"modules/rasterize_module/#georeader.rasterize.rasterize_geometry_like","title":"<code>rasterize_geometry_like(geometry, data_like, value=1, dtype=np.uint8, crs_geometry=None, fill=0, all_touched=False, return_only_data=False)</code>","text":"<p>Rasterise the <code>geometry</code> to the same extent and resolution as defined <code>data_like</code> GeoData object.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Union[Polygon, MultiPolygon, LineString]</code> <p>geometry to rasterise</p> required <code>data_like</code> <code>GeoData</code> <p>geoData to use transform, bounds and crs for rasterisation. Output raster will have the same extent, resolution, crs and shape as this object.</p> required <code>value</code> <code>Number</code> <p>value to use in the points within the geometry</p> <code>1</code> <code>dtype</code> <code>Any</code> <p>dtype of the rasterised raster.</p> <code>uint8</code> <code>crs_geometry</code> <code>Optional[Any]</code> <p>CRS of geometry</p> <code>None</code> <code>fill</code> <code>Union[int, float]</code> <p>fill option for <code>rasterio.features.rasterize</code>. Value for pixels not covered by the geometries.</p> <code>0</code> <code>all_touched</code> <code>bool</code> <p>all_touched option for <code>rasterio.features.rasterize</code>. If True, all pixels touched  by geometries will be burned in.  If false, only pixels whose center is within the polygon or that are selected by Bresenham's line algorithm will be burned in.</p> <code>False</code> <code>return_only_data</code> <code>bool</code> <p>if <code>True</code> returns only the <code>np.ndarray</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, ndarray]</code> <p><code>GeoTensor</code> or <code>np.ndarray</code> with shape <code>(H, W)</code> with the rasterised polygon</p> Source code in <code>georeader/rasterize.py</code> <pre><code>def rasterize_geometry_like(geometry:Union[Polygon, MultiPolygon, LineString], \n                            data_like: GeoData, value:Number=1,\n                            dtype:Any=np.uint8,\n                            crs_geometry:Optional[Any]=None, fill:Union[int, float]=0, all_touched:bool=False,\n                            return_only_data:bool=False)-&gt; Union[GeoTensor, np.ndarray]:\n    \"\"\"\n    Rasterise the `geometry` to the same extent and resolution as defined `data_like` GeoData object.\n\n    Args:\n        geometry: geometry to rasterise\n        data_like: geoData to use transform, bounds and crs for rasterisation. Output\n            raster will have the same extent, resolution, crs and shape as this object.\n        value: value to use in the points within the geometry\n        dtype: dtype of the rasterised raster.\n        crs_geometry: CRS of geometry\n        fill: fill option for `rasterio.features.rasterize`. Value for pixels not covered by the geometries.\n        all_touched: all_touched option for `rasterio.features.rasterize`. If True, all pixels touched \n            by geometries will be burned in.  If false, only pixels whose center is within the polygon or that\n            are selected by Bresenham's line algorithm will be burned in.\n        return_only_data: if `True` returns only the `np.ndarray`.\n\n    Returns:\n        `GeoTensor` or `np.ndarray` with shape `(H, W)` with the rasterised polygon\n    \"\"\"\n    shape_out = data_like.shape\n    if crs_geometry and not window_utils.compare_crs(data_like.crs, crs_geometry):\n        geometry = window_utils.polygon_to_crs(geometry, crs_geometry, data_like.crs)\n\n    return rasterize_from_geometry(geometry, crs_geom_bounds=data_like.crs,\n                                   transform=data_like.transform,\n                                   window_out=rasterio.windows.Window(0, 0, width=shape_out[-1], height=shape_out[-2]),\n                                   return_only_data=return_only_data,dtype=dtype, value=value,\n                                   fill=fill, all_touched=all_touched)\n</code></pre>"},{"location":"modules/rasterize_module/#georeader.rasterize.rasterize_geopandas_like","title":"<code>rasterize_geopandas_like(dataframe, data_like, column, fill=0, all_touched=False, return_only_data=False)</code>","text":"<p>Rasterise the geodataframe to the same extent and resolution as defined <code>data_like</code> GeoData object</p> <p>Parameters:</p> Name Type Description Default <code>dataframe</code> <code>GeoDataFrame</code> <p><code>GeoDataFrame</code> with columns <code>geometry</code> and <code>column</code>.  The 'geometry' column is expected to have shapely geometries.</p> required <code>data_like</code> <code>GeoData</code> <p>geoData to use transform, bounds and crs for rasterisation</p> required <code>column</code> <code>str</code> <p>column to take the values for rasterisation.</p> required <code>fill</code> <code>Union[int, float]</code> <p>fill option for <code>rasterio.features.rasterize</code>. Value for pixels not covered by the geometries.</p> <code>0</code> <code>all_touched</code> <code>bool</code> <p>all_touched option for <code>rasterio.features.rasterize</code>. If True, all pixels touched  by geometries will be burned in.  If false, only pixels whose center is within the polygon or that are selected by Bresenham's line algorithm will be burned in.</p> <code>False</code> <code>return_only_data</code> <code>bool</code> <p>if <code>True</code> returns only the <code>np.ndarray</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, ndarray]</code> <p><code>GeoTensor</code> or <code>np.ndarray</code> with shape (H, W) with the rasterised polygons of the dataframe</p> Source code in <code>georeader/rasterize.py</code> <pre><code>def rasterize_geopandas_like(dataframe:gpd.GeoDataFrame,data_like: GeoData, column:str,\n                             fill:Union[int, float]=0, all_touched:bool=False,\n                             return_only_data:bool=False)-&gt; Union[GeoTensor, np.ndarray]:\n    \"\"\"\n    Rasterise the geodataframe to the same extent and resolution as defined `data_like` GeoData object\n\n    Args:\n        dataframe: `GeoDataFrame` with columns `geometry` and `column`. \n            The 'geometry' column is expected to have shapely geometries.\n        data_like: geoData to use transform, bounds and crs for rasterisation\n        column: column to take the values for rasterisation.\n        fill: fill option for `rasterio.features.rasterize`. Value for pixels not covered by the geometries.\n        all_touched: all_touched option for `rasterio.features.rasterize`. If True, all pixels touched \n            by geometries will be burned in.  If false, only pixels whose center is within the polygon or that\n            are selected by Bresenham's line algorithm will be burned in.\n        return_only_data: if `True` returns only the `np.ndarray`.\n\n    Returns:\n        `GeoTensor` or `np.ndarray` with shape (H, W) with the rasterised polygons of the dataframe\n\n    \"\"\"\n\n    shape_out = data_like.shape\n    return rasterize_from_geopandas(dataframe, column=column,\n                                    crs_out=data_like.crs,\n                                    transform=data_like.transform,\n                                    window_out=rasterio.windows.Window(0, 0, width=shape_out[-1], height=shape_out[-2]),\n                                    return_only_data=return_only_data,\n                                    fill=fill, all_touched=all_touched)\n</code></pre>"},{"location":"modules/read_module/","title":"Geospatial Data Reading and Manipulation","text":""},{"location":"modules/read_module/#protocols","title":"Protocols","text":"<p>The <code>georeader</code> package uses two main protocols to define interfaces for geospatial data:</p>"},{"location":"modules/read_module/#geodatabase-protocol","title":"GeoDataBase Protocol","text":"<p>This is the minimal interface required for geospatial operations. Window methods require objects implementing this protocol as input. Any class implementing this protocol provides basic spatial information:</p> <ul> <li><code>transform</code>: A rasterio.Affine object defining the spatial transform</li> <li><code>crs</code>: Coordinate reference system</li> <li><code>shape</code>: The shape of the data array</li> <li><code>width</code>: Width of the data (shape[-1])</li> <li><code>height</code>: Height of the data (shape[-2])</li> </ul>"},{"location":"modules/read_module/#geodata-protocol","title":"GeoData Protocol","text":"<p>This extends the <code>GeoDataBase</code> protocol with methods for data access. Read methods require objects implementing this protocol as inputs. Classes implementing the <code>GeoData</code> protocol must have the following methods and properties:</p> <ul> <li>All properties from <code>GeoDataBase</code></li> <li><code>load(boundless: bool = True) -&gt; GeoTensor</code>: Loads data into memory</li> <li><code>read_from_window(window, boundless) -&gt; Union[Self, GeoTensor]</code>: Reads data from a window</li> <li><code>values</code>: Returns the data array</li> <li><code>res</code>: Resolution (tuple of x and y resolution)</li> <li><code>dtype</code>: Data type</li> <li><code>dims</code>: Dimension names</li> <li><code>fill_value_default</code>: Fill value for missing data</li> <li><code>bounds</code>: Data bounds</li> <li><code>footprint(crs: Optional[str] = None) -&gt; Polygon</code>: Returns the footprint as a polygon</li> </ul>"},{"location":"modules/read_module/#implementations","title":"Implementations","text":"<p>The library provides the following implementations of the <code>GeoData</code> protocol:</p> <ol> <li>GeoTensor: A numpy-based implementation for in-memory operations.</li> <li>RasterioReader: An implementation for lazy-loading with <code>rasterio</code>.</li> <li>readers.*: Custom readers for official data formats of several satellite missions (Sentinel-2, Proba-V, SpotVGT, EMIT, PRISMA or EnMAP).</li> </ol>"},{"location":"modules/read_module/#window-and-read-methods","title":"Window and Read Methods","text":"<p>The API provides two types of methods:</p>"},{"location":"modules/read_module/#window-methods","title":"Window Methods","text":"<p>These methods work with any object implementing the <code>GeoDataBase</code> protocol. They calculate <code>rasterio.windows</code> objects without reading any data:</p> <ul> <li><code>window_from_bounds</code>: Creates a window to read from the raster from geographic bounds</li> <li><code>window_from_center_coords</code>: Creates a window  to read from the raster  centered on specific coordinates.</li> <li><code>window_from_polygon</code>: Creates a window  to read from the raster that contains a polygon</li> <li><code>window_from_tile</code>: Creates a window  to read from the raster from X/Y/Z Web Mercator tiles.</li> </ul>"},{"location":"modules/read_module/#read-methods","title":"Read Methods","text":"<p>These methods require objects implementing the <code>GeoData</code> protocol. They load and transform data:</p> <ul> <li><code>read_from_center_coords</code>: Reads data centered on specific coordinates</li> <li><code>read_from_bounds</code>: Reads data within geographic bounds</li> <li><code>read_from_polygon</code>: Reads data within a polygon's boundaries</li> <li><code>read_from_tile</code>: Reads data from X/Y/Z Web Mercator tiles.</li> <li><code>read_to_crs</code>: Reads data and reprojects to a different coordinate reference system</li> <li><code>read_reproject_like</code>: Reprojects data to match spatial extent and shape of another GeoData object.</li> <li><code>resize</code>: Changes the spatial resolution of the data.</li> <li><code>read_reproject</code>: Low-level function for arbitrary reprojection.</li> <li><code>read_rpcs</code>: Georeferences data using rational polynomial coefficients.</li> <li><code>spatial_mosaic</code>: Creates a spatial mosaic by combining spatially multiple GeoData objects.</li> </ul>"},{"location":"modules/read_module/#api-reference","title":"API Reference","text":""},{"location":"modules/read_module/#read-methods_1","title":"Read Methods","text":""},{"location":"modules/read_module/#georeader.read.read_from_center_coords","title":"<code>read_from_center_coords(data_in, center_coords, shape, crs_center_coords=None, return_only_data=False, trigger_load=False, boundless=True)</code>","text":"<p>Returns a chip of <code>data_in</code> centered on <code>center_coords</code> of shape <code>shape</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>GeoData</code> <p>GeoData object</p> required <code>center_coords</code> <code>Tuple[float, float]</code> <p>x, y tuple of coords in <code>data_in</code> crs.</p> required <code>shape</code> <code>Tuple[int, int]</code> <p>shape of the window to read</p> required <code>crs_center_coords</code> <code>Optional[Any]</code> <p>CRS of center coords. If provided will check if it needs to reproject the coords before computing the reading window.</p> <code>None</code> <code>return_only_data</code> <code>bool</code> <p>defaults to <code>False</code>. If <code>True</code> it returns a np.ndarray otherwise returns an GeoData georreferenced object.</p> <code>False</code> <code>trigger_load</code> <code>bool</code> <p>defaults to <code>False</code>. Trigger loading the data to memory.</p> <code>False</code> <code>boundless</code> <code>bool</code> <p>if <code>True</code> data read will always have the shape of the provided window (padding with <code>fill_value_default</code>)</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[GeoData, ndarray]</code> <p>GeoData or np.array sliced from <code>data_in</code> of shape <code>shape</code>.</p> Source code in <code>georeader/read.py</code> <pre><code>def read_from_center_coords(data_in: GeoData, center_coords:Tuple[float, float], shape:Tuple[int,int],\n                            crs_center_coords:Optional[Any]=None,\n                            return_only_data:bool=False, trigger_load:bool=False,\n                            boundless:bool=True) -&gt; Union[GeoData, np.ndarray]:\n    \"\"\"\n    Returns a chip of `data_in` centered on `center_coords` of shape `shape`.\n\n    Args:\n        data_in: GeoData object\n        center_coords: x, y tuple of coords in `data_in` crs.\n        shape: shape of the window to read\n        crs_center_coords: CRS of center coords. If provided will check if it needs to reproject the coords before\n            computing the reading window.\n        return_only_data: defaults to `False`. If `True` it returns a np.ndarray otherwise\n            returns an GeoData georreferenced object.\n        trigger_load: defaults to `False`. Trigger loading the data to memory.\n        boundless: if `True` data read will always have the shape of the provided window\n            (padding with `fill_value_default`)\n\n    Returns:\n        GeoData or np.array sliced from `data_in` of shape `shape`.\n\n    \"\"\"\n\n    window = window_from_center_coords(data_in, center_coords, shape, crs_center_coords)\n\n    return read_from_window(data_in, window=window, return_only_data=return_only_data,\n                            trigger_load=trigger_load, boundless=boundless)\n</code></pre>"},{"location":"modules/read_module/#georeader.read.read_from_bounds","title":"<code>read_from_bounds(data_in, bounds, crs_bounds=None, pad_add=(0, 0), return_only_data=False, trigger_load=False, boundless=True)</code>","text":"<p>Reads a slice of data_in covering the <code>bounds</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>GeoData</code> <p>GeoData with geographic info (crs and geotransform).</p> required <code>bounds</code> <code>Tuple[float, float, float, float]</code> <p>bounding box to read.</p> required <code>crs_bounds</code> <code>Optional[str]</code> <p>if not None will transform the bounds from that crs to the <code>data.crs</code> to read the chip.</p> <code>None</code> <code>pad_add</code> <code>Tuple[int, int]</code> <p>Tuple[int, int]. Pad in pixels to add to the <code>window</code> that is read.This is useful when this function is called for interpolation/CNN prediction.</p> <code>(0, 0)</code> <code>return_only_data</code> <code>bool</code> <p>defaults to <code>False</code>. If <code>True</code> it returns a np.ndarray otherwise returns an GeoData georreferenced object.</p> <code>False</code> <code>trigger_load</code> <code>bool</code> <p>defaults to <code>False</code>. Trigger loading the data to memory.</p> <code>False</code> <code>boundless</code> <code>bool</code> <p>if <code>True</code> data read will always have the shape of the provided window (padding with <code>fill_value_default</code>)</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[GeoData, ndarray]</code> <p>sliced GeoData</p> Source code in <code>georeader/read.py</code> <pre><code>def read_from_bounds(data_in: GeoData, bounds: Tuple[float, float, float, float],\n                     crs_bounds: Optional[str] = None, pad_add:Tuple[int, int]=(0, 0),\n                     return_only_data: bool = False, trigger_load: bool = False,\n                     boundless: bool = True) -&gt; Union[GeoData, np.ndarray]:\n    \"\"\"\n    Reads a slice of data_in covering the `bounds`.\n\n    Args:\n        data_in: GeoData with geographic info (crs and geotransform).\n        bounds:  bounding box to read.\n        crs_bounds: if not None will transform the bounds from that crs to the `data.crs` to read the chip.\n        pad_add: Tuple[int, int]. Pad in pixels to add to the `window` that is read.This is useful when this function is called for\n            interpolation/CNN prediction.\n        return_only_data: defaults to `False`. If `True` it returns a np.ndarray otherwise\n            returns an GeoData georreferenced object.\n        trigger_load: defaults to `False`. Trigger loading the data to memory.\n        boundless: if `True` data read will always have the shape of the provided window\n            (padding with `fill_value_default`)\n\n    Returns:\n        sliced GeoData\n    \"\"\"\n    window_in = window_from_bounds(data_in, bounds, crs_bounds)\n    if any(p &gt; 0 for p in pad_add):\n        window_in = pad_window(window_in, pad_add)  # Add padding for bicubic int or for co-registration\n    window_in = round_outer_window(window_in)\n\n    return read_from_window(data_in, window_in, return_only_data=return_only_data, trigger_load=trigger_load,\n                            boundless=boundless)\n</code></pre>"},{"location":"modules/read_module/#georeader.read.read_from_polygon","title":"<code>read_from_polygon(data_in, polygon, crs_polygon=None, pad_add=(0, 0), return_only_data=False, trigger_load=False, boundless=True, window_surrounding=False)</code>","text":"<p>Reads a slice of data_in covering the <code>polygon</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>GeoData</code> <p>GeoData with geographic info (crs and geotransform).</p> required <code>polygon</code> <code>Union[Polygon, MultiPolygon]</code> <p>Polygon or MultiPolygon that specifies the region to read.</p> required <code>crs_polygon</code> <code>Optional[str]</code> <p>if not None will transform the polygon from that crs to the data.crs to read the chip.</p> <code>None</code> <code>pad_add</code> <code>Tuple[int, int]</code> <p>pad in pixels to add to the <code>window</code> that is read.This is useful when this function is called for interpolation/CNN prediction.</p> <code>(0, 0)</code> <code>return_only_data</code> <code>bool</code> <p>defaults to <code>False</code>. If <code>True</code> it returns a np.ndarray otherwise returns an GeoData georreferenced object.</p> <code>False</code> <code>trigger_load</code> <code>bool</code> <p>defaults to <code>False</code>. Trigger loading the data to memory.</p> <code>False</code> <code>boundless</code> <code>bool</code> <p>if <code>True</code> data read will always have the shape of the provided window (padding with <code>fill_value_default</code>)</p> <code>True</code> <code>window_surrounding</code> <code>bool</code> <p>The window surrounds the polygon. (i.e. <code>window.row_off</code> + <code>window.height</code> will not be a vertex)</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[GeoData, ndarray]</code> <p>sliced GeoData</p> Source code in <code>georeader/read.py</code> <pre><code>def read_from_polygon(data_in: GeoData, polygon: Union[Polygon, MultiPolygon],\n                      crs_polygon: Optional[str] = None, pad_add:Tuple[int, int]=(0, 0),\n                      return_only_data: bool = False, trigger_load: bool = False,\n                      boundless: bool = True, window_surrounding:bool=False) -&gt; Union[GeoData, np.ndarray]:\n    \"\"\"\n    Reads a slice of data_in covering the `polygon`.\n\n    Args:\n        data_in: GeoData with geographic info (crs and geotransform).\n        polygon: Polygon or MultiPolygon that specifies the region to read.\n        crs_polygon: if not None will transform the polygon from that crs to the data.crs to read the chip.\n        pad_add: pad in pixels to add to the `window` that is read.This is useful when this function is called for\n            interpolation/CNN prediction.\n        return_only_data: defaults to `False`. If `True` it returns a np.ndarray otherwise\n            returns an GeoData georreferenced object.\n        trigger_load: defaults to `False`. Trigger loading the data to memory.\n        boundless: if `True` data read will always have the shape of the provided window\n            (padding with `fill_value_default`)\n        window_surrounding: The window surrounds the polygon. (i.e. `window.row_off` + `window.height` will not be a vertex)\n\n    Returns:\n        sliced GeoData\n    \"\"\"\n    window_in = window_from_polygon(data_in, polygon, crs_polygon, \n                                    window_surrounding=window_surrounding)\n    if any(p &gt; 0 for p in pad_add):\n        window_in = pad_window(window_in, pad_add)  # Add padding for bicubic int or for co-registration\n    window_in = round_outer_window(window_in)\n\n    return read_from_window(data_in, window_in, return_only_data=return_only_data, \n                            trigger_load=trigger_load,\n                            boundless=boundless)\n</code></pre>"},{"location":"modules/read_module/#georeader.read.read_from_window","title":"<code>read_from_window(data_in, window, return_only_data=False, trigger_load=False, boundless=True)</code>","text":"<p>Reads a window from data_in padding with <code>data_in.fill_value_default</code> if needed  (output GeoData will have <code>window.height</code>, <code>window.width</code> shape if boundless is <code>True</code>).</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>GeoData</code> <p>GeoData with \"x\" and \"y\" coordinates</p> required <code>window</code> <code>Window</code> <p>window to slice the GeoData with.</p> required <code>return_only_data</code> <code>bool</code> <p>defaults to <code>False</code>. If <code>True</code> it returns a np.ndarray otherwise returns an GeoData georreferenced object.</p> <code>False</code> <code>trigger_load</code> <code>bool</code> <p>defaults to <code>False</code>. Trigger loading the data to memory.</p> <code>False</code> <code>boundless</code> <code>bool</code> <p>if <code>True</code> data read will always have the shape of the provided window (padding with <code>fill_value_default</code>)</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[GeoData, ndarray, None]</code> <p>GeoData object</p> Source code in <code>georeader/read.py</code> <pre><code>def read_from_window(data_in: GeoData,\n                     window: rasterio.windows.Window, return_only_data: bool = False,\n                     trigger_load: bool = False,\n                     boundless: bool = True) -&gt; Union[GeoData, np.ndarray, None]:\n    \"\"\"\n    Reads a window from data_in padding with `data_in.fill_value_default` if needed \n    (output GeoData will have `window.height`, `window.width` shape if boundless is `True`).\n\n    Args:\n        data_in: GeoData with \"x\" and \"y\" coordinates\n        window: window to slice the GeoData with.\n        return_only_data: defaults to `False`. If `True` it returns a np.ndarray otherwise\n            returns an GeoData georreferenced object.\n        trigger_load: defaults to `False`. Trigger loading the data to memory.\n        boundless: if `True` data read will always have the shape of the provided window\n            (padding with `fill_value_default`)\n\n    Returns:\n        GeoData object\n    \"\"\"\n\n    named_shape = OrderedDict(zip(data_in.dims, data_in.shape))\n\n    window_data = rasterio.windows.Window(col_off=0, row_off=0,\n                                          width=named_shape[\"x\"], height=named_shape[\"y\"])\n\n    # get transform of current window\n    transform = data_in.transform\n\n    # Case the window does not intersect the data\n    if not rasterio.windows.intersect([window_data, window]):\n        if not boundless:\n            return None\n\n        expected_shapes = {\"x\": window.width, \"y\": window.height}\n        shape = tuple([named_shape[s] if s not in [\"x\", \"y\"] else expected_shapes[s] for s in data_in.dims])\n        data = np.zeros(shape, dtype=data_in.dtype)\n        fill_value_default = getattr(data_in, \"fill_value_default\", 0)\n        if fill_value_default != 0:\n            data += fill_value_default\n        if return_only_data:\n            return data\n\n        return GeoTensor(data, crs=data_in.crs,\n                         transform=rasterio.windows.transform(window, transform=transform),\n                         fill_value_default=fill_value_default)\n\n    # Read data directly with rasterio (handles automatically the padding)\n    data_sel = data_in.read_from_window(window=window, boundless=boundless)\n\n    if return_only_data:\n        return data_sel.values\n\n    if trigger_load:\n        data_sel = data_sel.load()\n\n    return data_sel\n</code></pre>"},{"location":"modules/read_module/#georeader.read.read_from_tile","title":"<code>read_from_tile(data, x, y, z, dst_crs=WEB_MERCATOR_CRS, out_shape=(SIZE_DEFAULT, SIZE_DEFAULT), resolution_dst_crs=None, assert_if_not_intersects=False)</code>","text":"<p>Read a web mercator tile from a GeoData object. Tiles are TMS tiles defined as: (https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>GeoData</code> <p>GeoData object</p> required <code>x</code> <code>int</code> <p>x. x coordinate of the tile in the TMS system.</p> required <code>y</code> <code>int</code> <p>y. y coordinate of the tile in the TMS system.</p> required <code>z</code> <code>int</code> <p>z. zoom level</p> required <code>dst_crs</code> <code>Optional[Any]</code> <p>output crs. Defaults to WEB_MERCATOR_CRS. If None uses the crs of data.</p> <code>WEB_MERCATOR_CRS</code> <code>out_shape</code> <code>Optional[Tuple[int, int]]</code> <p>output size. Defaults to (SIZE_DEFAULT, SIZE_DEFAULT). If None it will be the size of the tile in the input resolution.</p> <code>(SIZE_DEFAULT, SIZE_DEFAULT)</code> <code>resolution_dst_crs</code> <code>Optional[Union[float, Tuple[float, float]]]</code> <p>output resolution. Defaults to None.  If out_shape is not None it will be ignored. If None and out_shape is None the output will be at the resolution of the input data.</p> <code>None</code> <code>assert_if_not_intersects</code> <code>bool</code> <p>If True it will raise an error if the tile does not intersect the data. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Optional[GeoTensor]</code> <p>GeoTensor covering the tile or None if the tile does not intersect the data.</p> Source code in <code>georeader/read.py</code> <pre><code>def read_from_tile(data:GeoData, x:int, y:int, z:int, dst_crs:Optional[Any]=WEB_MERCATOR_CRS, \n                   out_shape:Optional[Tuple[int,int]]=(SIZE_DEFAULT, SIZE_DEFAULT), \n                   resolution_dst_crs:Optional[Union[float, Tuple[float, float]]]=None,\n                   assert_if_not_intersects:bool=False) -&gt; Optional[GeoTensor]:\n    \"\"\"\n    Read a web mercator tile from a GeoData object. Tiles are TMS tiles defined as: (https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames)\n\n    Args:\n        data (GeoData): GeoData object\n        x (int): x. x coordinate of the tile in the TMS system.\n        y (int): y. y coordinate of the tile in the TMS system.\n        z (int): z. zoom level\n        dst_crs (Optional[Any], optional): output crs. Defaults to WEB_MERCATOR_CRS. If None uses the crs of data.\n        out_shape (Optional[Tuple[int,int]], optional): output size. Defaults to (SIZE_DEFAULT, SIZE_DEFAULT). If None it will be the size\n            of the tile in the input resolution.\n        resolution_dst_crs (Optional[Union[float, Tuple[float, float]]], optional): output resolution. Defaults to None. \n            If out_shape is not None it will be ignored. If None and out_shape is None the output will be at the resolution of the input data.\n        assert_if_not_intersects (bool, optional): If True it will raise an error if the tile does not intersect the data. Defaults to False.\n\n    Returns:\n        GeoTensor: GeoTensor covering the tile or None if the tile does not intersect the data.\n    \"\"\"\n    bounds_wgs = mercantile.xy_bounds(int(x), int(y), int(z))\n    polygon_crs_webmercator = box(bounds_wgs.left, bounds_wgs.bottom, bounds_wgs.right, bounds_wgs.top)\n\n    intersects = polygon_crs_webmercator.intersects(data.footprint(crs=WEB_MERCATOR_CRS))\n\n    if not intersects:\n        assert not assert_if_not_intersects, \"Tile does not intersect data\"\n    else:\n        return\n\n    if out_shape is not None and hasattr(data, \"read_from_tile\"):\n        return data.read_from_tile(x, y, z, dst_crs=dst_crs, out_shape=out_shape)\n\n    if dst_crs is None:\n        dst_crs = data.crs\n\n    if window_utils.compare_crs(data.crs, dst_crs) and (out_shape is None) and (resolution_dst_crs is None):\n        # read from polygon handles the case where the data does not intersect the polygon\n        return read_from_polygon(data, polygon_crs_webmercator, WEB_MERCATOR_CRS, window_surrounding=True).load()\n\n    if out_shape is not None:\n        polygon_crs_dst = window_utils.polygon_to_crs(polygon_crs_webmercator, WEB_MERCATOR_CRS, dst_crs)\n        bounds_dst = polygon_crs_dst.bounds\n        dst_transform = rasterio.transform.from_bounds(*bounds_dst, \n                                                       width=out_shape[1], height=out_shape[0])\n        window_data = rasterio.windows.Window(0, 0, width=out_shape[1], height=out_shape[0])\n    else:\n        if resolution_dst_crs is not None:\n            if isinstance(resolution_dst_crs, numbers.Number):\n                resolution_dst_crs = (abs(resolution_dst_crs), abs(resolution_dst_crs))\n\n        polygon_crs_data = window_utils.polygon_to_crs(polygon_crs_webmercator, WEB_MERCATOR_CRS, data.crs)\n        bounds_crs_data = polygon_crs_data.bounds\n\n        in_height, in_width = data.shape[-2:]\n        dst_transform, width, height = rasterio.warp.calculate_default_transform(data.crs, dst_crs, in_width, in_height, *bounds_crs_data,\n                                                                                resolution=resolution_dst_crs)\n        window_data = rasterio.windows.Window(0,0, width=width, height=height)\n        dst_transform, window_data = calculate_transform_window(data, dst_crs, resolution_dst_crs)\n\n    return read_reproject(data, dst_crs=dst_crs, dst_transform=dst_transform, \n                          window_out=window_data)\n</code></pre>"},{"location":"modules/read_module/#georeader.read.read_to_crs","title":"<code>read_to_crs(data_in, dst_crs, resampling=rasterio.warp.Resampling.cubic_spline, resolution_dst_crs=None, return_only_data=False)</code>","text":"<p>Change the crs of data_in to dst_crs. This function is a wrapper of the <code>read_reproject</code> function to reproject data_in to dst_crs.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>GeoData</code> <p>GeoData to reproyect</p> required <code>dst_crs</code> <code>Any</code> <p>dst crs. Examples: \"EPSG:4326\", \"EPSG:3857\"</p> required <code>resampling</code> <code>Resampling</code> <p>Defaults to <code>rasterio.warp.Resampling.cubic_spline</code></p> <code>cubic_spline</code> <code>resolution_dst_crs</code> <code>Optional[Union[float, Tuple[float, float]]]</code> <p>spatial resolution of the output <code>GeoTensor</code> in <code>dst_crs</code> CRS. Defaults to None.  If not provided it will compute the resolution to match the resolution of the input.</p> <code>None</code> <code>return_only_data</code> <code>bool</code> <p>Defaults to <code>False</code>.  If <code>True</code> it returns a np.ndarray otherwise a <code>GeoTensor</code> object (georreferenced array).</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, ndarray]</code> <p>Union[GeoTensor, np.ndarray]: data in dst_crs</p> Source code in <code>georeader/read.py</code> <pre><code>def read_to_crs(data_in:GeoData, dst_crs:Any, \n                resampling:rasterio.warp.Resampling = rasterio.warp.Resampling.cubic_spline,\n                resolution_dst_crs:Optional[Union[float, Tuple[float, float]]]=None,\n                return_only_data: bool = False)-&gt; Union[GeoTensor, np.ndarray]:\n    \"\"\"\n    Change the crs of data_in to dst_crs. This function is a wrapper of the `read_reproject` function\n    to reproject data_in to dst_crs.\n\n    Args:\n        data_in (GeoData): GeoData to reproyect\n        dst_crs (Any): dst crs. Examples: \"EPSG:4326\", \"EPSG:3857\"\n        resampling (rasterio.warp.Resampling, optional): \n            Defaults to `rasterio.warp.Resampling.cubic_spline`\n        resolution_dst_crs (Optional[Union[float, Tuple[float, float]]], optional): \n            spatial resolution of the output `GeoTensor` in `dst_crs` CRS. Defaults to None. \n            If not provided it will compute the resolution to match the resolution of the input.\n        return_only_data (bool, optional): Defaults to `False`. \n            If `True` it returns a np.ndarray otherwise a `GeoTensor` object (georreferenced array).\n\n    Returns:\n        Union[GeoTensor, np.ndarray]: data in dst_crs\n    \"\"\"\n    if window_utils.compare_crs(data_in.crs, dst_crs):\n        return data_in\n\n    window_data, dst_transform = calculate_transform_window(data_in, dst_crs, resolution_dst_crs)\n\n\n    return read_reproject(data_in, dst_crs=dst_crs,\n                          dst_transform=dst_transform,\n                          window_out=window_data,\n                          resampling=resampling, return_only_data=return_only_data)\n</code></pre>"},{"location":"modules/read_module/#georeader.read.read_reproject_like","title":"<code>read_reproject_like(data_in, data_like, resolution_dst=None, resampling=rasterio.warp.Resampling.cubic_spline, dtype_dst=None, return_only_data=False, dst_nodata=None)</code>","text":"<p>Reads from <code>data_in</code> and reprojects to have the same extent and resolution than <code>data_like</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>GeoData</code> <p>GeoData to read and reproject. Expected coords \"x\" and \"y\".</p> required <code>data_like</code> <code>GeoData</code> <p>GeoData to get the bounds and resolution to reproject <code>data_in</code>.</p> required <code>resolution_dst</code> <code>Optional[Union[float, Tuple[float, float]]]</code> <p>if not None it will overwrite the resolution of <code>data_like</code>.</p> <code>None</code> <code>resampling</code> <code>Resampling</code> <p>specifies how data is reprojected from <code>rasterio.warp.Resampling</code>.</p> <code>cubic_spline</code> <code>dtype_dst</code> <code>Any</code> <p>if None it will be inferred</p> <code>None</code> <code>return_only_data</code> <code>bool</code> <p>defaults to <code>False</code>. If <code>True</code> it returns a np.ndarray otherwise returns an GeoTensor object (georreferenced array).</p> <code>False</code> <code>dst_nodata</code> <code>Optional[int]</code> <p>dst_nodata value</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, ndarray]</code> <p>GeoTensor read from <code>data_in</code> with same transform, crs, shape and bounds than <code>data_like</code>.</p> Source code in <code>georeader/read.py</code> <pre><code>def read_reproject_like(data_in: GeoData, data_like: GeoData,\n                        resolution_dst:Optional[Union[float, Tuple[float, float]]]=None,\n                        resampling: rasterio.warp.Resampling = rasterio.warp.Resampling.cubic_spline,\n                        dtype_dst:Any=None, return_only_data: bool = False,\n                        dst_nodata: Optional[int] = None) -&gt; Union[GeoTensor, np.ndarray]:\n    \"\"\"\n    Reads from `data_in` and reprojects to have the same extent and resolution than `data_like`.\n\n    Args:\n        data_in: GeoData to read and reproject. Expected coords \"x\" and \"y\".\n        data_like: GeoData to get the bounds and resolution to reproject `data_in`.\n        resolution_dst: if not None it will overwrite the resolution of `data_like`.\n        resampling: specifies how data is reprojected from `rasterio.warp.Resampling`.\n        dtype_dst: if None it will be inferred\n        return_only_data: defaults to `False`. If `True` it returns a np.ndarray otherwise\n            returns an GeoTensor object (georreferenced array).\n        dst_nodata: dst_nodata value\n\n    Returns:\n        GeoTensor read from `data_in` with same transform, crs, shape and bounds than `data_like`.\n    \"\"\"\n\n    shape_out = data_like.shape[-2:]\n    if resolution_dst is not None:\n        if isinstance(resolution_dst, float):\n            resolution_dst = (resolution_dst, resolution_dst)\n\n        resolution_data_like = data_like.res\n\n        shape_out = int(round(shape_out[0] / resolution_dst[0] * resolution_data_like[0])), \\\n                    int(round(shape_out[1] / resolution_dst[1] * resolution_data_like[1]))\n\n    return read_reproject(data_in, dst_crs=data_like.crs, dst_transform=data_like.transform,\n                          resolution_dst_crs=resolution_dst,\n                          window_out=rasterio.windows.Window(0,0, width=shape_out[-1], height=shape_out[-2]),\n                          resampling=resampling,dtype_dst=dtype_dst, return_only_data=return_only_data,\n                          dst_nodata=dst_nodata)\n</code></pre>"},{"location":"modules/read_module/#georeader.read.resize","title":"<code>resize(data_in, resolution_dst, window_out=None, anti_aliasing=True, anti_aliasing_sigma=None, resampling=rasterio.warp.Resampling.cubic_spline, return_only_data=False)</code>","text":"<p>Change the spatial resolution of data_in to <code>resolution_dst</code>. This function is a wrapper of the <code>read_reproject</code> function that adds anti_aliasing before reprojecting.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>GeoData</code> <p>GeoData to change the resolution. Expected coords \"x\" and \"y\".</p> required <code>resolution_dst</code> <code>Union[float, Tuple[float, float]]</code> <p>spatial resolution in data_in crs</p> required <code>window_out</code> <code>Optional[Window]</code> <p>Optional. output size of the fragment to read and reproject. Defaults to the ceiling size</p> <code>None</code> <code>anti_aliasing</code> <code>bool</code> <p>Whether to apply a Gaussian filter to smooth the image prior to downsampling</p> <code>True</code> <code>anti_aliasing_sigma</code> <code>Optional[Union[float, ndarray]]</code> <p>anti_aliasing_sigma : {float}, optional     Standard deviation for Gaussian filtering used when anti-aliasing.     By default, this value is chosen as (s - 1) / 2 where s is the     downsampling factor, where s &gt; 1</p> <code>None</code> <code>resampling</code> <code>Resampling</code> <p>specifies how data is reprojected from <code>rasterio.warp.Resampling</code>.</p> <code>cubic_spline</code> <code>return_only_data</code> <code>bool</code> <p>defaults to <code>False</code>. If <code>True</code> it returns a np.ndarray otherwise returns an GeoTensor object (georreferenced array).</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, ndarray]</code> <p>GeoTensor with spatial resolution <code>resolution_dst</code></p> Source code in <code>georeader/read.py</code> <pre><code>def resize(data_in:GeoData, resolution_dst:Union[float, Tuple[float, float]],\n           window_out:Optional[rasterio.windows.Window]=None,\n           anti_aliasing:bool=True, anti_aliasing_sigma:Optional[Union[float,np.ndarray]]=None,\n           resampling: rasterio.warp.Resampling = rasterio.warp.Resampling.cubic_spline,\n           return_only_data: bool = False)-&gt; Union[\n    GeoTensor, np.ndarray]:\n    \"\"\"\n    Change the spatial resolution of data_in to `resolution_dst`. This function is a wrapper of the `read_reproject` function\n    that adds anti_aliasing before reprojecting.\n\n    Args:\n        data_in: GeoData to change the resolution. Expected coords \"x\" and \"y\".\n        resolution_dst: spatial resolution in data_in crs\n        window_out: Optional. output size of the fragment to read and reproject. Defaults to the ceiling size\n        anti_aliasing: Whether to apply a Gaussian filter to smooth the image prior to downsampling\n        anti_aliasing_sigma:  anti_aliasing_sigma : {float}, optional\n                Standard deviation for Gaussian filtering used when anti-aliasing.\n                By default, this value is chosen as (s - 1) / 2 where s is the\n                downsampling factor, where s &gt; 1\n        resampling: specifies how data is reprojected from `rasterio.warp.Resampling`.\n        return_only_data: defaults to `False`. If `True` it returns a np.ndarray otherwise\n            returns an GeoTensor object (georreferenced array).\n\n    Returns:\n        GeoTensor with spatial resolution `resolution_dst`\n\n    \"\"\"\n    resolution_or = data_in.res\n    if isinstance(resolution_dst, numbers.Number):\n        resolution_dst = (abs(resolution_dst), abs(resolution_dst))\n    scale = np.array([resolution_dst[0] / resolution_or[0], resolution_dst[1] / resolution_or[1]])\n\n    if window_out is None:\n        spatial_shape = data_in.shape[-2:]\n\n        # scale &lt; 1 =&gt; make image smaller (resolution_or &lt; resolution_dst)\n        # scale &gt; 1 =&gt; make image larger (resolution_or &gt; resolution_dst)\n        output_shape_exact = spatial_shape[0] / scale[0], spatial_shape[1] / scale[1]\n        output_shape_rounded = round(output_shape_exact[0], ndigits=3), round(output_shape_exact[1], ndigits=3)\n        output_shape = ceil(output_shape_rounded[0]), ceil(output_shape_rounded[1])\n        window_out = rasterio.windows.Window(col_off=0, row_off=0, width=output_shape[1], height=output_shape[0])\n\n    if anti_aliasing:\n        data_in = apply_anti_aliasing(data_in, anti_aliasing_sigma=anti_aliasing_sigma, \n                                      resolution_dst=resolution_dst)\n\n    return read_reproject(data_in, dst_crs=data_in.crs, resolution_dst_crs=resolution_dst,\n                          dst_transform=data_in.transform, window_out=window_out,\n                          resampling=resampling, return_only_data=return_only_data)\n</code></pre>"},{"location":"modules/read_module/#georeader.read.read_reproject","title":"<code>read_reproject(data_in, dst_crs=None, bounds=None, resolution_dst_crs=None, dst_transform=None, window_out=None, resampling=rasterio.warp.Resampling.cubic_spline, dtype_dst=None, return_only_data=False, dst_nodata=None)</code>","text":"<p>This function slices the data by the bounds and reprojects it to the dst_crs and resolution_dst_crs</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>GeoData</code> <p>GeoData to read and reproject. Expected coords \"x\" and \"y\".</p> required <code>dst_crs</code> <code>Optional[str]</code> <p>CRS to reproject.</p> <code>None</code> <code>bounds</code> <code>Optional[Tuple[float, float, float, float]]</code> <p>Optional. bounds in CRS specified by <code>dst_crs</code>. If not provided <code>window_out</code> must be given.</p> <code>None</code> <code>resolution_dst_crs</code> <code>Optional[Union[float, Tuple[float, float]]]</code> <p>resolution in the CRS specified by <code>dst_crs</code>. If not provided will use the the resolution intrinsic of dst_transform.</p> <code>None</code> <code>dst_transform</code> <code>Optional[Affine]</code> <p>Optional dest transform. If not provided the dst_transform is a rectilinear transform computed with the bounds and resolution_dst_crs.</p> <code>None</code> <code>window_out</code> <code>Optional[Window]</code> <p>Window out to read w.r.t <code>dst_transform</code>. If not provided it is computed from the bounds. Window out if provided has the output width and height of the reprojected data.</p> <code>None</code> <code>resampling</code> <code>Resampling</code> <p>specifies how data is reprojected from <code>rasterio.warp.Resampling</code>.</p> <code>cubic_spline</code> <code>dtype_dst</code> <code>Any</code> <p>if None it will be data_in.dtype</p> <code>None</code> <code>return_only_data</code> <code>bool</code> <p>defaults to <code>False</code>. If <code>True</code> it returns a np.ndarray otherwise returns an GeoTensor object (georreferenced array).</p> <code>False</code> <code>dst_nodata</code> <code>Optional[int]</code> <p>dst_nodata value</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, ndarray]</code> <p>GeoTensor reprojected to dst_crs with resolution_dst_crs</p> Source code in <code>georeader/read.py</code> <pre><code>def read_reproject(data_in: GeoData, dst_crs: Optional[str]=None,\n                   bounds: Optional[Tuple[float, float, float, float]]=None,\n                   resolution_dst_crs: Optional[Union[float, Tuple[float, float]]]=None,\n                   dst_transform:Optional[rasterio.Affine]=None,\n                   window_out:Optional[rasterio.windows.Window]=None,\n                   resampling: rasterio.warp.Resampling = rasterio.warp.Resampling.cubic_spline,\n                   dtype_dst:Any=None, return_only_data: bool = False, dst_nodata: Optional[int] = None) -&gt; Union[\n    GeoTensor, np.ndarray]:\n    \"\"\"\n    This function slices the data by the bounds and reprojects it to the dst_crs and resolution_dst_crs\n\n    Args:\n        data_in: GeoData to read and reproject. Expected coords \"x\" and \"y\".\n        dst_crs: CRS to reproject.\n        bounds: Optional. bounds in CRS specified by `dst_crs`. If not provided `window_out` must be given.\n        resolution_dst_crs: resolution in the CRS specified by `dst_crs`. If not provided will use the the resolution\n            intrinsic of dst_transform.\n        dst_transform: Optional dest transform. If not provided the dst_transform is a rectilinear transform computed\n            with the bounds and resolution_dst_crs.\n        window_out: Window out to read w.r.t `dst_transform`. If not provided it is computed from the bounds.\n            Window out if provided has the output width and height of the reprojected data.\n        resampling: specifies how data is reprojected from `rasterio.warp.Resampling`.\n        dtype_dst: if None it will be data_in.dtype\n        return_only_data: defaults to `False`. If `True` it returns a np.ndarray otherwise\n            returns an GeoTensor object (georreferenced array).\n        dst_nodata: dst_nodata value\n\n    Returns:\n        GeoTensor reprojected to dst_crs with resolution_dst_crs\n\n    \"\"\"\n\n    named_shape = OrderedDict(zip(data_in.dims, data_in.shape))\n\n    # Compute output transform\n    dst_transform = window_utils.figure_out_transform(transform=dst_transform, bounds=bounds,\n                                                      resolution_dst=resolution_dst_crs)\n\n    # Compute size of window in out crs\n    if window_out is None:\n        assert bounds is not None, \"Both window_out and bounds are None. This is needed to figure out the size of the output array\"\n        window_out = rasterio.windows.from_bounds(*bounds,\n                                                  transform=dst_transform).round_lengths(op=\"ceil\",\n                                                                                         pixel_precision=PIXEL_PRECISION)\n\n    crs_data_in = data_in.crs\n    if dst_crs is None:\n        dst_crs = crs_data_in\n\n    #  if dst_crs == data_in.crs and the resolution is the same and window is exact return read_from_window\n    if window_utils.compare_crs(dst_crs, crs_data_in):\n        transform_data = data_in.transform\n        if (dst_transform.a == transform_data.a) and (dst_transform.b == transform_data.b) and (\n                dst_transform.d == transform_data.d) and (dst_transform.e == transform_data.e):\n            # find shift between the two transforms\n            x_dst, y_dst = dst_transform.c, dst_transform.f\n            col_off, row_off = ~transform_data * (x_dst, y_dst)\n            window_in_data = rasterio.windows.Window(col_off, row_off, \n                                                     window_out.width, window_out.height)\n\n            if _is_exact_round(window_in_data.row_off) and _is_exact_round(window_in_data.col_off):\n                window_in_data = window_in_data.round_offsets(op=\"floor\", pixel_precision=PIXEL_PRECISION)\n                return read_from_window(data_in, window_in_data, return_only_data=return_only_data, trigger_load=True)\n\n    isbool_dtypein = data_in.dtype == 'bool'\n    isbool_dtypedst = False\n\n    cast = True\n    if dtype_dst is None:\n        cast = False\n        dtype_dst = data_in.dtype\n        if isbool_dtypein:\n            isbool_dtypedst = True\n    elif np.dtype(dtype_dst) == 'bool':\n        isbool_dtypedst = True\n\n    # Create out array for reprojection\n    dict_shape_window_out = {\"x\": window_out.width, \"y\": window_out.height}\n    shape_out = tuple([named_shape[s] if s not in [\"x\", \"y\"] else dict_shape_window_out[s] for s in named_shape])\n    dst_nodata = dst_nodata or data_in.fill_value_default\n    if isbool_dtypedst:\n        dst_nodata = bool(dst_nodata)\n\n    destination = np.full(shape_out, fill_value=dst_nodata, dtype=dtype_dst)\n\n    polygon_dst_crs = window_utils.window_polygon(window_out, dst_transform)\n\n    # If the polygon does not intersect the data return a GeoTensor with nodata\n    if not data_in.footprint(crs=dst_crs).intersects(polygon_dst_crs):\n        return GeoTensor(destination, transform=dst_transform, crs=dst_crs,\n                         fill_value_default=dst_nodata)\n\n    if not isinstance(data_in, GeoTensor):\n        # Compute real polygon that is going to be read\n        # Read a padded window of the input data. This data will be then used for reprojection\n        geotensor_in = read_from_polygon(data_in, polygon_dst_crs, crs_polygon=dst_crs,\n                                         pad_add=(3, 3), return_only_data=False,\n                                         trigger_load=True)\n    else:\n        geotensor_in = data_in\n\n    # Triggering load makes that fill_value_default goes to nodata\n    np_array_in = np.asanyarray(geotensor_in.values)\n\n    if cast:\n        if isbool_dtypedst:\n            np_array_in = np_array_in.astype(np.float32)\n        else:\n            np_array_in = np_array_in.astype(dtype_dst)\n    elif isbool_dtypein:\n        np_array_in = np_array_in.astype(np.float32)\n\n\n    index_iter = [[(ns, i) for i in range(s)] for ns, s in named_shape.items() if ns not in [\"x\", \"y\"]]\n    # e.g. if named_shape = {'time': 4, 'band': 2, 'x':10, 'y': 10} index_iter -&gt;\n    # [[('time', 0), ('time', 1), ('time', 2), ('time', 3)],\n    #  [('band', 0), ('band', 1)]]\n\n    for current_select_tuple in itertools.product(*index_iter):\n        # current_select_tuple = (('time', 0), ('band', 0))\n        i_sel_tuple = tuple(t[1] for t in current_select_tuple)\n\n        np_array_iter = np_array_in[i_sel_tuple]\n        if isbool_dtypedst:\n            dst_iter_write = destination[i_sel_tuple].astype(np.float32)\n            dst_nodata_iter = float(dst_nodata)\n        else:\n            dst_iter_write = destination[i_sel_tuple]\n            dst_nodata_iter = dst_nodata\n\n        rasterio.warp.reproject(\n            np_array_iter,\n            dst_iter_write,\n            src_transform=geotensor_in.transform,\n            src_crs=crs_data_in,\n            dst_transform=dst_transform,\n            dst_crs=dst_crs,\n            src_nodata=geotensor_in.fill_value_default,\n            dst_nodata=dst_nodata_iter,\n            resampling=resampling)\n\n        if isbool_dtypedst:\n            destination[i_sel_tuple] = (dst_iter_write &gt; .5)\n\n    if return_only_data:\n        return destination\n\n    return GeoTensor(destination, transform=dst_transform, crs=dst_crs,\n                     fill_value_default=dst_nodata)\n</code></pre>"},{"location":"modules/read_module/#georeader.read.read_rpcs","title":"<code>read_rpcs(input_npy, rpcs, fill_value_default=0, dst_crs=None, resolution_dst_crs=None, resampling=rasterio.warp.Resampling.cubic_spline, return_only_data=False)</code>","text":"<p>This function georreferences an array using the RPCs.      The RPCs are used to compute the transform from the input array to the destination crs.</p> <pre><code>This function assumes that the RPCs are in EPSG:4326.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input_npy</code> <code>NDArray</code> <p>Array to georeference. It must have 2, 3 or 4 dimensions.</p> required <code>rpcs</code> <code>RPC</code> <p>RPCs to compute the transform.</p> required <code>fill_value_default</code> <code>int</code> <p>how to encode the nodata value. Defaults to 0.</p> <code>0</code> <code>dst_crs</code> <code>Optional[Any]</code> <p>Destination crs. Defaults to None. If None, the dst_crs is the same as in the RPC polynomial (EPSG:4326).</p> <code>None</code> <code>resampling</code> <code>Resampling</code> <p>Resampling method.  Defaults to rasterio.warp.Resampling.cubic_spline.</p> <code>cubic_spline</code> <code>return_only_data</code> <code>bool</code> <p>If True it returns only the data. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>GeoTensor</code> <p>GeoTensor with the georeferenced array based on the RPCs.</p> Source code in <code>georeader/read.py</code> <pre><code>def read_rpcs(input_npy:NDArray, rpcs:rasterio.rpc.RPC, \n              fill_value_default:int=0,\n              dst_crs:Optional[Any]=None,\n              resolution_dst_crs:Optional[Union[float, Tuple[float, float]]]=None,\n              resampling: rasterio.warp.Resampling = rasterio.warp.Resampling.cubic_spline,\n              return_only_data:bool=False) -&gt; GeoTensor:\n    \"\"\"\n    This function georreferences an array using the RPCs. \n        The RPCs are used to compute the transform from the input array to the destination crs.\n\n        This function assumes that the RPCs are in EPSG:4326.\n\n    Args:\n        input_npy (NDArray): Array to georeference. It must have 2, 3 or 4 dimensions.\n        rpcs (rasterio.rpc.RPC): RPCs to compute the transform.\n        fill_value_default (int, optional): how to encode the nodata value. Defaults to 0.\n        dst_crs (Optional[Any], optional): Destination crs. Defaults to None.\n            If None, the dst_crs is the same as in the RPC polynomial (EPSG:4326).\n        resampling (rasterio.warp.Resampling, optional): Resampling method. \n            Defaults to rasterio.warp.Resampling.cubic_spline.\n        return_only_data (bool, optional): If True it returns only the data. Defaults to False.\n\n    Returns:\n        GeoTensor: GeoTensor with the georeferenced array based on the RPCs.\n    \"\"\"\n\n    isbool_dtypedst = input_npy.dtype == 'bool'\n    if isbool_dtypedst:\n        fill_value_default = bool(fill_value_default)\n\n    assert input_npy.ndim &gt;= 2 and input_npy.ndim &lt;= 4, \"Input array must have 2, 3 or 4 dimensions\"\n\n    named_shape = OrderedDict(reversed(list(zip([\"y\", \"x\", \"band\", \"time\"], \n                                                reversed(input_npy.shape)))))\n\n    index_iter = [[(ns, i) for i in range(s)] for ns, s in named_shape.items() if ns not in [\"x\", \"y\"]]\n    # e.g. if named_shape = {'time': 4, 'band': 2, 'x':10, 'y': 10} index_iter -&gt;\n    # [[('time', 0), ('time', 1), ('time', 2), ('time', 3)],\n    #  [('band', 0), ('band', 1)]]\n\n    if dst_crs is None:\n        dst_crs = rasterio.crs.CRS.from_epsg(4326)\n\n    src_crs = rasterio.crs.CRS.from_epsg(4326)\n\n    if resolution_dst_crs is not None:\n        if isinstance(resolution_dst_crs, float):\n            resolution_dst_crs = (resolution_dst_crs, resolution_dst_crs)\n\n    dst_transform, dst_width, dst_height = rasterio.warp.calculate_default_transform(\n            src_crs=None, dst_crs=dst_crs, \n            width=input_npy.shape[-1], \n            height=input_npy.shape[-2], \n            resolution=resolution_dst_crs,\n            rpcs=rpcs, dst_width=None, dst_height=None)\n\n    destination = np.full(input_npy.shape[:-2] + (dst_height, dst_width),\n                          fill_value=fill_value_default,\n                          dtype=input_npy.dtype)\n\n    for current_select_tuple in itertools.product(*index_iter):\n        # current_select_tuple = (('time', 0), ('band', 0))\n        i_sel_tuple = tuple(t[1] for t in current_select_tuple)\n\n        np_array_iter = input_npy[i_sel_tuple]\n        if isbool_dtypedst:\n            dst_iter_write = destination[i_sel_tuple].astype(np.float32)\n            fill_value_default_iter = float(fill_value_default)\n        else:\n            dst_iter_write = destination[i_sel_tuple]\n            fill_value_default_iter = fill_value_default\n\n        rasterio.warp.reproject(\n            np_array_iter,\n            dst_iter_write,\n            src_transform=None,\n            rpcs=rpcs,\n            src_crs=src_crs,\n            dst_transform=dst_transform,\n            dst_crs=dst_crs,\n            src_nodata=fill_value_default_iter,\n            dst_nodata=fill_value_default_iter,\n            resampling=resampling)\n\n        if isbool_dtypedst:\n            destination[i_sel_tuple] = (dst_iter_write &gt; .5)\n\n    if return_only_data:\n        return destination\n\n    return GeoTensor(destination, transform=dst_transform, crs=dst_crs,\n                     fill_value_default=fill_value_default)\n</code></pre>"},{"location":"modules/read_module/#georeader.mosaic.spatial_mosaic","title":"<code>spatial_mosaic(data_list, polygon=None, crs_polygon=None, dst_transform=None, bounds=None, dst_crs=None, dtype_dst=None, window_size=None, resampling=rasterio.warp.Resampling.cubic_spline, masking_function=None, dst_nodata=None)</code>","text":"<p>Computes the spatial mosaic of all input products in <code>data_list</code>. It iteratively calls <code>read_reproject</code> with all the list of rasters while there is any <code>dst_nodata</code> value. This function m requires that the copy of the output fits in memory.</p> <p>This function is very similar to <code>rasterio.merge.merge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>Union[List[GeoData], List[Tuple[GeoData, GeoData]]]</code> <p>List of raster objects. each element could be a single geodata object or a tuple of an object and a mask (second item will be considered the invalid values mask).</p> required <code>polygon</code> <code>Optional[Polygon]</code> <p>polygon to compute the mosaic in crs_polygon</p> <code>None</code> <code>crs_polygon</code> <code>Optional[str]</code> <p>CRS of the polygon. If not provided it will use the CRS of the first product of the list.</p> <code>None</code> <code>bounds</code> <code>Optional[Tuple[float, float, float, float]]</code> <p>bounds to compute the mosaic.</p> <code>None</code> <code>dst_crs</code> <code>Optional[str]</code> <p>CRS of the product. If not provided it will use the CRS of the first product of the list</p> <code>None</code> <code>dst_transform</code> <code>Optional[Affine]</code> <p>Optional dest transform. If not provided the dst_transform is a rectilinear transform computed</p> <code>None</code> <code>window_size</code> <code>Optional[Tuple[int, int]]</code> <p>The mosaic will be computed by windows of this size (for efficiency purposes)</p> <code>None</code> <code>resampling</code> <code>Resampling</code> <p>specifies how data is reprojected from <code>rasterio.warp.Resampling</code>.</p> <code>cubic_spline</code> <code>masking_function</code> <code>Optional[Callable[[GeoData], GeoData]]</code> <p>function to call to the mask if provided or to the tensor (if not provided) should return a bool tensor with only spatial dimensions.</p> <code>None</code> <code>dst_nodata</code> <code>Optional[int]</code> <p>no data value. if None will use <code>data_list[0].fill_value_default</code></p> <code>None</code> <p>Returns:</p> Type Description <code>GeoTensor</code> <p>GeoTensor with mosaic over the given bounds</p> Source code in <code>georeader/mosaic.py</code> <pre><code>def spatial_mosaic(data_list:Union[List[GeoData], List[Tuple[GeoData,GeoData]]],\n                   polygon:Optional[Polygon]=None,\n                   crs_polygon:Optional[str]=None,\n                   dst_transform:Optional[rasterio.transform.Affine]=None,\n                   bounds:Optional[Tuple[float, float, float, float]]=None,\n                   dst_crs:Optional[str]=None,\n                   dtype_dst:Optional[str]=None,\n                   window_size: Optional[Tuple[int, int]]= None,\n                   resampling:rasterio.warp.Resampling=rasterio.warp.Resampling.cubic_spline,\n                   masking_function:Optional[Callable[[GeoData], GeoData]]=None,\n                   dst_nodata:Optional[int]=None) -&gt; GeoTensor:\n    \"\"\"\n    Computes the spatial mosaic of all input products in `data_list`. It iteratively calls `read_reproject` with\n    all the list of rasters while there is any `dst_nodata` value. This function m requires that the copy of the output\n    fits in memory.\n\n    This function is very similar to `rasterio.merge.merge`.\n\n    Args:\n        data_list: List of raster objects. each element could be a single geodata object or a tuple of an object and a\n            mask (second item will be considered the invalid values mask).\n        polygon: polygon to compute the mosaic in crs_polygon\n        crs_polygon: CRS of the polygon. If not provided it will use the CRS of the first product of the list.\n        bounds: bounds to compute the mosaic.\n        dst_crs: CRS of the product. If not provided it will use the CRS of the first product of the list\n        dst_transform: Optional dest transform. If not provided the dst_transform is a rectilinear transform computed\n        window_size: The mosaic will be computed by windows of this size (for efficiency purposes)\n        resampling:specifies how data is reprojected from `rasterio.warp.Resampling`.\n        masking_function: function to call to the mask if provided or to the tensor (if not provided) should return a bool tensor\n            with only spatial dimensions.\n        dst_nodata: no data value. if None will use `data_list[0].fill_value_default`\n\n    Returns:\n        GeoTensor with mosaic over the given bounds\n\n    \"\"\"\n\n    assert len(data_list) &gt; 0, f\"Expected at least one product found 0 {data_list}\"\n\n    if isinstance(data_list[0], tuple):\n        first_data_object =  data_list[0][0]\n        first_mask_object = data_list[0][1]\n    else:\n        first_data_object = data_list[0]\n        first_mask_object = None\n\n    if dst_transform is None:\n        dst_transform = first_data_object.transform\n\n    if dst_crs is None:\n        dst_crs = first_data_object.crs\n\n    if polygon is None:\n        if bounds is not None:\n            polygon = box(*bounds)\n        else:\n            # Polygon is the Union of the polygons of all the data\n            for data in data_list:\n                if isinstance(data, tuple):\n                    data = data[0]\n                polygon_iter = data.footprint(crs=dst_crs)\n\n                if polygon is None:\n                    polygon = polygon_iter\n                else:\n                    polygon = polygon.union(polygon_iter)\n    else:\n        if crs_polygon is None:\n            crs_polygon = dst_crs\n        elif not georeader.compare_crs(crs_polygon, dst_crs):\n            polygon = window_utils.polygon_to_crs(polygon, crs_polygon, dst_crs)\n\n    GeoDataFake = namedtuple(\"GeoDataFake\", [\"transform\", \"crs\"])\n    window_polygon = read.window_from_polygon(GeoDataFake(transform=dst_transform, crs=dst_crs),\n                                              polygon, crs_polygon=dst_crs)\n\n    window_polygon = window_utils.round_outer_window(window_polygon)\n\n    # Shift transform to window\n    dst_transform = rasterio.windows.transform(window_polygon, transform=dst_transform)\n    dst_nodata = dst_nodata or first_data_object.fill_value_default\n\n    # Get object to save the results\n    data_return = read_reproject(first_data_object,\n                                 dst_crs=dst_crs, dst_transform=dst_transform,\n                                 resampling=resampling,\n                                 dtype_dst=dtype_dst,\n                                 window_out=rasterio.windows.Window(row_off=0, col_off=0, width=window_polygon.width,\n                                                                    height=window_polygon.height),\n                                 dst_nodata=dst_nodata)\n\n    # invalid_values of spatial locations only  -&gt; any\n    invalid_values = data_return.values == dst_nodata\n    if len(data_return.shape) &gt; 2:\n        axis_any = tuple(i for i in range(len(data_return.shape)-2))\n        invalid_values = np.any(invalid_values, axis=axis_any) # (H, W)\n    else:\n        axis_any = None\n\n    if first_mask_object is not None:\n        if (masking_function is None) and len(first_mask_object.shape) &gt; 2:\n            assert (len(first_mask_object.shape) == 3) and (first_mask_object.shape[0] == 1), f\"Expected two dims, found {first_mask_object.shape}\"\n\n        invalid_geotensor = read_reproject(first_mask_object,\n                                           dst_crs=dst_crs, dst_transform=dst_transform,\n                                           resampling=rasterio.warp.Resampling.nearest,\n                                           window_out=rasterio.windows.Window(row_off=0, col_off=0,\n                                                                              width=window_polygon.width,\n                                                                              height=window_polygon.height))\n        if masking_function is not None:\n            invalid_geotensor = masking_function(invalid_geotensor)\n\n        invalid_geotensor.values = invalid_geotensor.values.astype(bool)\n        invalid_geotensor.values =  invalid_geotensor.values.squeeze()\n        assert len(invalid_geotensor.shape) == 2, f\"Invalid mask expected 2 dims found {invalid_geotensor.shape}\"\n\n        invalid_values|= invalid_geotensor.values\n    elif masking_function is not None:\n        # Apply masking funtion to the readed data\n        invalid_geotensor = masking_function(data_return)\n\n        invalid_geotensor.values = invalid_geotensor.values.astype(bool)\n        invalid_geotensor.values = invalid_geotensor.values.squeeze()\n        assert len(invalid_geotensor.shape) == 2, f\"Invalid mask expected 2 dims found {invalid_geotensor.shape}\"\n        invalid_values |= invalid_geotensor.values\n\n    # data_return.values[..., invalid_values] = data_return.fill_value_default\n\n    if not np.any(invalid_values):\n        return data_return\n\n    if len(data_list) == 1:\n        return data_return\n\n    if window_size is not None:\n        windows = slices.create_windows(data_return.shape[-2:], window_size)\n    else:\n        windows = [rasterio.windows.Window(row_off=0, col_off=0, width=data_return.shape[-1],\n                                           height=data_return.shape[-2])]\n\n    # Cache of the polygons geodata\n    polygons_geodata = [None for _ in range(len(data_list)-1)]\n\n    for window in windows:\n        slice_spatial = window.toslices()\n        invalid_values_window = invalid_values[slice_spatial]\n        if not np.any(invalid_values_window):\n            continue\n\n        # Add dims to slice_obj\n        slice_obj = tuple(slice(None) for _ in range(len(data_return.shape)-2)) + slice_spatial\n        dst_transform_iter = rasterio.windows.transform(window, transform=dst_transform)\n        window_reproject_iter = rasterio.windows.Window(row_off=0, col_off=0, width=window.width, height=window.height)\n        polygon_iter = window_utils.window_polygon(window, dst_transform)\n\n        for _i, data in enumerate(data_list[1:]):\n            if isinstance(data, tuple):\n                geodata = data[0]\n                geomask = data[1]\n            else:\n                geodata = data\n                geomask = None\n\n            if polygons_geodata[_i] is None:\n                polygons_geodata[_i] = geodata.footprint(crs=dst_crs)\n\n            polygon_geodata = polygons_geodata[_i]\n\n            if not polygon_geodata.intersects(polygon_iter):\n                continue\n\n            if geomask is not None:\n                if (masking_function is None) and len(geomask.shape) &gt; 2:\n                    assert (len(geomask.shape) == 3) and (\n                                geomask.shape[0] == 1), f\"Expected two dims, found {geomask.shape}\"\n\n                invalid_geotensor = read_reproject(geomask,\n                                                   dst_crs=dst_crs, dst_transform=dst_transform_iter,\n                                                   resampling=rasterio.warp.Resampling.nearest,\n                                                   window_out=window_reproject_iter)\n                if masking_function is not None:\n                    invalid_geotensor = masking_function(invalid_geotensor)\n\n                invalid_geotensor.values = invalid_geotensor.values.astype(bool)\n                invalid_geotensor.values = invalid_geotensor.values.squeeze()\n                assert len(invalid_geotensor.shape) == 2, f\"Invalid mask expected 2 dims found {invalid_geotensor.shape}\"\n                if np.all(invalid_geotensor.values):\n                    continue\n                invalid_values_iter = invalid_geotensor.values\n\n            data_read = read_reproject(geodata, dst_crs=dst_crs, window_out=window_reproject_iter,\n                                       dst_transform=dst_transform_iter, resampling=resampling,\n                                       dtype_dst=dtype_dst,\n                                       dst_nodata=dst_nodata)\n\n            if (geomask is None) and (masking_function is not None):\n                invalid_geotensor = masking_function(data_read)\n\n                invalid_geotensor.values = invalid_geotensor.values.astype(bool)\n                invalid_geotensor.values = invalid_geotensor.values.squeeze()\n                assert len(invalid_geotensor.shape) == 2, f\"Invalid mask expected 2 dims found {invalid_geotensor.shape}\"\n                if np.all(invalid_geotensor.values):\n                    continue\n                invalid_values_iter = invalid_geotensor.values\n\n            # data_read could have more dims -&gt; any\n            masked_values_read = data_read.values == dst_nodata\n            if axis_any is not None:\n                masked_values_read = np.any(masked_values_read, axis=axis_any)  # (H, W)\n\n            if (geomask is not None) or (masking_function is not None):\n                invalid_values_iter |= masked_values_read\n            else:\n                invalid_values_iter = masked_values_read\n\n            # Copy values invalids in window and valids in iter\n            mask_values_copy_out = invalid_values_window &amp; ~invalid_values_iter\n            data_return.values[slice_obj][..., mask_values_copy_out] = data_read.values[...,mask_values_copy_out]\n\n            invalid_values_window &amp;= invalid_values_iter\n\n            if not np.any(invalid_values_window):\n                break\n\n\n    return data_return\n</code></pre>"},{"location":"modules/read_module/#window-methods_1","title":"Window Methods","text":""},{"location":"modules/read_module/#georeader.read.read_from_center_coords","title":"<code>read_from_center_coords(data_in, center_coords, shape, crs_center_coords=None, return_only_data=False, trigger_load=False, boundless=True)</code>","text":"<p>Returns a chip of <code>data_in</code> centered on <code>center_coords</code> of shape <code>shape</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>GeoData</code> <p>GeoData object</p> required <code>center_coords</code> <code>Tuple[float, float]</code> <p>x, y tuple of coords in <code>data_in</code> crs.</p> required <code>shape</code> <code>Tuple[int, int]</code> <p>shape of the window to read</p> required <code>crs_center_coords</code> <code>Optional[Any]</code> <p>CRS of center coords. If provided will check if it needs to reproject the coords before computing the reading window.</p> <code>None</code> <code>return_only_data</code> <code>bool</code> <p>defaults to <code>False</code>. If <code>True</code> it returns a np.ndarray otherwise returns an GeoData georreferenced object.</p> <code>False</code> <code>trigger_load</code> <code>bool</code> <p>defaults to <code>False</code>. Trigger loading the data to memory.</p> <code>False</code> <code>boundless</code> <code>bool</code> <p>if <code>True</code> data read will always have the shape of the provided window (padding with <code>fill_value_default</code>)</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[GeoData, ndarray]</code> <p>GeoData or np.array sliced from <code>data_in</code> of shape <code>shape</code>.</p> Source code in <code>georeader/read.py</code> <pre><code>def read_from_center_coords(data_in: GeoData, center_coords:Tuple[float, float], shape:Tuple[int,int],\n                            crs_center_coords:Optional[Any]=None,\n                            return_only_data:bool=False, trigger_load:bool=False,\n                            boundless:bool=True) -&gt; Union[GeoData, np.ndarray]:\n    \"\"\"\n    Returns a chip of `data_in` centered on `center_coords` of shape `shape`.\n\n    Args:\n        data_in: GeoData object\n        center_coords: x, y tuple of coords in `data_in` crs.\n        shape: shape of the window to read\n        crs_center_coords: CRS of center coords. If provided will check if it needs to reproject the coords before\n            computing the reading window.\n        return_only_data: defaults to `False`. If `True` it returns a np.ndarray otherwise\n            returns an GeoData georreferenced object.\n        trigger_load: defaults to `False`. Trigger loading the data to memory.\n        boundless: if `True` data read will always have the shape of the provided window\n            (padding with `fill_value_default`)\n\n    Returns:\n        GeoData or np.array sliced from `data_in` of shape `shape`.\n\n    \"\"\"\n\n    window = window_from_center_coords(data_in, center_coords, shape, crs_center_coords)\n\n    return read_from_window(data_in, window=window, return_only_data=return_only_data,\n                            trigger_load=trigger_load, boundless=boundless)\n</code></pre>"},{"location":"modules/read_module/#georeader.read.window_from_bounds","title":"<code>window_from_bounds(data_in, bounds, crs_bounds=None)</code>","text":"<p>Compute window to read in data_in from bounds in crs_bounds. If crs_bounds is None it assumes bounds are in the crs of data_in</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>Union[GeoDataBase, DatasetReader]</code> <p>Reader with crs and transform attributes</p> required <code>bounds</code> <code>Tuple[float, float, float, float]</code> <p>tuple with bounds to find the corresponding window</p> required <code>crs_bounds</code> <code>Optional[str]</code> <p>Optional coordinate reference system of the bounds. If not provided assumes same crs as <code>data_in</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Window</code> <p>Window object with location in pixel coordinates relative to <code>data_in</code> of the bounds</p> Source code in <code>georeader/read.py</code> <pre><code>def window_from_bounds(data_in: Union[GeoDataBase, rasterio.DatasetReader], \n                       bounds:Tuple[float, float, float, float],\n                       crs_bounds:Optional[str]=None) -&gt; rasterio.windows.Window:\n    \"\"\"\n    Compute window to read in data_in from bounds in crs_bounds. If crs_bounds is None it assumes bounds are in the\n    crs of data_in\n\n    Args:\n        data_in: Reader with crs and transform attributes\n        bounds: tuple with bounds to find the corresponding window\n        crs_bounds: Optional coordinate reference system of the bounds. If not provided assumes same crs as `data_in`\n\n    Returns:\n        Window object with location in pixel coordinates relative to `data_in` of the bounds\n\n    \"\"\"\n    if (crs_bounds is not None) and not window_utils.compare_crs(crs_bounds, data_in.crs):\n\n        bounds_in = rasterio.warp.transform_bounds(crs_bounds,\n                                                   data_in.crs, *bounds)\n    else:\n        bounds_in = bounds\n\n    window_in = rasterio.windows.from_bounds(*bounds_in, transform=data_in.transform)\n\n    return window_in\n</code></pre>"},{"location":"modules/read_module/#georeader.read.window_from_center_coords","title":"<code>window_from_center_coords(data_in, center_coords, shape, crs_center_coords=None)</code>","text":"<p>Compute window to read in <code>data_in</code> from the coordinates of the center pixel. If <code>crs_center_coords</code> is None it assumes  <code>center_coords</code> are in the crs of <code>data_in</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>Union[GeoDataBase, DatasetReader]</code> <p>Reader with crs and transform attributes</p> required <code>center_coords</code> <code>Tuple[float, float]</code> <p>Tuple with center coords (x, y) format</p> required <code>shape</code> <code>Tuple[int, int]</code> <p>Tuple with shape to read (H, W) format</p> required <code>crs_center_coords</code> <code>Optional[Any]</code> <p>Optional coordinate reference system of the bounds. If not provided assumes same crs as <code>data_in</code></p> <code>None</code> <p>Returns:</p> Type Description <code>Window</code> <p>Window object with location in pixel coordinates relative to <code>data_in</code> of the window centered on <code>center_coords</code></p> Source code in <code>georeader/read.py</code> <pre><code>def window_from_center_coords(data_in: Union[GeoDataBase, rasterio.DatasetReader], \n                              center_coords:Tuple[float, float],\n                              shape:Tuple[int,int], crs_center_coords:Optional[Any]=None) -&gt; rasterio.windows.Window:\n    \"\"\"\n     Compute window to read in `data_in` from the coordinates of the center pixel. If `crs_center_coords` is None it assumes\n     `center_coords` are in the crs of `data_in`.\n\n    Args:\n        data_in: Reader with crs and transform attributes\n        center_coords: Tuple with center coords (x, y) format\n        shape: Tuple with shape to read (H, W) format\n        crs_center_coords: Optional coordinate reference system of the bounds. If not provided assumes same crs as `data_in`\n\n    Returns:\n         Window object with location in pixel coordinates relative to `data_in` of the window centered on `center_coords`\n    \"\"\"\n\n    if (crs_center_coords is not None) and not window_utils.compare_crs(crs_center_coords, data_in.crs):\n        center_coords = _transform_from_crs(center_coords, crs_center_coords, data_in.crs)\n\n    # The computation of the corner coordinates from the center is the same as in utils.polygon_slices\n    transform = data_in.transform\n\n    pixel_center_coords = ~transform * tuple(center_coords)\n    pixel_upper_left =  _round_all((pixel_center_coords[0] - shape[1] / 2, pixel_center_coords[1] - shape[0] / 2))\n\n    # OLD CODE that didn't support non-rectilinear transforms\n    # assert transform.is_rectilinear(), \"Transform is not rectilear\"\n    #\n    # upper_left_coords = (center_coords[0] - (transform.a * shape[1] / 2),\n    #                      center_coords[1] - (transform.e * shape[0] / 2))\n    # pixel_upper_left = _round_all(~transform * upper_left_coords)\n\n    window = rasterio.windows.Window(row_off=pixel_upper_left[1], col_off=pixel_upper_left[0],\n                                     width=shape[1], height=shape[0])\n    return window\n</code></pre>"},{"location":"modules/read_module/#georeader.read.window_from_polygon","title":"<code>window_from_polygon(data_in, polygon, crs_polygon=None, window_surrounding=False)</code>","text":"<p>Obtains the data window that surrounds the polygon</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>Union[GeoDataBase, DatasetReader]</code> <p>Reader with crs and transform attributes</p> required <code>polygon</code> <code>Union[Polygon, MultiPolygon]</code> <p>Polygon or MultiPolygon</p> required <code>crs_polygon</code> <code>Optional[str]</code> <p>Optional coordinate reference system of the bounds. If not provided assumes same crs as <code>data_in</code></p> <code>None</code> <code>window_surrounding</code> <code>bool</code> <p>The window surrounds the polygon. (i.e. window.row_off + window.height will not be a vertex)</p> <code>False</code> <p>Returns:</p> Type Description <code>Window</code> <p>Window object with location in pixel coordinates relative to <code>data_in</code> of the polygon</p> Source code in <code>georeader/read.py</code> <pre><code>def window_from_polygon(data_in: Union[GeoDataBase, rasterio.DatasetReader],\n                        polygon:Union[Polygon, MultiPolygon], crs_polygon:Optional[str]=None,\n                        window_surrounding:bool=False) -&gt; rasterio.windows.Window:\n    \"\"\"\n    Obtains the data window that surrounds the polygon\n\n    Args:\n        data_in: Reader with crs and transform attributes\n        polygon: Polygon or MultiPolygon\n        crs_polygon: Optional coordinate reference system of the bounds. If not provided assumes same crs as `data_in`\n        window_surrounding: The window surrounds the polygon. (i.e. window.row_off + window.height will not be a vertex)\n\n    Returns:\n        Window object with location in pixel coordinates relative to `data_in` of the polygon\n\n    \"\"\"\n    data_in_crs = data_in.crs\n    data_in_transform = data_in.transform\n\n    # convert polygon to GeoData crs\n    coords_multipol = window_utils.exterior_pixel_coords(polygon=polygon, crs_polygon=crs_polygon, \n                                                         crs=data_in_crs, transform=data_in_transform)\n\n    # Figure out min max rows and cols to build the window\n    row_off = min(c[1] for coords in coords_multipol for c in coords)\n    col_off = min(c[0] for coords in coords_multipol for c in coords)\n\n    row_max = max(c[1] for coords in coords_multipol for c in coords)\n    col_max = max(c[0] for coords in coords_multipol for c in coords)\n    if window_surrounding:\n        row_max += 1\n        col_max += 1\n\n    return rasterio.windows.Window(row_off=row_off, col_off=col_off,\n                                   width=col_max-col_off,\n                                   height=row_max-row_off)\n</code></pre>"},{"location":"modules/read_module/#georeader.read.window_from_tile","title":"<code>window_from_tile(data_in, x, y, z)</code>","text":"<p>Returns the window corresponding to the x,y,z tile in the data_in.</p> <p>Tiles are TMS tiles defined as: (https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames)</p> <p>Parameters:</p> Name Type Description Default <code>data_in</code> <code>Union[GeoData, DatasetReader]</code> <p>GeoData object</p> required <code>x</code> <code>int</code> <p>x coordinate of the tile in the TMS system.</p> required <code>y</code> <code>int</code> <p>y coordinate of the tile in the TMS system.</p> required <code>z</code> <code>int</code> <p>z coordinate of the tile in the TMS system.</p> required <p>Returns:</p> Type Description <code>Window</code> <p>rasterio.windows.Window: window corresponding to the tile</p> Source code in <code>georeader/read.py</code> <pre><code>def window_from_tile(data_in: Union[GeoDataBase, rasterio.DatasetReader],\n                     x:int, y:int, z:int) -&gt; rasterio.windows.Window:\n    \"\"\"\n    Returns the window corresponding to the x,y,z tile in the data_in.\n\n    Tiles are TMS tiles defined as: (https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames)\n\n    Args:\n        data_in (Union[GeoData, rasterio.DatasetReader]):  GeoData object\n        x (int): x coordinate of the tile in the TMS system.\n        y (int): y coordinate of the tile in the TMS system.\n        z (int): z coordinate of the tile in the TMS system.\n\n    Returns:\n        rasterio.windows.Window: window corresponding to the tile\n    \"\"\"\n    bounds_wgs = mercantile.xy_bounds(int(x), int(y), int(z))\n    polygon_crs_webmercator = box(bounds_wgs.left, bounds_wgs.bottom, bounds_wgs.right, bounds_wgs.top)\n    return window_from_polygon(data_in, polygon_crs_webmercator, WEB_MERCATOR_CRS,\n                               window_surrounding=True)\n</code></pre>"},{"location":"modules/read_module/#georeader.mosaic.spatial_mosaic","title":"<code>spatial_mosaic(data_list, polygon=None, crs_polygon=None, dst_transform=None, bounds=None, dst_crs=None, dtype_dst=None, window_size=None, resampling=rasterio.warp.Resampling.cubic_spline, masking_function=None, dst_nodata=None)</code>","text":"<p>Computes the spatial mosaic of all input products in <code>data_list</code>. It iteratively calls <code>read_reproject</code> with all the list of rasters while there is any <code>dst_nodata</code> value. This function m requires that the copy of the output fits in memory.</p> <p>This function is very similar to <code>rasterio.merge.merge</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>Union[List[GeoData], List[Tuple[GeoData, GeoData]]]</code> <p>List of raster objects. each element could be a single geodata object or a tuple of an object and a mask (second item will be considered the invalid values mask).</p> required <code>polygon</code> <code>Optional[Polygon]</code> <p>polygon to compute the mosaic in crs_polygon</p> <code>None</code> <code>crs_polygon</code> <code>Optional[str]</code> <p>CRS of the polygon. If not provided it will use the CRS of the first product of the list.</p> <code>None</code> <code>bounds</code> <code>Optional[Tuple[float, float, float, float]]</code> <p>bounds to compute the mosaic.</p> <code>None</code> <code>dst_crs</code> <code>Optional[str]</code> <p>CRS of the product. If not provided it will use the CRS of the first product of the list</p> <code>None</code> <code>dst_transform</code> <code>Optional[Affine]</code> <p>Optional dest transform. If not provided the dst_transform is a rectilinear transform computed</p> <code>None</code> <code>window_size</code> <code>Optional[Tuple[int, int]]</code> <p>The mosaic will be computed by windows of this size (for efficiency purposes)</p> <code>None</code> <code>resampling</code> <code>Resampling</code> <p>specifies how data is reprojected from <code>rasterio.warp.Resampling</code>.</p> <code>cubic_spline</code> <code>masking_function</code> <code>Optional[Callable[[GeoData], GeoData]]</code> <p>function to call to the mask if provided or to the tensor (if not provided) should return a bool tensor with only spatial dimensions.</p> <code>None</code> <code>dst_nodata</code> <code>Optional[int]</code> <p>no data value. if None will use <code>data_list[0].fill_value_default</code></p> <code>None</code> <p>Returns:</p> Type Description <code>GeoTensor</code> <p>GeoTensor with mosaic over the given bounds</p> Source code in <code>georeader/mosaic.py</code> <pre><code>def spatial_mosaic(data_list:Union[List[GeoData], List[Tuple[GeoData,GeoData]]],\n                   polygon:Optional[Polygon]=None,\n                   crs_polygon:Optional[str]=None,\n                   dst_transform:Optional[rasterio.transform.Affine]=None,\n                   bounds:Optional[Tuple[float, float, float, float]]=None,\n                   dst_crs:Optional[str]=None,\n                   dtype_dst:Optional[str]=None,\n                   window_size: Optional[Tuple[int, int]]= None,\n                   resampling:rasterio.warp.Resampling=rasterio.warp.Resampling.cubic_spline,\n                   masking_function:Optional[Callable[[GeoData], GeoData]]=None,\n                   dst_nodata:Optional[int]=None) -&gt; GeoTensor:\n    \"\"\"\n    Computes the spatial mosaic of all input products in `data_list`. It iteratively calls `read_reproject` with\n    all the list of rasters while there is any `dst_nodata` value. This function m requires that the copy of the output\n    fits in memory.\n\n    This function is very similar to `rasterio.merge.merge`.\n\n    Args:\n        data_list: List of raster objects. each element could be a single geodata object or a tuple of an object and a\n            mask (second item will be considered the invalid values mask).\n        polygon: polygon to compute the mosaic in crs_polygon\n        crs_polygon: CRS of the polygon. If not provided it will use the CRS of the first product of the list.\n        bounds: bounds to compute the mosaic.\n        dst_crs: CRS of the product. If not provided it will use the CRS of the first product of the list\n        dst_transform: Optional dest transform. If not provided the dst_transform is a rectilinear transform computed\n        window_size: The mosaic will be computed by windows of this size (for efficiency purposes)\n        resampling:specifies how data is reprojected from `rasterio.warp.Resampling`.\n        masking_function: function to call to the mask if provided or to the tensor (if not provided) should return a bool tensor\n            with only spatial dimensions.\n        dst_nodata: no data value. if None will use `data_list[0].fill_value_default`\n\n    Returns:\n        GeoTensor with mosaic over the given bounds\n\n    \"\"\"\n\n    assert len(data_list) &gt; 0, f\"Expected at least one product found 0 {data_list}\"\n\n    if isinstance(data_list[0], tuple):\n        first_data_object =  data_list[0][0]\n        first_mask_object = data_list[0][1]\n    else:\n        first_data_object = data_list[0]\n        first_mask_object = None\n\n    if dst_transform is None:\n        dst_transform = first_data_object.transform\n\n    if dst_crs is None:\n        dst_crs = first_data_object.crs\n\n    if polygon is None:\n        if bounds is not None:\n            polygon = box(*bounds)\n        else:\n            # Polygon is the Union of the polygons of all the data\n            for data in data_list:\n                if isinstance(data, tuple):\n                    data = data[0]\n                polygon_iter = data.footprint(crs=dst_crs)\n\n                if polygon is None:\n                    polygon = polygon_iter\n                else:\n                    polygon = polygon.union(polygon_iter)\n    else:\n        if crs_polygon is None:\n            crs_polygon = dst_crs\n        elif not georeader.compare_crs(crs_polygon, dst_crs):\n            polygon = window_utils.polygon_to_crs(polygon, crs_polygon, dst_crs)\n\n    GeoDataFake = namedtuple(\"GeoDataFake\", [\"transform\", \"crs\"])\n    window_polygon = read.window_from_polygon(GeoDataFake(transform=dst_transform, crs=dst_crs),\n                                              polygon, crs_polygon=dst_crs)\n\n    window_polygon = window_utils.round_outer_window(window_polygon)\n\n    # Shift transform to window\n    dst_transform = rasterio.windows.transform(window_polygon, transform=dst_transform)\n    dst_nodata = dst_nodata or first_data_object.fill_value_default\n\n    # Get object to save the results\n    data_return = read_reproject(first_data_object,\n                                 dst_crs=dst_crs, dst_transform=dst_transform,\n                                 resampling=resampling,\n                                 dtype_dst=dtype_dst,\n                                 window_out=rasterio.windows.Window(row_off=0, col_off=0, width=window_polygon.width,\n                                                                    height=window_polygon.height),\n                                 dst_nodata=dst_nodata)\n\n    # invalid_values of spatial locations only  -&gt; any\n    invalid_values = data_return.values == dst_nodata\n    if len(data_return.shape) &gt; 2:\n        axis_any = tuple(i for i in range(len(data_return.shape)-2))\n        invalid_values = np.any(invalid_values, axis=axis_any) # (H, W)\n    else:\n        axis_any = None\n\n    if first_mask_object is not None:\n        if (masking_function is None) and len(first_mask_object.shape) &gt; 2:\n            assert (len(first_mask_object.shape) == 3) and (first_mask_object.shape[0] == 1), f\"Expected two dims, found {first_mask_object.shape}\"\n\n        invalid_geotensor = read_reproject(first_mask_object,\n                                           dst_crs=dst_crs, dst_transform=dst_transform,\n                                           resampling=rasterio.warp.Resampling.nearest,\n                                           window_out=rasterio.windows.Window(row_off=0, col_off=0,\n                                                                              width=window_polygon.width,\n                                                                              height=window_polygon.height))\n        if masking_function is not None:\n            invalid_geotensor = masking_function(invalid_geotensor)\n\n        invalid_geotensor.values = invalid_geotensor.values.astype(bool)\n        invalid_geotensor.values =  invalid_geotensor.values.squeeze()\n        assert len(invalid_geotensor.shape) == 2, f\"Invalid mask expected 2 dims found {invalid_geotensor.shape}\"\n\n        invalid_values|= invalid_geotensor.values\n    elif masking_function is not None:\n        # Apply masking funtion to the readed data\n        invalid_geotensor = masking_function(data_return)\n\n        invalid_geotensor.values = invalid_geotensor.values.astype(bool)\n        invalid_geotensor.values = invalid_geotensor.values.squeeze()\n        assert len(invalid_geotensor.shape) == 2, f\"Invalid mask expected 2 dims found {invalid_geotensor.shape}\"\n        invalid_values |= invalid_geotensor.values\n\n    # data_return.values[..., invalid_values] = data_return.fill_value_default\n\n    if not np.any(invalid_values):\n        return data_return\n\n    if len(data_list) == 1:\n        return data_return\n\n    if window_size is not None:\n        windows = slices.create_windows(data_return.shape[-2:], window_size)\n    else:\n        windows = [rasterio.windows.Window(row_off=0, col_off=0, width=data_return.shape[-1],\n                                           height=data_return.shape[-2])]\n\n    # Cache of the polygons geodata\n    polygons_geodata = [None for _ in range(len(data_list)-1)]\n\n    for window in windows:\n        slice_spatial = window.toslices()\n        invalid_values_window = invalid_values[slice_spatial]\n        if not np.any(invalid_values_window):\n            continue\n\n        # Add dims to slice_obj\n        slice_obj = tuple(slice(None) for _ in range(len(data_return.shape)-2)) + slice_spatial\n        dst_transform_iter = rasterio.windows.transform(window, transform=dst_transform)\n        window_reproject_iter = rasterio.windows.Window(row_off=0, col_off=0, width=window.width, height=window.height)\n        polygon_iter = window_utils.window_polygon(window, dst_transform)\n\n        for _i, data in enumerate(data_list[1:]):\n            if isinstance(data, tuple):\n                geodata = data[0]\n                geomask = data[1]\n            else:\n                geodata = data\n                geomask = None\n\n            if polygons_geodata[_i] is None:\n                polygons_geodata[_i] = geodata.footprint(crs=dst_crs)\n\n            polygon_geodata = polygons_geodata[_i]\n\n            if not polygon_geodata.intersects(polygon_iter):\n                continue\n\n            if geomask is not None:\n                if (masking_function is None) and len(geomask.shape) &gt; 2:\n                    assert (len(geomask.shape) == 3) and (\n                                geomask.shape[0] == 1), f\"Expected two dims, found {geomask.shape}\"\n\n                invalid_geotensor = read_reproject(geomask,\n                                                   dst_crs=dst_crs, dst_transform=dst_transform_iter,\n                                                   resampling=rasterio.warp.Resampling.nearest,\n                                                   window_out=window_reproject_iter)\n                if masking_function is not None:\n                    invalid_geotensor = masking_function(invalid_geotensor)\n\n                invalid_geotensor.values = invalid_geotensor.values.astype(bool)\n                invalid_geotensor.values = invalid_geotensor.values.squeeze()\n                assert len(invalid_geotensor.shape) == 2, f\"Invalid mask expected 2 dims found {invalid_geotensor.shape}\"\n                if np.all(invalid_geotensor.values):\n                    continue\n                invalid_values_iter = invalid_geotensor.values\n\n            data_read = read_reproject(geodata, dst_crs=dst_crs, window_out=window_reproject_iter,\n                                       dst_transform=dst_transform_iter, resampling=resampling,\n                                       dtype_dst=dtype_dst,\n                                       dst_nodata=dst_nodata)\n\n            if (geomask is None) and (masking_function is not None):\n                invalid_geotensor = masking_function(data_read)\n\n                invalid_geotensor.values = invalid_geotensor.values.astype(bool)\n                invalid_geotensor.values = invalid_geotensor.values.squeeze()\n                assert len(invalid_geotensor.shape) == 2, f\"Invalid mask expected 2 dims found {invalid_geotensor.shape}\"\n                if np.all(invalid_geotensor.values):\n                    continue\n                invalid_values_iter = invalid_geotensor.values\n\n            # data_read could have more dims -&gt; any\n            masked_values_read = data_read.values == dst_nodata\n            if axis_any is not None:\n                masked_values_read = np.any(masked_values_read, axis=axis_any)  # (H, W)\n\n            if (geomask is not None) or (masking_function is not None):\n                invalid_values_iter |= masked_values_read\n            else:\n                invalid_values_iter = masked_values_read\n\n            # Copy values invalids in window and valids in iter\n            mask_values_copy_out = invalid_values_window &amp; ~invalid_values_iter\n            data_return.values[slice_obj][..., mask_values_copy_out] = data_read.values[...,mask_values_copy_out]\n\n            invalid_values_window &amp;= invalid_values_iter\n\n            if not np.any(invalid_values_window):\n                break\n\n\n    return data_return\n</code></pre>"},{"location":"modules/readers_module/","title":"Satellite Data Readers","text":"<p>This module provides specialized readers for various optical satellite missions. All these readers implement the GeoData protocol, which means they provide a consistent interface for spatial operations, data access, and manipulation.</p> <p>These readers make it easy to work with official data formats from different Earth observation missions, and they can be used with all the functions available in the <code>georeader.read</code> module.</p> <p>Readers available:</p> <ul> <li>Sentinel-2</li> <li>Proba-V</li> <li>SpotVGT</li> <li>EMIT</li> <li>PRISMA</li> <li>EnMAP</li> </ul>"},{"location":"modules/readers_module/#sentinel-2-reader","title":"Sentinel-2 Reader","text":"<p>The Sentinel-2 reader provides functionality for reading Sentinel-2 L1C and L2A products in SAFE format. It supports:</p> <ul> <li>Direct reading from local files or cloud storage (Google Cloud Storage)</li> <li>Windowed reading for efficient memory usage</li> <li>Conversion from digital numbers to radiance</li> <li>Access to metadata, including viewing geometry and solar angles</li> </ul> <p>Tutorial examples:</p> <ul> <li>Reading from the public Google bucket</li> <li>Exploring image metadata</li> <li>Creating mosaics from multiple images</li> <li>Converting TOA reflectance to radiance</li> </ul>"},{"location":"modules/readers_module/#api-reference","title":"API Reference","text":"<p>Sentinel-2 reader inherited from https://github.com/IPL-UV/DL-L8S2-UV.</p> <p>Authors: Gonzalo Mateo-Garc\u00eda, Dan Lopez-Puigdollers</p> <p>It has several enhancements:</p> <ul> <li>Support for S2L2A images</li> <li>It can read directly images from a GCP bucket (for example data from  here)</li> <li>Windowed read and read and reproject in the same function (see <code>load_bands_bbox</code>)</li> <li>Creation of the image only involves reading one metadata file (<code>xxx.SAFE/MTD_{self.producttype}.xml</code>)</li> <li>Compatible with <code>georeader.read</code> functions</li> <li>It can read from the pyramid if available.</li> </ul> <p>Sentinel-2 docs</p>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2Image","title":"<code>S2Image</code>","text":"<p>Base Sentinel-2 image reader for handling Sentinel-2 satellite products. Do Not use this class directly, use S2ImageL1C or S2ImageL2A instead.</p> <p>This class provides functionality to read and manipulate Sentinel-2 satellite imagery. It handles the specific format and metadata of Sentinel-2 products, supporting operations like loading bands, masks, and converting digital numbers to radiance.</p> <p>Parameters:</p> Name Type Description Default <code>s2folder</code> <code>str</code> <p>Path to the Sentinel-2 SAFE product folder.</p> required <code>polygon</code> <code>Optional[Polygon]</code> <p>Polygon defining the area of interest in EPSG:4326. Defaults to None (entire image).</p> <code>None</code> <code>granules</code> <code>Optional[Dict[str, str]]</code> <p>Dictionary mapping band names to file paths. Defaults to None (automatically discovered).</p> <code>None</code> <code>out_res</code> <code>int</code> <p>Output resolution in meters. Must be one of 10, 20, or 60. Defaults to 10.</p> <code>10</code> <code>window_focus</code> <code>Optional[Window]</code> <p>Window to focus on a specific region of the image. Defaults to None (entire image).</p> <code>None</code> <code>bands</code> <code>Optional[List[str]]</code> <p>List of bands to read. If None, all available bands will be loaded based on the product type.</p> <code>None</code> <code>metadata_msi</code> <code>Optional[str]</code> <p>Path to metadata file. If None, it is assumed to be in the SAFE folder.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>mission</code> <code>str</code> <p>Mission identifier (e.g., 'S2A', 'S2B').</p> <code>producttype</code> <code>str</code> <p>Product type identifier (e.g., 'MSIL1C', 'MSIL2A').</p> <code>pdgs</code> <code>str</code> <p>PDGS Processing Baseline number.</p> <code>relorbitnum</code> <code>str</code> <p>Relative Orbit number.</p> <code>tile_number_field</code> <code>str</code> <p>Tile Number field.</p> <code>product_discriminator</code> <code>str</code> <p>Product Discriminator.</p> <code>name</code> <code>str</code> <p>Base name of the product.</p> <code>folder</code> <code>str</code> <p>Path to the product folder.</p> <code>datetime</code> <code>datetime</code> <p>Acquisition datetime.</p> <code>metadata_msi</code> <code>str</code> <p>Path to the MSI metadata file.</p> <code>out_res</code> <code>int</code> <p>Output resolution in meters.</p> <code>bands</code> <code>List[str]</code> <p>List of bands to read.</p> <code>dims</code> <code>Tuple[str]</code> <p>Names of the dimensions (\"band\", \"y\", \"x\").</p> <code>fill_value_default</code> <code>int</code> <p>Default fill value (typically 0).</p> <code>band_check</code> <code>str</code> <p>Band used as template for reading.</p> <code>granule_readers</code> <code>Dict[str, RasterioReader]</code> <p>Dictionary of readers for each band.</p> <code>window_focus</code> <code>Window</code> <p>Current window focus.</p> <code>transform</code> <p>Affine transform for the window.</p> <code>crs</code> <p>Coordinate reference system.</p> <code>shape</code> <p>Shape of the data (bands, height, width).</p> <code>bounds</code> <p>Bounds of the window.</p> <code>res</code> <code>Tuple[float, float]</code> <p>Resolution of the data.</p> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>class S2Image:\n    \"\"\"\n    Base Sentinel-2 image reader for handling Sentinel-2 satellite products.\n    Do Not use this class directly, use S2ImageL1C or S2ImageL2A instead.\n\n    This class provides functionality to read and manipulate Sentinel-2 satellite imagery.\n    It handles the specific format and metadata of Sentinel-2 products, supporting operations\n    like loading bands, masks, and converting digital numbers to radiance.\n\n    Args:\n        s2folder (str): Path to the Sentinel-2 SAFE product folder.\n        polygon (Optional[Polygon]): Polygon defining the area of interest in EPSG:4326.\n            Defaults to None (entire image).\n        granules (Optional[Dict[str, str]]): Dictionary mapping band names to file paths.\n            Defaults to None (automatically discovered).\n        out_res (int): Output resolution in meters. Must be one of 10, 20, or 60. Defaults to 10.\n        window_focus (Optional[rasterio.windows.Window]): Window to focus on a specific\n            region of the image. Defaults to None (entire image).\n        bands (Optional[List[str]]): List of bands to read. If None, all available bands\n            will be loaded based on the product type.\n        metadata_msi (Optional[str]): Path to metadata file. If None, it is assumed to be\n            in the SAFE folder.\n\n    Attributes:\n        mission (str): Mission identifier (e.g., 'S2A', 'S2B').\n        producttype (str): Product type identifier (e.g., 'MSIL1C', 'MSIL2A').\n        pdgs (str): PDGS Processing Baseline number.\n        relorbitnum (str): Relative Orbit number.\n        tile_number_field (str): Tile Number field.\n        product_discriminator (str): Product Discriminator.\n        name (str): Base name of the product.\n        folder (str): Path to the product folder.\n        datetime (datetime): Acquisition datetime.\n        metadata_msi (str): Path to the MSI metadata file.\n        out_res (int): Output resolution in meters.\n        bands (List[str]): List of bands to read.\n        dims (Tuple[str]): Names of the dimensions (\"band\", \"y\", \"x\").\n        fill_value_default (int): Default fill value (typically 0).\n        band_check (str): Band used as template for reading.\n        granule_readers (Dict[str, RasterioReader]): Dictionary of readers for each band.\n        window_focus (rasterio.windows.Window): Current window focus.\n        transform: Affine transform for the window.\n        crs: Coordinate reference system.\n        shape: Shape of the data (bands, height, width).\n        bounds: Bounds of the window.\n        res: Resolution of the data.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        s2folder: str,\n        polygon: Optional[Polygon] = None,\n        granules: Optional[Dict[str, str]] = None,\n        out_res: int = 10,\n        window_focus: Optional[rasterio.windows.Window] = None,\n        bands: Optional[List[str]] = None,\n        metadata_msi: Optional[str] = None,\n    ):\n        \"\"\"\n        Sentinel-2 image reader class.\n\n        Args:\n            s2folder: name of the SAFE product expects name\n            polygon: in CRS EPSG:4326\n            granules: dictionary with granule name and path\n            out_res: output resolution in meters one of 10, 20, 60 (default 10)\n            window_focus: rasterio window to read. All reads will be based on this window\n            bands: list of bands to read. If None all bands are read.\n            metadata_msi: path to metadata file. If None it is assumed to be in the SAFE folder\n\n        \"\"\"\n        (\n            self.mission,\n            self.producttype,\n            sensing_date_str,\n            self.pdgs,\n            self.relorbitnum,\n            self.tile_number_field,\n            self.product_discriminator,\n        ) = s2_name_split(s2folder)\n\n        # Remove last trailing slash\n        s2folder = (\n            s2folder[:-1]\n            if (s2folder.endswith(\"/\") or s2folder.endswith(\"\\\\\"))\n            else s2folder\n        )\n        self.name = os.path.basename(os.path.splitext(s2folder)[0])\n\n        self.folder = s2folder\n        self.datetime = datetime.datetime.strptime(\n            sensing_date_str, \"%Y%m%dT%H%M%S\"\n        ).replace(tzinfo=datetime.timezone.utc)\n\n        info_granules_metadata = None\n\n        if metadata_msi is None:\n            info_granules_metadata = _get_info_granules_metadata(self.folder)\n            if info_granules_metadata is not None:\n                self.metadata_msi = info_granules_metadata[\"metadata_msi\"]\n                if \"metadata_tl\" in info_granules_metadata:\n                    self.metadata_tl = info_granules_metadata[\"metadata_tl\"]\n            else:\n                self.metadata_msi = os.path.join(\n                    self.folder, f\"MTD_{self.producttype}.xml\"\n                ).replace(\"\\\\\", \"/\")\n\n        else:\n            self.metadata_msi = metadata_msi\n\n        out_res = int(out_res)\n\n        # TODO increase possible out_res to powers of 2 of 10 meters and 60 meters\n        # rst = rasterio.open('gs://gcp-public-data-sentinel-2/tiles/49/S/GV/S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE/GRANULE/L1C_T49SGV_A027271_20220527T031740/IMG_DATA/T49SGV_20220527T030539_B02.jp2')\n        # rst.overviews(1) -&gt; [2, 4, 8, 16]\n        assert out_res in {10, 20, 60}, \"Not valid output resolution.Choose 10, 20, 60\"\n\n        # Default resolution to read\n        self.out_res = out_res\n\n        if bands is None:\n            if self.producttype == \"MSIL2A\":\n                self.bands = list(BANDS_S2_L2A)\n            else:\n                self.bands = list(BANDS_S2)\n        else:\n            self.bands = normalize_band_names(bands)\n\n        self.dims = (\"band\", \"y\", \"x\")\n        self.fill_value_default = 0\n\n        # Select the band that will be used as template when reading\n        self.band_check = None\n        for band in self.bands:\n            if BANDS_RESOLUTION[band] == self.out_res:\n                self.band_check = band\n                break\n\n        assert (\n            self.band_check is not None\n        ), f\"Not band found of resolution {self.out_res} in {self.bands}\"\n\n        # This dict will be filled by the _get_reader function\n        self.granule_readers: Dict[str, RasterioReader] = {}\n        self.window_focus = window_focus\n        self.root_metadata_msi = None\n        self._radio_add_offsets = None\n        self._solar_irradiance = None\n        self._scale_factor_U = None\n        self._quantification_value = None\n\n        # The code below could be only triggered if required\n        if not granules:\n            # This is useful when copying with cache_product_to_local_dir func\n            if info_granules_metadata is None:\n                info_granules_metadata = _get_info_granules_metadata(self.folder)\n\n            if info_granules_metadata is not None:\n                self.granules = info_granules_metadata[\"granules\"]\n\n            else:\n                self.load_metadata_msi()\n                bands_elms = self.root_metadata_msi.findall(\".//IMAGE_FILE\")\n                all_granules = [\n                    os.path.join(self.folder, b.text + \".jp2\").replace(\"\\\\\", \"/\")\n                    for b in bands_elms\n                ]\n                if self.producttype == \"MSIL2A\":\n                    self.granules = {j.split(\"_\")[-2]: j for j in all_granules}\n                else:\n                    self.granules = {\n                        j.split(\"_\")[-1].replace(\".jp2\", \"\"): j for j in all_granules\n                    }\n        else:\n            self.granules = granules\n\n        self._pol = polygon\n        if self._pol is not None:\n            self._pol_crs = window_utils.polygon_to_crs(\n                self._pol, \"EPSG:4326\", self.crs\n            )\n        else:\n            self._pol_crs = None\n\n    def cache_product_to_local_dir(\n        self,\n        path_dest: Optional[str] = None,\n        print_progress: bool = True,\n        format_bands: Optional[str] = None,\n    ) -&gt; \"__class__\":\n        \"\"\"\n        Copy the product to a local directory and return a new instance of the class with the new path\n\n        Args:\n            path_dest: path to the destination folder. If None, the current folder ()\".\") is used\n            print_progress: print progress bar. Default True\n            format_bands: format of the bands. Default None (keep original format). Options: \"COG\", \"GeoTIFF\"\n\n        Returns:\n            A new instance of the class pointing to the new path\n        \"\"\"\n        if path_dest is None:\n            path_dest = \".\"\n\n        if format_bands is not None:\n            assert format_bands in {\n                \"COG\",\n                \"GeoTIFF\",\n            }, \"Not valid format_bands. Choose 'COG' or 'GeoTIFF'\"\n\n        name_with_safe = f\"{self.name}.SAFE\"\n        dest_folder = os.path.join(path_dest, name_with_safe)\n\n        # Copy metadata\n        metadata_filename = os.path.basename(self.metadata_msi)\n        metadata_output_path = os.path.join(dest_folder, metadata_filename)\n        if not os.path.exists(metadata_output_path):\n            os.makedirs(dest_folder, exist_ok=True)\n            self.load_metadata_msi()\n            ET.ElementTree(self.root_metadata_msi).write(metadata_output_path)\n            root_metadata_msi = self.root_metadata_msi\n        else:\n            root_metadata_msi = read_xml(metadata_output_path)\n\n        bands_elms = root_metadata_msi.findall(\".//IMAGE_FILE\")\n        if self.producttype == \"MSIL2A\":\n            granules_name_metadata = {b.text.split(\"_\")[-2]: b.text for b in bands_elms}\n        else:\n            granules_name_metadata = {b.text.split(\"_\")[-1]: b.text for b in bands_elms}\n\n        new_granules = {}\n        with tqdm(total=len(self.bands), disable=not print_progress) as pbar:\n            for b in self.bands:\n                granule = self.granules[b]\n                ext_origin = os.path.splitext(granule)[1]\n\n                if format_bands is not None:\n                    if ext_origin.startswith(\".tif\"):\n                        convert = False\n                    else:\n                        convert = True\n\n                    ext_dst = \".tif\"\n                else:\n                    convert = False\n                    ext_dst = ext_origin\n\n                namefile = os.path.splitext(granules_name_metadata[b])[0]\n                new_granules[b] = namefile + ext_dst\n                new_granules_path = os.path.join(dest_folder, new_granules[b])\n                if not os.path.exists(new_granules_path):\n                    new_granules_path_tmp = os.path.join(\n                        dest_folder, namefile + ext_origin\n                    )\n                    pbar.set_description(\n                        f\"Donwloading band {b} from {granule} to {new_granules_path}\"\n                    )\n                    dir_granules_path = os.path.dirname(new_granules_path)\n                    os.makedirs(dir_granules_path, exist_ok=True)\n                    get_file(granule, new_granules_path_tmp)\n                    if convert:\n                        image = RasterioReader(new_granules_path_tmp).load().squeeze()\n                        if format_bands == \"COG\":\n                            save_cog(image, new_granules_path, descriptions=[b])\n                        elif format_bands == \"GeoTIFF\":\n                            save_tiled_geotiff(\n                                image, new_granules_path, descriptions=[b]\n                            )\n                        else:\n                            raise NotImplementedError(f\"Not implemented {format_bands}\")\n                        os.remove(new_granules_path_tmp)\n\n                pbar.update(1)\n\n        # Save granules for fast reading\n        granules_path = os.path.join(dest_folder, \"granules.json\").replace(\"\\\\\", \"/\")\n        if not os.path.exists(granules_path):\n            with open(granules_path, \"w\") as fh:\n                json.dump(\n                    {\"granules\": new_granules, \"metadata_msi\": metadata_filename}, fh\n                )\n\n        new_granules_full_path = {\n            k: os.path.join(dest_folder, v) for k, v in new_granules.items()\n        }\n\n        obj = s2loader(\n            s2folder=dest_folder,\n            out_res=self.out_res,\n            window_focus=self.window_focus,\n            bands=self.bands,\n            granules=new_granules_full_path,\n            polygon=self._pol,\n            metadata_msi=metadata_output_path,\n        )\n        obj.root_metadata_msi = root_metadata_msi\n        return obj\n\n    def DN_to_radiance(self, dn_data: Optional[GeoTensor] = None) -&gt; GeoTensor:\n        return DN_to_radiance(self, dn_data)\n\n    def load_metadata_msi(self) -&gt; ET.Element:\n        if self.root_metadata_msi is None:\n            self.root_metadata_msi = read_xml(self.metadata_msi)\n        return self.root_metadata_msi\n\n    def footprint(self, crs: Optional[str] = None) -&gt; Polygon:\n        if self._pol_crs is None:\n            self.load_metadata_msi()\n            footprint_txt = self.root_metadata_msi.findall(\".//EXT_POS_LIST\")[0].text\n            coords_split = footprint_txt.split(\" \")[:-1]\n            self._pol = Polygon(\n                [\n                    (float(lngstr), float(latstr))\n                    for latstr, lngstr in zip(coords_split[::2], coords_split[1::2])\n                ]\n            )\n            self._pol_crs = window_utils.polygon_to_crs(\n                self._pol, \"EPSG:4326\", self.crs\n            )\n\n        pol_window = window_utils.window_polygon(\n            self._get_reader().window_focus, self.transform\n        )\n\n        pol = self._pol_crs.intersection(pol_window)\n\n        if (crs is None) or window_utils.compare_crs(self.crs, crs):\n            return pol\n\n        return window_utils.polygon_to_crs(pol, self.crs, crs)\n\n    def radio_add_offsets(self) -&gt; Dict[str, float]:\n        if self._radio_add_offsets is None:\n            self.load_metadata_msi()\n            radio_add_offsets = self.root_metadata_msi.findall(\".//RADIO_ADD_OFFSET\")\n            if len(radio_add_offsets) == 0:\n                self._radio_add_offsets = {b: 0 for b in BANDS_S2}\n            else:\n                self._radio_add_offsets = {\n                    BANDS_S2[int(r.attrib[\"band_id\"])]: int(r.text)\n                    for r in radio_add_offsets\n                }\n\n        return self._radio_add_offsets\n\n    def solar_irradiance(self) -&gt; Dict[str, float]:\n        \"\"\"\n        Returns solar irradiance per nanometer: W/m\u00b2/nm\n\n        Reads solar irradiance from metadata_msi:\n            &lt;SOLAR_IRRADIANCE bandId=\"0\" unit=\"W/m\u00b2/\u00b5m\"&gt;1874.3&lt;/SOLAR_IRRADIANCE&gt;\n        \"\"\"\n        if self._solar_irradiance is None:\n            self.load_metadata_msi()\n            sr = self.root_metadata_msi.findall(\".//SOLAR_IRRADIANCE\")\n            self._solar_irradiance = {\n                BANDS_S2[int(r.attrib[\"bandId\"])]: float(r.text) / 1_000 for r in sr\n            }\n\n        return self._solar_irradiance\n\n    def scale_factor_U(self) -&gt; float:\n        if self._scale_factor_U is None:\n            self.load_metadata_msi()\n            self._scale_factor_U = float(self.root_metadata_msi.find(\".//U\").text)\n\n        return self._scale_factor_U\n\n    def quantification_value(self) -&gt; int:\n        \"\"\"Returns the quantification value stored in the metadata msi file (this is always: 10_000)\"\"\"\n        if self._quantification_value is None:\n            self.load_metadata_msi()\n            self._quantification_value = int(\n                self.root_metadata_msi.find(\".//QUANTIFICATION_VALUE\").text\n            )\n\n        return self._quantification_value\n\n    def get_reader(\n        self, band_names: Union[str, List[str]], overview_level: Optional[int] = None\n    ) -&gt; RasterioReader:\n        \"\"\"\n        Provides a RasterioReader object to read all the bands at the same resolution\n\n        Args:\n            band_names: List of band names or band. raises assertion error if bands have different resolution.\n            overview_level: level of the pyramid to read (same as in rasterio)\n\n        Returns:\n            RasterioReader\n\n        \"\"\"\n        if isinstance(band_names, str):\n            band_names = [band_names]\n\n        band_names = normalize_band_names(band_names)\n\n        assert all(\n            BANDS_RESOLUTION[band_names[0]] == BANDS_RESOLUTION[b] for b in band_names\n        ), f\"Bands: {band_names} have different resolution\"\n\n        reader = RasterioReader(\n            [self.granules[band_name] for band_name in band_names],\n            window_focus=None,\n            stack=False,\n            fill_value_default=self.fill_value_default,\n            overview_level=overview_level,\n        )\n        window_in = read.window_from_bounds(reader, self.bounds)\n        window_in_rounded = read.round_outer_window(window_in)\n        reader.set_window(window_in_rounded)\n        return reader\n\n    def _get_reader(self, band_name: Optional[str] = None) -&gt; RasterioReader:\n        if band_name is None:\n            band_name = self.band_check\n\n        if band_name not in self.granule_readers:\n            # TODO handle different out_res than 10, 20, 60?\n            if self.out_res == BANDS_RESOLUTION[band_name]:\n                overview_level = None\n                has_out_res = True\n            elif self.out_res == BANDS_RESOLUTION[band_name] * 2:\n                # out_res == 20 and BANDS_RESOLUTION[band_name]==10 -&gt; read from first overview\n                overview_level = 0\n                has_out_res = True\n            elif self.out_res &gt; BANDS_RESOLUTION[band_name]:\n                # out_res 60 and BANDS_RESOLUTION[band_name] == 10 or BANDS_RESOLUTION[band_name] == 20\n                overview_level = 1 if BANDS_RESOLUTION[band_name] == 10 else 0\n                has_out_res = False\n            else:\n                overview_level = None\n                has_out_res = False\n\n            # figure out which window_focus to set\n\n            if band_name == self.band_check:\n                window_focus = self.window_focus\n                set_window_after = False\n            elif has_out_res:\n                window_focus = self.window_focus\n                set_window_after = False\n            else:\n                set_window_after = True\n                window_focus = None\n\n            self.granule_readers[band_name] = RasterioReader(\n                self.granules[band_name],\n                window_focus=window_focus,\n                fill_value_default=self.fill_value_default,\n                overview_level=overview_level,\n            )\n            if set_window_after:\n                window_in = read.window_from_bounds(\n                    self.granule_readers[band_name], self.bounds\n                )\n                window_in_rounded = read.round_outer_window(window_in)\n                self.granule_readers[band_name].set_window(window_in_rounded)\n\n        return self.granule_readers[band_name]\n\n    @property\n    def dtype(self):\n        # This is always np.uint16\n        reader_band_check = self._get_reader()\n        return reader_band_check.dtype\n\n    @property\n    def shape(self):\n        reader_band_check = self._get_reader()\n        return (len(self.bands),) + reader_band_check.shape[-2:]\n\n    @property\n    def transform(self):\n        reader_band_check = self._get_reader()\n        return reader_band_check.transform\n\n    @property\n    def crs(self):\n        reader_band_check = self._get_reader()\n        return reader_band_check.crs\n\n    @property\n    def bounds(self):\n        reader_band_check = self._get_reader()\n        return reader_band_check.bounds\n\n    @property\n    def res(self) -&gt; Tuple[float, float]:\n        reader_band_check = self._get_reader()\n        return reader_band_check.res\n\n    def __str__(self):\n        return self.folder\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\" \n         {self.folder}\n         Transform: {self.transform}\n         Shape: {self.shape}\n         Resolution: {self.res}\n         Bounds: {self.bounds}\n         CRS: {self.crs}\n         bands: {self.bands}\n         fill_value_default: {self.fill_value_default}\n        \"\"\"\n\n    def read_from_band_names(self, band_names: List[str]) -&gt; \"__class__\":\n        \"\"\"\n        Read from band names\n\n        Args:\n            band_names: List of band names\n\n        Returns:\n            Copy of current object with band names set to band_names\n        \"\"\"\n        s2obj = s2loader(\n            s2folder=self.folder,\n            out_res=self.out_res,\n            window_focus=self.window_focus,\n            bands=band_names,\n            granules=self.granules,\n            polygon=self._pol,\n            metadata_msi=self.metadata_msi,\n        )\n        s2obj.root_metadata_msi = self.root_metadata_msi\n        return s2obj\n\n    def read_from_window(\n        self, window: rasterio.windows.Window, boundless: bool = True\n    ) -&gt; \"__class__\":\n        # return GeoTensor(values=self.values, transform=self.transform, crs=self.crs)\n\n        reader_ref = self._get_reader()\n        rasterio_reader_ref = reader_ref.read_from_window(\n            window=window, boundless=boundless\n        )\n        s2obj = s2loader(\n            s2folder=self.folder,\n            out_res=self.out_res,\n            window_focus=rasterio_reader_ref.window_focus,\n            bands=self.bands,\n            granules=self.granules,\n            polygon=self._pol,\n            metadata_msi=self.metadata_msi,\n        )\n        # Set band check to avoid re-reading\n        s2obj.granule_readers[self.band_check] = rasterio_reader_ref\n        s2obj.band_check = self.band_check\n\n        s2obj.root_metadata_msi = self.root_metadata_msi\n\n        return s2obj\n\n    def load(self, boundless: bool = True) -&gt; GeoTensor:\n        reader_ref = self._get_reader()\n        geotensor_ref = reader_ref.load(boundless=boundless)\n\n        array_out = np.full(\n            (len(self.bands),) + geotensor_ref.shape[-2:],\n            fill_value=geotensor_ref.fill_value_default,\n            dtype=np.int32,\n        )\n\n        # Deal with NODATA values\n        invalids = (geotensor_ref.values == 0) | (geotensor_ref.values == (2**16) - 1)\n\n        radio_add = self.radio_add_offsets()\n        for idx, b in enumerate(self.bands):\n            if b == self.band_check:\n\n                # Avoid bug of band names without zero before\n                if len(b) == 2:\n                    b = f\"B0{b[-1]}\"\n\n                geotensor_iter = geotensor_ref\n            else:\n                reader_iter = self._get_reader(b)\n                if (\n                    np.mean(\n                        np.abs(np.array(reader_iter.res) - np.array(geotensor_ref.res))\n                    )\n                    &lt; 1e-6\n                ):\n                    geotensor_iter = reader_iter.load(boundless=boundless)\n                else:\n                    geotensor_iter = read.read_reproject_like(\n                        reader_iter, geotensor_ref\n                    )\n\n            # Important: Adds radio correction! otherwise images after 2022-01-25 shifted (PROCESSING_BASELINE '04.00' or above)\n            array_out[idx] = geotensor_iter.values[0].astype(np.int32) + radio_add[b]\n\n        array_out[:, invalids[0]] = self.fill_value_default\n\n        if np.any(array_out &lt; 0):\n            raise ValueError(\"Negative values found in the image\")\n\n        array_out = array_out.astype(np.uint16)\n\n        return GeoTensor(\n            values=array_out,\n            transform=geotensor_ref.transform,\n            crs=geotensor_ref.crs,\n            fill_value_default=self.fill_value_default,\n        )\n\n    @property\n    def values(self) -&gt; np.ndarray:\n        return self.load().values\n\n    def load_mask(self) -&gt; GeoTensor:\n        reader_ref = self._get_reader()\n        geotensor_ref = reader_ref.load(boundless=True)\n        geotensor_ref.values = (geotensor_ref.values == 0) | (\n            geotensor_ref.values == (2**16) - 1\n        )\n        return geotensor_ref\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2Image.__init__","title":"<code>__init__(s2folder, polygon=None, granules=None, out_res=10, window_focus=None, bands=None, metadata_msi=None)</code>","text":"<p>Sentinel-2 image reader class.</p> <p>Parameters:</p> Name Type Description Default <code>s2folder</code> <code>str</code> <p>name of the SAFE product expects name</p> required <code>polygon</code> <code>Optional[Polygon]</code> <p>in CRS EPSG:4326</p> <code>None</code> <code>granules</code> <code>Optional[Dict[str, str]]</code> <p>dictionary with granule name and path</p> <code>None</code> <code>out_res</code> <code>int</code> <p>output resolution in meters one of 10, 20, 60 (default 10)</p> <code>10</code> <code>window_focus</code> <code>Optional[Window]</code> <p>rasterio window to read. All reads will be based on this window</p> <code>None</code> <code>bands</code> <code>Optional[List[str]]</code> <p>list of bands to read. If None all bands are read.</p> <code>None</code> <code>metadata_msi</code> <code>Optional[str]</code> <p>path to metadata file. If None it is assumed to be in the SAFE folder</p> <code>None</code> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def __init__(\n    self,\n    s2folder: str,\n    polygon: Optional[Polygon] = None,\n    granules: Optional[Dict[str, str]] = None,\n    out_res: int = 10,\n    window_focus: Optional[rasterio.windows.Window] = None,\n    bands: Optional[List[str]] = None,\n    metadata_msi: Optional[str] = None,\n):\n    \"\"\"\n    Sentinel-2 image reader class.\n\n    Args:\n        s2folder: name of the SAFE product expects name\n        polygon: in CRS EPSG:4326\n        granules: dictionary with granule name and path\n        out_res: output resolution in meters one of 10, 20, 60 (default 10)\n        window_focus: rasterio window to read. All reads will be based on this window\n        bands: list of bands to read. If None all bands are read.\n        metadata_msi: path to metadata file. If None it is assumed to be in the SAFE folder\n\n    \"\"\"\n    (\n        self.mission,\n        self.producttype,\n        sensing_date_str,\n        self.pdgs,\n        self.relorbitnum,\n        self.tile_number_field,\n        self.product_discriminator,\n    ) = s2_name_split(s2folder)\n\n    # Remove last trailing slash\n    s2folder = (\n        s2folder[:-1]\n        if (s2folder.endswith(\"/\") or s2folder.endswith(\"\\\\\"))\n        else s2folder\n    )\n    self.name = os.path.basename(os.path.splitext(s2folder)[0])\n\n    self.folder = s2folder\n    self.datetime = datetime.datetime.strptime(\n        sensing_date_str, \"%Y%m%dT%H%M%S\"\n    ).replace(tzinfo=datetime.timezone.utc)\n\n    info_granules_metadata = None\n\n    if metadata_msi is None:\n        info_granules_metadata = _get_info_granules_metadata(self.folder)\n        if info_granules_metadata is not None:\n            self.metadata_msi = info_granules_metadata[\"metadata_msi\"]\n            if \"metadata_tl\" in info_granules_metadata:\n                self.metadata_tl = info_granules_metadata[\"metadata_tl\"]\n        else:\n            self.metadata_msi = os.path.join(\n                self.folder, f\"MTD_{self.producttype}.xml\"\n            ).replace(\"\\\\\", \"/\")\n\n    else:\n        self.metadata_msi = metadata_msi\n\n    out_res = int(out_res)\n\n    # TODO increase possible out_res to powers of 2 of 10 meters and 60 meters\n    # rst = rasterio.open('gs://gcp-public-data-sentinel-2/tiles/49/S/GV/S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE/GRANULE/L1C_T49SGV_A027271_20220527T031740/IMG_DATA/T49SGV_20220527T030539_B02.jp2')\n    # rst.overviews(1) -&gt; [2, 4, 8, 16]\n    assert out_res in {10, 20, 60}, \"Not valid output resolution.Choose 10, 20, 60\"\n\n    # Default resolution to read\n    self.out_res = out_res\n\n    if bands is None:\n        if self.producttype == \"MSIL2A\":\n            self.bands = list(BANDS_S2_L2A)\n        else:\n            self.bands = list(BANDS_S2)\n    else:\n        self.bands = normalize_band_names(bands)\n\n    self.dims = (\"band\", \"y\", \"x\")\n    self.fill_value_default = 0\n\n    # Select the band that will be used as template when reading\n    self.band_check = None\n    for band in self.bands:\n        if BANDS_RESOLUTION[band] == self.out_res:\n            self.band_check = band\n            break\n\n    assert (\n        self.band_check is not None\n    ), f\"Not band found of resolution {self.out_res} in {self.bands}\"\n\n    # This dict will be filled by the _get_reader function\n    self.granule_readers: Dict[str, RasterioReader] = {}\n    self.window_focus = window_focus\n    self.root_metadata_msi = None\n    self._radio_add_offsets = None\n    self._solar_irradiance = None\n    self._scale_factor_U = None\n    self._quantification_value = None\n\n    # The code below could be only triggered if required\n    if not granules:\n        # This is useful when copying with cache_product_to_local_dir func\n        if info_granules_metadata is None:\n            info_granules_metadata = _get_info_granules_metadata(self.folder)\n\n        if info_granules_metadata is not None:\n            self.granules = info_granules_metadata[\"granules\"]\n\n        else:\n            self.load_metadata_msi()\n            bands_elms = self.root_metadata_msi.findall(\".//IMAGE_FILE\")\n            all_granules = [\n                os.path.join(self.folder, b.text + \".jp2\").replace(\"\\\\\", \"/\")\n                for b in bands_elms\n            ]\n            if self.producttype == \"MSIL2A\":\n                self.granules = {j.split(\"_\")[-2]: j for j in all_granules}\n            else:\n                self.granules = {\n                    j.split(\"_\")[-1].replace(\".jp2\", \"\"): j for j in all_granules\n                }\n    else:\n        self.granules = granules\n\n    self._pol = polygon\n    if self._pol is not None:\n        self._pol_crs = window_utils.polygon_to_crs(\n            self._pol, \"EPSG:4326\", self.crs\n        )\n    else:\n        self._pol_crs = None\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2Image.cache_product_to_local_dir","title":"<code>cache_product_to_local_dir(path_dest=None, print_progress=True, format_bands=None)</code>","text":"<p>Copy the product to a local directory and return a new instance of the class with the new path</p> <p>Parameters:</p> Name Type Description Default <code>path_dest</code> <code>Optional[str]</code> <p>path to the destination folder. If None, the current folder ()\".\") is used</p> <code>None</code> <code>print_progress</code> <code>bool</code> <p>print progress bar. Default True</p> <code>True</code> <code>format_bands</code> <code>Optional[str]</code> <p>format of the bands. Default None (keep original format). Options: \"COG\", \"GeoTIFF\"</p> <code>None</code> <p>Returns:</p> Type Description <code>__class__</code> <p>A new instance of the class pointing to the new path</p> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def cache_product_to_local_dir(\n    self,\n    path_dest: Optional[str] = None,\n    print_progress: bool = True,\n    format_bands: Optional[str] = None,\n) -&gt; \"__class__\":\n    \"\"\"\n    Copy the product to a local directory and return a new instance of the class with the new path\n\n    Args:\n        path_dest: path to the destination folder. If None, the current folder ()\".\") is used\n        print_progress: print progress bar. Default True\n        format_bands: format of the bands. Default None (keep original format). Options: \"COG\", \"GeoTIFF\"\n\n    Returns:\n        A new instance of the class pointing to the new path\n    \"\"\"\n    if path_dest is None:\n        path_dest = \".\"\n\n    if format_bands is not None:\n        assert format_bands in {\n            \"COG\",\n            \"GeoTIFF\",\n        }, \"Not valid format_bands. Choose 'COG' or 'GeoTIFF'\"\n\n    name_with_safe = f\"{self.name}.SAFE\"\n    dest_folder = os.path.join(path_dest, name_with_safe)\n\n    # Copy metadata\n    metadata_filename = os.path.basename(self.metadata_msi)\n    metadata_output_path = os.path.join(dest_folder, metadata_filename)\n    if not os.path.exists(metadata_output_path):\n        os.makedirs(dest_folder, exist_ok=True)\n        self.load_metadata_msi()\n        ET.ElementTree(self.root_metadata_msi).write(metadata_output_path)\n        root_metadata_msi = self.root_metadata_msi\n    else:\n        root_metadata_msi = read_xml(metadata_output_path)\n\n    bands_elms = root_metadata_msi.findall(\".//IMAGE_FILE\")\n    if self.producttype == \"MSIL2A\":\n        granules_name_metadata = {b.text.split(\"_\")[-2]: b.text for b in bands_elms}\n    else:\n        granules_name_metadata = {b.text.split(\"_\")[-1]: b.text for b in bands_elms}\n\n    new_granules = {}\n    with tqdm(total=len(self.bands), disable=not print_progress) as pbar:\n        for b in self.bands:\n            granule = self.granules[b]\n            ext_origin = os.path.splitext(granule)[1]\n\n            if format_bands is not None:\n                if ext_origin.startswith(\".tif\"):\n                    convert = False\n                else:\n                    convert = True\n\n                ext_dst = \".tif\"\n            else:\n                convert = False\n                ext_dst = ext_origin\n\n            namefile = os.path.splitext(granules_name_metadata[b])[0]\n            new_granules[b] = namefile + ext_dst\n            new_granules_path = os.path.join(dest_folder, new_granules[b])\n            if not os.path.exists(new_granules_path):\n                new_granules_path_tmp = os.path.join(\n                    dest_folder, namefile + ext_origin\n                )\n                pbar.set_description(\n                    f\"Donwloading band {b} from {granule} to {new_granules_path}\"\n                )\n                dir_granules_path = os.path.dirname(new_granules_path)\n                os.makedirs(dir_granules_path, exist_ok=True)\n                get_file(granule, new_granules_path_tmp)\n                if convert:\n                    image = RasterioReader(new_granules_path_tmp).load().squeeze()\n                    if format_bands == \"COG\":\n                        save_cog(image, new_granules_path, descriptions=[b])\n                    elif format_bands == \"GeoTIFF\":\n                        save_tiled_geotiff(\n                            image, new_granules_path, descriptions=[b]\n                        )\n                    else:\n                        raise NotImplementedError(f\"Not implemented {format_bands}\")\n                    os.remove(new_granules_path_tmp)\n\n            pbar.update(1)\n\n    # Save granules for fast reading\n    granules_path = os.path.join(dest_folder, \"granules.json\").replace(\"\\\\\", \"/\")\n    if not os.path.exists(granules_path):\n        with open(granules_path, \"w\") as fh:\n            json.dump(\n                {\"granules\": new_granules, \"metadata_msi\": metadata_filename}, fh\n            )\n\n    new_granules_full_path = {\n        k: os.path.join(dest_folder, v) for k, v in new_granules.items()\n    }\n\n    obj = s2loader(\n        s2folder=dest_folder,\n        out_res=self.out_res,\n        window_focus=self.window_focus,\n        bands=self.bands,\n        granules=new_granules_full_path,\n        polygon=self._pol,\n        metadata_msi=metadata_output_path,\n    )\n    obj.root_metadata_msi = root_metadata_msi\n    return obj\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2Image.get_reader","title":"<code>get_reader(band_names, overview_level=None)</code>","text":"<p>Provides a RasterioReader object to read all the bands at the same resolution</p> <p>Parameters:</p> Name Type Description Default <code>band_names</code> <code>Union[str, List[str]]</code> <p>List of band names or band. raises assertion error if bands have different resolution.</p> required <code>overview_level</code> <code>Optional[int]</code> <p>level of the pyramid to read (same as in rasterio)</p> <code>None</code> <p>Returns:</p> Type Description <code>RasterioReader</code> <p>RasterioReader</p> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def get_reader(\n    self, band_names: Union[str, List[str]], overview_level: Optional[int] = None\n) -&gt; RasterioReader:\n    \"\"\"\n    Provides a RasterioReader object to read all the bands at the same resolution\n\n    Args:\n        band_names: List of band names or band. raises assertion error if bands have different resolution.\n        overview_level: level of the pyramid to read (same as in rasterio)\n\n    Returns:\n        RasterioReader\n\n    \"\"\"\n    if isinstance(band_names, str):\n        band_names = [band_names]\n\n    band_names = normalize_band_names(band_names)\n\n    assert all(\n        BANDS_RESOLUTION[band_names[0]] == BANDS_RESOLUTION[b] for b in band_names\n    ), f\"Bands: {band_names} have different resolution\"\n\n    reader = RasterioReader(\n        [self.granules[band_name] for band_name in band_names],\n        window_focus=None,\n        stack=False,\n        fill_value_default=self.fill_value_default,\n        overview_level=overview_level,\n    )\n    window_in = read.window_from_bounds(reader, self.bounds)\n    window_in_rounded = read.round_outer_window(window_in)\n    reader.set_window(window_in_rounded)\n    return reader\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2Image.quantification_value","title":"<code>quantification_value()</code>","text":"<p>Returns the quantification value stored in the metadata msi file (this is always: 10_000)</p> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def quantification_value(self) -&gt; int:\n    \"\"\"Returns the quantification value stored in the metadata msi file (this is always: 10_000)\"\"\"\n    if self._quantification_value is None:\n        self.load_metadata_msi()\n        self._quantification_value = int(\n            self.root_metadata_msi.find(\".//QUANTIFICATION_VALUE\").text\n        )\n\n    return self._quantification_value\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2Image.read_from_band_names","title":"<code>read_from_band_names(band_names)</code>","text":"<p>Read from band names</p> <p>Parameters:</p> Name Type Description Default <code>band_names</code> <code>List[str]</code> <p>List of band names</p> required <p>Returns:</p> Type Description <code>__class__</code> <p>Copy of current object with band names set to band_names</p> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def read_from_band_names(self, band_names: List[str]) -&gt; \"__class__\":\n    \"\"\"\n    Read from band names\n\n    Args:\n        band_names: List of band names\n\n    Returns:\n        Copy of current object with band names set to band_names\n    \"\"\"\n    s2obj = s2loader(\n        s2folder=self.folder,\n        out_res=self.out_res,\n        window_focus=self.window_focus,\n        bands=band_names,\n        granules=self.granules,\n        polygon=self._pol,\n        metadata_msi=self.metadata_msi,\n    )\n    s2obj.root_metadata_msi = self.root_metadata_msi\n    return s2obj\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2Image.solar_irradiance","title":"<code>solar_irradiance()</code>","text":"<p>Returns solar irradiance per nanometer: W/m\u00b2/nm</p> Reads solar irradiance from metadata_msi <p>1874.3</p> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def solar_irradiance(self) -&gt; Dict[str, float]:\n    \"\"\"\n    Returns solar irradiance per nanometer: W/m\u00b2/nm\n\n    Reads solar irradiance from metadata_msi:\n        &lt;SOLAR_IRRADIANCE bandId=\"0\" unit=\"W/m\u00b2/\u00b5m\"&gt;1874.3&lt;/SOLAR_IRRADIANCE&gt;\n    \"\"\"\n    if self._solar_irradiance is None:\n        self.load_metadata_msi()\n        sr = self.root_metadata_msi.findall(\".//SOLAR_IRRADIANCE\")\n        self._solar_irradiance = {\n            BANDS_S2[int(r.attrib[\"bandId\"])]: float(r.text) / 1_000 for r in sr\n        }\n\n    return self._solar_irradiance\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2ImageL1C","title":"<code>S2ImageL1C</code>","text":"<p>               Bases: <code>S2Image</code></p> <p>Sentinel-2 Level 1C (top of atmosphere reflectance) image reader.</p> <p>This class extends the base S2Image class to handle Sentinel-2 Level 1C products, which provide calibrated and orthorectified top of atmosphere reflectance data. It also provides methods to access viewing and solar angle information.</p> <p>Parameters:</p> Name Type Description Default <code>s2folder</code> <code>str</code> <p>Path to the Sentinel-2 SAFE product folder.</p> required <code>granules</code> <code>Dict[str, str]</code> <p>Dictionary mapping band names to file paths.</p> required <code>polygon</code> <code>Polygon</code> <p>Polygon defining the area of interest in EPSG:4326.</p> required <code>out_res</code> <code>int</code> <p>Output resolution in meters. Must be one of 10, 20, or 60. Defaults to 10.</p> <code>10</code> <code>window_focus</code> <code>Optional[Window]</code> <p>Window to focus on a specific region of the image. Defaults to None (entire image).</p> <code>None</code> <code>bands</code> <code>Optional[List[str]]</code> <p>List of bands to read. If None, all available bands will be loaded.</p> <code>None</code> <code>metadata_msi</code> <code>Optional[str]</code> <p>Path to metadata file. If None, it is assumed to be in the SAFE folder.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>Additional</code> <code>to S2Image attributes</code> <code>granule_folder</code> <code>str</code> <p>Path to the granule folder.</p> <code>msk_clouds_file</code> <code>str</code> <p>Path to the cloud mask file.</p> <code>metadata_tl</code> <code>str</code> <p>Path to the TL metadata file.</p> <code>root_metadata_tl</code> <p>Root element of the TL metadata XML.</p> <code>tileId</code> <code>str</code> <p>Tile identifier.</p> <code>satId</code> <code>str</code> <p>Satellite identifier.</p> <code>procLevel</code> <code>str</code> <p>Processing level.</p> <code>dimsByRes</code> <code>Dict</code> <p>Dimensions by resolution.</p> <code>ulxyByRes</code> <code>Dict</code> <p>Upper-left coordinates by resolution.</p> <code>tileAnglesNode</code> <code>Dict</code> <p>Tile angles node from metadata.</p> <code>mean_sza</code> <code>float</code> <p>Mean solar zenith angle.</p> <code>mean_saa</code> <code>float</code> <p>Mean solar azimuth angle.</p> <code>mean_vza</code> <code>Dict[str, float]</code> <p>Mean viewing zenith angle per band.</p> <code>mean_vaa</code> <code>Dict[str, float]</code> <p>Mean viewing azimuth angle per band.</p> <code>vaa</code> <code>Dict[str, GeoTensor]</code> <p>Viewing azimuth angle as GeoTensor per band.</p> <code>vza</code> <code>Dict[str, GeoTensor]</code> <p>Viewing zenith angle as GeoTensor per band.</p> <code>saa</code> <code>GeoTensor</code> <p>Solar azimuth angle as GeoTensor.</p> <code>sza</code> <code>GeoTensor</code> <p>Solar zenith angle as GeoTensor.</p> <code>anglesULXY</code> <code>Tuple[float, float]</code> <p>Upper-left coordinates of the angle grids.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Initialize the S2ImageL1C reader with a data path\n&gt;&gt;&gt; s2_l1c = S2ImageL1C('/path/to/S2A_MSIL1C_20170717T235959_N0205_R072_T01WCP_20170718T000256.SAFE',\n...                     granules=granules_dict, polygon=aoi_polygon)\n&gt;&gt;&gt; # Load all bands\n&gt;&gt;&gt; l1c_data = s2_l1c.load()\n&gt;&gt;&gt; # Read angle information\n&gt;&gt;&gt; s2_l1c.read_metadata_tl()\n&gt;&gt;&gt; solar_zenith = s2_l1c.sza\n&gt;&gt;&gt; # Convert to radiance\n&gt;&gt;&gt; radiance_data = s2_l1c.DN_to_radiance()\n</code></pre> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>class S2ImageL1C(S2Image):\n    \"\"\"\n    Sentinel-2 Level 1C (top of atmosphere reflectance) image reader.\n\n    This class extends the base S2Image class to handle Sentinel-2 Level 1C products,\n    which provide calibrated and orthorectified top of atmosphere reflectance data.\n    It also provides methods to access viewing and solar angle information.\n\n    Args:\n        s2folder (str): Path to the Sentinel-2 SAFE product folder.\n        granules (Dict[str, str]): Dictionary mapping band names to file paths.\n        polygon (Polygon): Polygon defining the area of interest in EPSG:4326.\n        out_res (int): Output resolution in meters. Must be one of 10, 20, or 60. Defaults to 10.\n        window_focus (Optional[rasterio.windows.Window]): Window to focus on a specific\n            region of the image. Defaults to None (entire image).\n        bands (Optional[List[str]]): List of bands to read. If None, all available bands will be loaded.\n        metadata_msi (Optional[str]): Path to metadata file. If None, it is assumed to be\n            in the SAFE folder.\n\n    Attributes:\n        Additional to S2Image attributes:\n        granule_folder (str): Path to the granule folder.\n        msk_clouds_file (str): Path to the cloud mask file.\n        metadata_tl (str): Path to the TL metadata file.\n        root_metadata_tl: Root element of the TL metadata XML.\n        tileId (str): Tile identifier.\n        satId (str): Satellite identifier.\n        procLevel (str): Processing level.\n        dimsByRes (Dict): Dimensions by resolution.\n        ulxyByRes (Dict): Upper-left coordinates by resolution.\n        tileAnglesNode: Tile angles node from metadata.\n        mean_sza (float): Mean solar zenith angle.\n        mean_saa (float): Mean solar azimuth angle.\n        mean_vza (Dict[str, float]): Mean viewing zenith angle per band.\n        mean_vaa (Dict[str, float]): Mean viewing azimuth angle per band.\n        vaa (Dict[str, GeoTensor]): Viewing azimuth angle as GeoTensor per band.\n        vza (Dict[str, GeoTensor]): Viewing zenith angle as GeoTensor per band.\n        saa (GeoTensor): Solar azimuth angle as GeoTensor.\n        sza (GeoTensor): Solar zenith angle as GeoTensor.\n        anglesULXY (Tuple[float, float]): Upper-left coordinates of the angle grids.\n\n    Examples:\n        &gt;&gt;&gt; # Initialize the S2ImageL1C reader with a data path\n        &gt;&gt;&gt; s2_l1c = S2ImageL1C('/path/to/S2A_MSIL1C_20170717T235959_N0205_R072_T01WCP_20170718T000256.SAFE',\n        ...                     granules=granules_dict, polygon=aoi_polygon)\n        &gt;&gt;&gt; # Load all bands\n        &gt;&gt;&gt; l1c_data = s2_l1c.load()\n        &gt;&gt;&gt; # Read angle information\n        &gt;&gt;&gt; s2_l1c.read_metadata_tl()\n        &gt;&gt;&gt; solar_zenith = s2_l1c.sza\n        &gt;&gt;&gt; # Convert to radiance\n        &gt;&gt;&gt; radiance_data = s2_l1c.DN_to_radiance()\n    \"\"\"\n\n    def __init__(\n        self,\n        s2folder,\n        granules: Dict[str, str],\n        polygon: Polygon,\n        out_res: int = 10,\n        window_focus: Optional[rasterio.windows.Window] = None,\n        bands: Optional[List[str]] = None,\n        metadata_msi: Optional[str] = None,\n    ):\n        super(S2ImageL1C, self).__init__(\n            s2folder=s2folder,\n            granules=granules,\n            polygon=polygon,\n            out_res=out_res,\n            bands=bands,\n            window_focus=window_focus,\n            metadata_msi=metadata_msi,\n        )\n\n        assert (\n            self.producttype == \"MSIL1C\"\n        ), f\"Unexpected product type {self.producttype} in image {self.folder}\"\n\n        first_granule = self.granules[list(self.granules.keys())[0]]\n        self.granule_folder = os.path.dirname(os.path.dirname(first_granule))\n        self.msk_clouds_file = os.path.join(\n            self.granule_folder, \"MSK_CLOUDS_B00.gml\"\n        ).replace(\"\\\\\", \"/\")\n        if not hasattr(self, \"metadata_tl\"):\n            self.metadata_tl = os.path.join(self.granule_folder, \"MTD_TL.xml\").replace(\n                \"\\\\\", \"/\"\n            )\n\n        self.root_metadata_tl = None\n\n        # Granule in L1C does not include TCI\n        # Assert bands in self.granule are ordered as in BANDS_S2\n        # assert all(granule[-7:-4] == bname for bname, granule in zip(BANDS_S2, self.granule)), f\"some granules are not in the expected order {self.granule}\"\n\n    def read_from_window(\n        self, window: rasterio.windows.Window, boundless: bool = True\n    ) -&gt; \"__class__\":\n        out = super().read_from_window(window, boundless=boundless)\n\n        if self.root_metadata_tl is None:\n            return out\n\n        # copy all metadata from the original image\n        for atribute in [\n            \"tileId\",\n            \"root_metadata_tl\",\n            \"satId\",\n            \"procLevel\",\n            \"dimsByRes\",\n            \"ulxyByRes\",\n            \"tileAnglesNode\",\n            \"mean_sza\",\n            \"mean_saa\",\n            \"mean_vza\",\n            \"mean_vaa\",\n            \"vaa\",\n            \"vza\",\n            \"saa\",\n            \"sza\",\n            \"anglesULXY\",\n        ]:\n            setattr(out, atribute, getattr(self, atribute))\n\n        return out\n\n    def cache_product_to_local_dir(\n        self,\n        path_dest: Optional[str] = None,\n        print_progress: bool = True,\n        format_bands: Optional[str] = None,\n    ) -&gt; \"__class__\":\n        \"\"\"\n        Overrides the parent method to copy the MTD_TL.xml file\n\n        Args:\n            path_dest (Optional[str], optional): path to the destination folder. Defaults to None.\n            print_progress (bool, optional): whether to print progress. Defaults to True.\n\n        Returns:\n            __class__: the cached object\n        \"\"\"\n        new_obj = super().cache_product_to_local_dir(\n            path_dest=path_dest,\n            print_progress=print_progress,\n            format_bands=format_bands,\n        )\n\n        if os.path.exists(new_obj.metadata_tl):\n            # the cached product already exists. returns\n            return new_obj\n\n        if self.root_metadata_tl is not None:\n            new_obj.root_metadata_tl = self.root_metadata_tl\n            ET.ElementTree(new_obj.metadata_tl).write(new_obj.metadata_tl)\n            # copy all metadata from the original image\n            for atribute in [\n                \"tileId\",\n                \"root_metadata_tl\",\n                \"satId\",\n                \"procLevel\",\n                \"dimsByRes\",\n                \"ulxyByRes\",\n                \"tileAnglesNode\",\n                \"mean_sza\",\n                \"mean_saa\",\n                \"mean_vza\",\n                \"mean_vaa\",\n                \"vaa\",\n                \"vza\",\n                \"saa\",\n                \"sza\",\n                \"anglesULXY\",\n            ]:\n                if hasattr(self, atribute):\n                    setattr(new_obj, atribute, getattr(self, atribute))\n        else:\n            get_file(self.metadata_tl, new_obj.metadata_tl)\n\n        granule_folder_rel = new_obj.granule_folder.replace(\"\\\\\", \"/\").replace(\n            new_obj.folder.replace(\"\\\\\", \"/\") + \"/\", \"\"\n        )\n        # Add metadata_tl to granules.json\n        granules_path = os.path.join(new_obj.folder, \"granules.json\").replace(\"\\\\\", \"/\")\n        with open(granules_path, \"r\") as fh:\n            info_granules_metadata = json.load(fh)\n        info_granules_metadata[\"metadata_tl\"] = os.path.join(\n            granule_folder_rel, \"MTD_TL.xml\"\n        ).replace(\"\\\\\", \"/\")\n        with open(granules_path, \"w\") as f:\n            json.dump(info_granules_metadata, f)\n\n        return new_obj\n\n    def read_metadata_tl(self):\n        \"\"\"\n        Read metadata TILE to parse information about the acquisition and properties of GRANULE bands.\n\n        It populates the following attributes:\n            - mean_sza\n            - mean_saa\n            - mean_vza\n            - mean_vaa\n            - vaa\n            - vza\n            - saa\n            - sza\n            - anglesULXY\n            - tileId\n            - satId\n            - procLevel\n            - epsg_code\n            - dimsByRes\n            - ulxyByRes\n            - tileAnglesNode\n            - root_metadata_tl\n\n        \"\"\"\n        if self.root_metadata_tl is not None:\n            return\n\n        self.root_metadata_tl = read_xml(self.metadata_tl)\n\n        # Stoopid XML namespace prefix\n        nsPrefix = self.root_metadata_tl.tag[: self.root_metadata_tl.tag.index(\"}\") + 1]\n        nsDict = {\"n1\": nsPrefix[1:-1]}\n\n        self.mean_sza = float(\n            self.root_metadata_tl.find(\".//Mean_Sun_Angle/ZENITH_ANGLE\").text\n        )\n        self.mean_saa = float(\n            self.root_metadata_tl.find(\".//Mean_Sun_Angle/AZIMUTH_ANGLE\").text\n        )\n\n        generalInfoNode = self.root_metadata_tl.find(\"n1:General_Info\", nsDict)\n        # N.B. I am still not entirely convinced that this SENSING_TIME is really\n        # the acquisition time, but the documentation is rubbish.\n        sensingTimeNode = generalInfoNode.find(\"SENSING_TIME\")\n        sensingTimeStr = sensingTimeNode.text.strip()\n        # self.datetime = datetime.datetime.strptime(sensingTimeStr, \"%Y-%m-%dT%H:%M:%S.%fZ\")\n        tileIdNode = generalInfoNode.find(\"TILE_ID\")\n        tileIdFullStr = tileIdNode.text.strip()\n        self.tileId = tileIdFullStr.split(\"_\")[-2]\n        self.satId = tileIdFullStr[:3]\n        self.procLevel = tileIdFullStr[\n            13:16\n        ]  # Not sure whether to use absolute pos or split by '_'....\n\n        geomInfoNode = self.root_metadata_tl.find(\"n1:Geometric_Info\", nsDict)\n        geocodingNode = geomInfoNode.find(\"Tile_Geocoding\")\n        self.epsg_code = geocodingNode.find(\"HORIZONTAL_CS_CODE\").text\n\n        # Dimensions of images at different resolutions.\n        self.dimsByRes = {}\n        sizeNodeList = geocodingNode.findall(\"Size\")\n        for sizeNode in sizeNodeList:\n            res = sizeNode.attrib[\"resolution\"]\n            nrows = int(sizeNode.find(\"NROWS\").text)\n            ncols = int(sizeNode.find(\"NCOLS\").text)\n            self.dimsByRes[res] = (nrows, ncols)\n\n        # Upper-left corners of images at different resolutions. As far as I can\n        # work out, these coords appear to be the upper left corner of the upper left\n        # pixel, i.e. equivalent to GDAL's convention. This also means that they\n        # are the same for the different resolutions, which is nice.\n        self.ulxyByRes = {}\n        posNodeList = geocodingNode.findall(\"Geoposition\")\n        for posNode in posNodeList:\n            res = posNode.attrib[\"resolution\"]\n            ulx = float(posNode.find(\"ULX\").text)\n            uly = float(posNode.find(\"ULY\").text)\n            self.ulxyByRes[res] = (ulx, uly)\n\n        # Sun and satellite angles.\n        # Zenith\n        self.tileAnglesNode = geomInfoNode.find(\"Tile_Angles\")\n        sunZenithNode = self.tileAnglesNode.find(\"Sun_Angles_Grid\").find(\"Zenith\")\n        # &lt;Zenith&gt;\n        #  &lt;COL_STEP unit=\"m\"&gt;5000&lt;/COL_STEP&gt;\n        #  &lt;ROW_STEP unit=\"m\"&gt;5000&lt;/ROW_STEP&gt;\n        angleGridXres = float(sunZenithNode.find(\"COL_STEP\").text)\n        angleGridYres = float(sunZenithNode.find(\"ROW_STEP\").text)\n        sza = self._makeValueArray(sunZenithNode.find(\"Values_List\"))\n        mask_nans = np.isnan(sza)\n        if np.any(mask_nans):\n            from skimage.restoration import inpaint_biharmonic\n\n            sza = inpaint_biharmonic(sza, mask_nans)\n        transform_zenith = rasterio.transform.from_origin(\n            self.ulxyByRes[str(self.out_res)][0],\n            self.ulxyByRes[str(self.out_res)][1],\n            angleGridXres,\n            angleGridYres,\n        )\n\n        self.sza = GeoTensor(sza, transform=transform_zenith, crs=self.epsg_code)\n\n        # Azimuth\n        sunAzimuthNode = self.tileAnglesNode.find(\"Sun_Angles_Grid\").find(\"Azimuth\")\n        angleGridXres = float(sunAzimuthNode.find(\"COL_STEP\").text)\n        angleGridYres = float(sunAzimuthNode.find(\"ROW_STEP\").text)\n        saa = self._makeValueArray(sunAzimuthNode.find(\"Values_List\"))\n        mask_nans = np.isnan(saa)\n        if np.any(mask_nans):\n            from skimage.restoration import inpaint_biharmonic\n\n            saa = inpaint_biharmonic(saa, mask_nans)\n        transform_azimuth = rasterio.transform.from_origin(\n            self.ulxyByRes[str(self.out_res)][0],\n            self.ulxyByRes[str(self.out_res)][1],\n            angleGridXres,\n            angleGridYres,\n        )\n        self.saa = GeoTensor(saa, transform=transform_azimuth, crs=self.epsg_code)\n\n        # Now build up the viewing angle per grid cell, from the separate layers\n        # given for each detector for each band. Initially I am going to keep\n        # the bands separate, just to see how that looks.\n        # The names of things in the XML suggest that these are view angles,\n        # but the numbers suggest that they are angles as seen from the pixel's\n        # frame of reference on the ground, i.e. they are in fact what we ultimately want.\n        viewingAngleNodeList = self.tileAnglesNode.findall(\n            \"Viewing_Incidence_Angles_Grids\"\n        )\n        vza = self._buildViewAngleArr(viewingAngleNodeList, \"Zenith\")\n        vaa = self._buildViewAngleArr(viewingAngleNodeList, \"Azimuth\")\n\n        self.vaa = {}\n        for k, varr in vaa.items():\n            mask_nans = np.isnan(varr)\n            if np.any(mask_nans):\n                from skimage.restoration import inpaint_biharmonic\n\n                varr = inpaint_biharmonic(varr, mask_nans)\n\n            self.vaa[k] = GeoTensor(\n                varr, transform=transform_azimuth, crs=self.epsg_code\n            )\n\n        self.vza = {}\n        for k, varr in vza.items():\n            mask_nans = np.isnan(varr)\n            if np.any(mask_nans):\n                from skimage.restoration import inpaint_biharmonic\n\n                varr = inpaint_biharmonic(varr, mask_nans)\n            self.vza[k] = GeoTensor(\n                varr, transform=transform_zenith, crs=self.epsg_code\n            )\n\n        # Make a guess at the coordinates of the angle grids. These are not given\n        # explicitly in the XML, and don't line up exactly with the other grids, so I am\n        # making a rough estimate. Because the angles don't change rapidly across these\n        # distances, it is not important if I am a bit wrong (although it would be nice\n        # to be exactly correct!).\n        (ulx, uly) = self.ulxyByRes[\"10\"]\n        self.anglesULXY = (ulx - angleGridXres / 2.0, uly + angleGridYres / 2.0)\n\n        # Read mean viewing angles for each band.\n        self.mean_vaa = {}\n        self.mean_vza = {}\n        for elm in self.tileAnglesNode.find(\"Mean_Viewing_Incidence_Angle_List\"):\n            band_name = BANDS_S2[int(elm.attrib[\"bandId\"])]\n            viewing_zenith_angle = float(elm.find(\"ZENITH_ANGLE\").text)\n            viewing_azimuth_angle = float(elm.find(\"AZIMUTH_ANGLE\").text)\n            self.mean_vza[band_name] = viewing_zenith_angle\n            self.mean_vaa[band_name] = viewing_azimuth_angle\n\n    def _buildViewAngleArr(self, viewingAngleNodeList, angleName):\n        \"\"\"\n        Build up the named viewing angle array from the various detector strips given as\n        separate arrays. I don't really understand this, and may need to re-write it once\n        I have worked it out......\n\n        The angleName is one of 'Zenith' or 'Azimuth'.\n        Returns a dictionary of 2-d arrays, keyed by the bandId string.\n        \"\"\"\n        angleArrDict = {}\n        for viewingAngleNode in viewingAngleNodeList:\n            band_name = BANDS_S2[int(viewingAngleNode.attrib[\"bandId\"])]\n            detectorId = viewingAngleNode.attrib[\"detectorId\"]\n\n            angleNode = viewingAngleNode.find(angleName)\n            angleArr = self._makeValueArray(angleNode.find(\"Values_List\"))\n            if band_name not in angleArrDict:\n                angleArrDict[band_name] = angleArr\n            else:\n                mask = ~np.isnan(angleArr)\n                angleArrDict[band_name][mask] = angleArr[mask]\n        return angleArrDict\n\n    @staticmethod\n    def _makeValueArray(valuesListNode):\n        \"\"\"\n        Take a &lt;Values_List&gt; node from the XML, and return an array of the values contained\n        within it. This will be a 2-d numpy array of float32 values (should I pass the dtype in??)\n\n        \"\"\"\n        valuesList = valuesListNode.findall(\"VALUES\")\n        vals = []\n        for valNode in valuesList:\n            text = valNode.text\n            vals.append([np.float32(x) for x in text.strip().split()])\n\n        return np.array(vals)\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2ImageL1C.cache_product_to_local_dir","title":"<code>cache_product_to_local_dir(path_dest=None, print_progress=True, format_bands=None)</code>","text":"<p>Overrides the parent method to copy the MTD_TL.xml file</p> <p>Parameters:</p> Name Type Description Default <code>path_dest</code> <code>Optional[str]</code> <p>path to the destination folder. Defaults to None.</p> <code>None</code> <code>print_progress</code> <code>bool</code> <p>whether to print progress. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>__class__</code> <code>__class__</code> <p>the cached object</p> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def cache_product_to_local_dir(\n    self,\n    path_dest: Optional[str] = None,\n    print_progress: bool = True,\n    format_bands: Optional[str] = None,\n) -&gt; \"__class__\":\n    \"\"\"\n    Overrides the parent method to copy the MTD_TL.xml file\n\n    Args:\n        path_dest (Optional[str], optional): path to the destination folder. Defaults to None.\n        print_progress (bool, optional): whether to print progress. Defaults to True.\n\n    Returns:\n        __class__: the cached object\n    \"\"\"\n    new_obj = super().cache_product_to_local_dir(\n        path_dest=path_dest,\n        print_progress=print_progress,\n        format_bands=format_bands,\n    )\n\n    if os.path.exists(new_obj.metadata_tl):\n        # the cached product already exists. returns\n        return new_obj\n\n    if self.root_metadata_tl is not None:\n        new_obj.root_metadata_tl = self.root_metadata_tl\n        ET.ElementTree(new_obj.metadata_tl).write(new_obj.metadata_tl)\n        # copy all metadata from the original image\n        for atribute in [\n            \"tileId\",\n            \"root_metadata_tl\",\n            \"satId\",\n            \"procLevel\",\n            \"dimsByRes\",\n            \"ulxyByRes\",\n            \"tileAnglesNode\",\n            \"mean_sza\",\n            \"mean_saa\",\n            \"mean_vza\",\n            \"mean_vaa\",\n            \"vaa\",\n            \"vza\",\n            \"saa\",\n            \"sza\",\n            \"anglesULXY\",\n        ]:\n            if hasattr(self, atribute):\n                setattr(new_obj, atribute, getattr(self, atribute))\n    else:\n        get_file(self.metadata_tl, new_obj.metadata_tl)\n\n    granule_folder_rel = new_obj.granule_folder.replace(\"\\\\\", \"/\").replace(\n        new_obj.folder.replace(\"\\\\\", \"/\") + \"/\", \"\"\n    )\n    # Add metadata_tl to granules.json\n    granules_path = os.path.join(new_obj.folder, \"granules.json\").replace(\"\\\\\", \"/\")\n    with open(granules_path, \"r\") as fh:\n        info_granules_metadata = json.load(fh)\n    info_granules_metadata[\"metadata_tl\"] = os.path.join(\n        granule_folder_rel, \"MTD_TL.xml\"\n    ).replace(\"\\\\\", \"/\")\n    with open(granules_path, \"w\") as f:\n        json.dump(info_granules_metadata, f)\n\n    return new_obj\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2ImageL1C.read_metadata_tl","title":"<code>read_metadata_tl()</code>","text":"<p>Read metadata TILE to parse information about the acquisition and properties of GRANULE bands.</p> It populates the following attributes <ul> <li>mean_sza</li> <li>mean_saa</li> <li>mean_vza</li> <li>mean_vaa</li> <li>vaa</li> <li>vza</li> <li>saa</li> <li>sza</li> <li>anglesULXY</li> <li>tileId</li> <li>satId</li> <li>procLevel</li> <li>epsg_code</li> <li>dimsByRes</li> <li>ulxyByRes</li> <li>tileAnglesNode</li> <li>root_metadata_tl</li> </ul> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def read_metadata_tl(self):\n    \"\"\"\n    Read metadata TILE to parse information about the acquisition and properties of GRANULE bands.\n\n    It populates the following attributes:\n        - mean_sza\n        - mean_saa\n        - mean_vza\n        - mean_vaa\n        - vaa\n        - vza\n        - saa\n        - sza\n        - anglesULXY\n        - tileId\n        - satId\n        - procLevel\n        - epsg_code\n        - dimsByRes\n        - ulxyByRes\n        - tileAnglesNode\n        - root_metadata_tl\n\n    \"\"\"\n    if self.root_metadata_tl is not None:\n        return\n\n    self.root_metadata_tl = read_xml(self.metadata_tl)\n\n    # Stoopid XML namespace prefix\n    nsPrefix = self.root_metadata_tl.tag[: self.root_metadata_tl.tag.index(\"}\") + 1]\n    nsDict = {\"n1\": nsPrefix[1:-1]}\n\n    self.mean_sza = float(\n        self.root_metadata_tl.find(\".//Mean_Sun_Angle/ZENITH_ANGLE\").text\n    )\n    self.mean_saa = float(\n        self.root_metadata_tl.find(\".//Mean_Sun_Angle/AZIMUTH_ANGLE\").text\n    )\n\n    generalInfoNode = self.root_metadata_tl.find(\"n1:General_Info\", nsDict)\n    # N.B. I am still not entirely convinced that this SENSING_TIME is really\n    # the acquisition time, but the documentation is rubbish.\n    sensingTimeNode = generalInfoNode.find(\"SENSING_TIME\")\n    sensingTimeStr = sensingTimeNode.text.strip()\n    # self.datetime = datetime.datetime.strptime(sensingTimeStr, \"%Y-%m-%dT%H:%M:%S.%fZ\")\n    tileIdNode = generalInfoNode.find(\"TILE_ID\")\n    tileIdFullStr = tileIdNode.text.strip()\n    self.tileId = tileIdFullStr.split(\"_\")[-2]\n    self.satId = tileIdFullStr[:3]\n    self.procLevel = tileIdFullStr[\n        13:16\n    ]  # Not sure whether to use absolute pos or split by '_'....\n\n    geomInfoNode = self.root_metadata_tl.find(\"n1:Geometric_Info\", nsDict)\n    geocodingNode = geomInfoNode.find(\"Tile_Geocoding\")\n    self.epsg_code = geocodingNode.find(\"HORIZONTAL_CS_CODE\").text\n\n    # Dimensions of images at different resolutions.\n    self.dimsByRes = {}\n    sizeNodeList = geocodingNode.findall(\"Size\")\n    for sizeNode in sizeNodeList:\n        res = sizeNode.attrib[\"resolution\"]\n        nrows = int(sizeNode.find(\"NROWS\").text)\n        ncols = int(sizeNode.find(\"NCOLS\").text)\n        self.dimsByRes[res] = (nrows, ncols)\n\n    # Upper-left corners of images at different resolutions. As far as I can\n    # work out, these coords appear to be the upper left corner of the upper left\n    # pixel, i.e. equivalent to GDAL's convention. This also means that they\n    # are the same for the different resolutions, which is nice.\n    self.ulxyByRes = {}\n    posNodeList = geocodingNode.findall(\"Geoposition\")\n    for posNode in posNodeList:\n        res = posNode.attrib[\"resolution\"]\n        ulx = float(posNode.find(\"ULX\").text)\n        uly = float(posNode.find(\"ULY\").text)\n        self.ulxyByRes[res] = (ulx, uly)\n\n    # Sun and satellite angles.\n    # Zenith\n    self.tileAnglesNode = geomInfoNode.find(\"Tile_Angles\")\n    sunZenithNode = self.tileAnglesNode.find(\"Sun_Angles_Grid\").find(\"Zenith\")\n    # &lt;Zenith&gt;\n    #  &lt;COL_STEP unit=\"m\"&gt;5000&lt;/COL_STEP&gt;\n    #  &lt;ROW_STEP unit=\"m\"&gt;5000&lt;/ROW_STEP&gt;\n    angleGridXres = float(sunZenithNode.find(\"COL_STEP\").text)\n    angleGridYres = float(sunZenithNode.find(\"ROW_STEP\").text)\n    sza = self._makeValueArray(sunZenithNode.find(\"Values_List\"))\n    mask_nans = np.isnan(sza)\n    if np.any(mask_nans):\n        from skimage.restoration import inpaint_biharmonic\n\n        sza = inpaint_biharmonic(sza, mask_nans)\n    transform_zenith = rasterio.transform.from_origin(\n        self.ulxyByRes[str(self.out_res)][0],\n        self.ulxyByRes[str(self.out_res)][1],\n        angleGridXres,\n        angleGridYres,\n    )\n\n    self.sza = GeoTensor(sza, transform=transform_zenith, crs=self.epsg_code)\n\n    # Azimuth\n    sunAzimuthNode = self.tileAnglesNode.find(\"Sun_Angles_Grid\").find(\"Azimuth\")\n    angleGridXres = float(sunAzimuthNode.find(\"COL_STEP\").text)\n    angleGridYres = float(sunAzimuthNode.find(\"ROW_STEP\").text)\n    saa = self._makeValueArray(sunAzimuthNode.find(\"Values_List\"))\n    mask_nans = np.isnan(saa)\n    if np.any(mask_nans):\n        from skimage.restoration import inpaint_biharmonic\n\n        saa = inpaint_biharmonic(saa, mask_nans)\n    transform_azimuth = rasterio.transform.from_origin(\n        self.ulxyByRes[str(self.out_res)][0],\n        self.ulxyByRes[str(self.out_res)][1],\n        angleGridXres,\n        angleGridYres,\n    )\n    self.saa = GeoTensor(saa, transform=transform_azimuth, crs=self.epsg_code)\n\n    # Now build up the viewing angle per grid cell, from the separate layers\n    # given for each detector for each band. Initially I am going to keep\n    # the bands separate, just to see how that looks.\n    # The names of things in the XML suggest that these are view angles,\n    # but the numbers suggest that they are angles as seen from the pixel's\n    # frame of reference on the ground, i.e. they are in fact what we ultimately want.\n    viewingAngleNodeList = self.tileAnglesNode.findall(\n        \"Viewing_Incidence_Angles_Grids\"\n    )\n    vza = self._buildViewAngleArr(viewingAngleNodeList, \"Zenith\")\n    vaa = self._buildViewAngleArr(viewingAngleNodeList, \"Azimuth\")\n\n    self.vaa = {}\n    for k, varr in vaa.items():\n        mask_nans = np.isnan(varr)\n        if np.any(mask_nans):\n            from skimage.restoration import inpaint_biharmonic\n\n            varr = inpaint_biharmonic(varr, mask_nans)\n\n        self.vaa[k] = GeoTensor(\n            varr, transform=transform_azimuth, crs=self.epsg_code\n        )\n\n    self.vza = {}\n    for k, varr in vza.items():\n        mask_nans = np.isnan(varr)\n        if np.any(mask_nans):\n            from skimage.restoration import inpaint_biharmonic\n\n            varr = inpaint_biharmonic(varr, mask_nans)\n        self.vza[k] = GeoTensor(\n            varr, transform=transform_zenith, crs=self.epsg_code\n        )\n\n    # Make a guess at the coordinates of the angle grids. These are not given\n    # explicitly in the XML, and don't line up exactly with the other grids, so I am\n    # making a rough estimate. Because the angles don't change rapidly across these\n    # distances, it is not important if I am a bit wrong (although it would be nice\n    # to be exactly correct!).\n    (ulx, uly) = self.ulxyByRes[\"10\"]\n    self.anglesULXY = (ulx - angleGridXres / 2.0, uly + angleGridYres / 2.0)\n\n    # Read mean viewing angles for each band.\n    self.mean_vaa = {}\n    self.mean_vza = {}\n    for elm in self.tileAnglesNode.find(\"Mean_Viewing_Incidence_Angle_List\"):\n        band_name = BANDS_S2[int(elm.attrib[\"bandId\"])]\n        viewing_zenith_angle = float(elm.find(\"ZENITH_ANGLE\").text)\n        viewing_azimuth_angle = float(elm.find(\"AZIMUTH_ANGLE\").text)\n        self.mean_vza[band_name] = viewing_zenith_angle\n        self.mean_vaa[band_name] = viewing_azimuth_angle\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.S2ImageL2A","title":"<code>S2ImageL2A</code>","text":"<p>               Bases: <code>S2Image</code></p> <p>Sentinel-2 Level 2A (surface reflectance) image reader.</p> <p>This class extends the base S2Image class to handle Sentinel-2 Level 2A products, which provide surface reflectance data with atmospheric corrections applied.</p> <p>Parameters:</p> Name Type Description Default <code>s2folder</code> <code>str</code> <p>Path to the Sentinel-2 SAFE product folder.</p> required <code>granules</code> <code>Dict[str, str]</code> <p>Dictionary mapping band names to file paths.</p> required <code>polygon</code> <code>Polygon</code> <p>Polygon defining the area of interest in EPSG:4326.</p> required <code>out_res</code> <code>int</code> <p>Output resolution in meters. Must be one of 10, 20, or 60. Defaults to 10.</p> <code>10</code> <code>window_focus</code> <code>Optional[Window]</code> <p>Window to focus on a specific region of the image. Defaults to None (entire image).</p> <code>None</code> <code>bands</code> <code>Optional[List[str]]</code> <p>List of bands to read. If None, the default L2A bands (excluding B10) will be loaded.</p> <code>None</code> <code>metadata_msi</code> <code>Optional[str]</code> <p>Path to metadata file. If None, it is assumed to be in the SAFE folder.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>mission</code> <code>str</code> <p>Mission identifier (e.g., 'S2A', 'S2B').</p> <code>producttype</code> <code>str</code> <p>Product type identifier (e.g., 'MSIL2A').</p> <code>pdgs</code> <code>str</code> <p>PDGS Processing Baseline number.</p> <code>relorbitnum</code> <code>str</code> <p>Relative Orbit number.</p> <code>tile_number_field</code> <code>str</code> <p>Tile Number field.</p> <code>product_discriminator</code> <code>str</code> <p>Product Discriminator.</p> <code>name</code> <code>str</code> <p>Base name of the product.</p> <code>folder</code> <code>str</code> <p>Path to the product folder.</p> <code>datetime</code> <code>datetime</code> <p>Acquisition datetime.</p> <code>metadata_msi</code> <code>str</code> <p>Path to the MSI metadata file.</p> <code>out_res</code> <code>int</code> <p>Output resolution in meters.</p> <code>bands</code> <code>List[str]</code> <p>List of bands to read.</p> <code>dims</code> <code>Tuple[str]</code> <p>Names of the dimensions (\"band\", \"y\", \"x\").</p> <code>fill_value_default</code> <code>int</code> <p>Default fill value (typically 0).</p> <code>band_check</code> <code>str</code> <p>Band used as template for reading.</p> <code>granule_readers</code> <code>Dict[str, RasterioReader]</code> <p>Dictionary of readers for each band.</p> <code>window_focus</code> <code>Window</code> <p>Current window focus.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Initialize the S2ImageL2A reader with a data path\n&gt;&gt;&gt; s2_l2a = S2ImageL2A('/path/to/S2A_MSIL2A_20170717T235959_N0205_R072_T01WCP_20170718T000256.SAFE',\n...                     granules=granules_dict, polygon=aoi_polygon)\n&gt;&gt;&gt; # Load all bands\n&gt;&gt;&gt; l2a_data = s2_l2a.load()\n</code></pre> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>class S2ImageL2A(S2Image):\n    \"\"\"\n    Sentinel-2 Level 2A (surface reflectance) image reader.\n\n    This class extends the base S2Image class to handle Sentinel-2 Level 2A products,\n    which provide surface reflectance data with atmospheric corrections applied.\n\n    Args:\n        s2folder (str): Path to the Sentinel-2 SAFE product folder.\n        granules (Dict[str, str]): Dictionary mapping band names to file paths.\n        polygon (Polygon): Polygon defining the area of interest in EPSG:4326.\n        out_res (int): Output resolution in meters. Must be one of 10, 20, or 60. Defaults to 10.\n        window_focus (Optional[rasterio.windows.Window]): Window to focus on a specific\n            region of the image. Defaults to None (entire image).\n        bands (Optional[List[str]]): List of bands to read. If None, the default L2A bands\n            (excluding B10) will be loaded.\n        metadata_msi (Optional[str]): Path to metadata file. If None, it is assumed to be\n            in the SAFE folder.\n\n    Attributes:\n        mission (str): Mission identifier (e.g., 'S2A', 'S2B').\n        producttype (str): Product type identifier (e.g., 'MSIL2A').\n        pdgs (str): PDGS Processing Baseline number.\n        relorbitnum (str): Relative Orbit number.\n        tile_number_field (str): Tile Number field.\n        product_discriminator (str): Product Discriminator.\n        name (str): Base name of the product.\n        folder (str): Path to the product folder.\n        datetime (datetime): Acquisition datetime.\n        metadata_msi (str): Path to the MSI metadata file.\n        out_res (int): Output resolution in meters.\n        bands (List[str]): List of bands to read.\n        dims (Tuple[str]): Names of the dimensions (\"band\", \"y\", \"x\").\n        fill_value_default (int): Default fill value (typically 0).\n        band_check (str): Band used as template for reading.\n        granule_readers (Dict[str, RasterioReader]): Dictionary of readers for each band.\n        window_focus (rasterio.windows.Window): Current window focus.\n\n    Examples:\n        &gt;&gt;&gt; # Initialize the S2ImageL2A reader with a data path\n        &gt;&gt;&gt; s2_l2a = S2ImageL2A('/path/to/S2A_MSIL2A_20170717T235959_N0205_R072_T01WCP_20170718T000256.SAFE',\n        ...                     granules=granules_dict, polygon=aoi_polygon)\n        &gt;&gt;&gt; # Load all bands\n        &gt;&gt;&gt; l2a_data = s2_l2a.load()\n    \"\"\"\n\n    def __init__(\n        self,\n        s2folder: str,\n        granules: Dict[str, str],\n        polygon: Polygon,\n        out_res: int = 10,\n        window_focus: Optional[rasterio.windows.Window] = None,\n        bands: Optional[List[str]] = None,\n        metadata_msi: Optional[str] = None,\n    ):\n        if bands is None:\n            bands = BANDS_S2_L2A\n\n        super(S2ImageL2A, self).__init__(\n            s2folder=s2folder,\n            granules=granules,\n            polygon=polygon,\n            out_res=out_res,\n            bands=bands,\n            window_focus=window_focus,\n            metadata_msi=metadata_msi,\n        )\n\n        assert (\n            self.producttype == \"MSIL2A\"\n        ), f\"Unexpected product type {self.producttype} in image {self.folder}\"\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.s2loader","title":"<code>s2loader(s2folder, out_res=10, bands=None, window_focus=None, granules=None, polygon=None, metadata_msi=None)</code>","text":"<p>Loads a S2ImageL2A or S2ImageL1C depending on the product type</p> <p>Parameters:</p> Name Type Description Default <code>s2folder</code> <code>str</code> <p>.SAFE folder. Expected standard ESA naming convention (see s2_name_split fun)</p> required <code>out_res</code> <code>int</code> <p>default output resolution {10, 20, 60}</p> <code>10</code> <code>bands</code> <code>Optional[List[str]]</code> <p>Bands to read. Default to BANDS_S2 or BANDS_S2_L2A depending on the product type</p> <code>None</code> <code>window_focus</code> <code>Optional[Window]</code> <p>window to read when creating the object</p> <code>None</code> <code>granules</code> <code>Optional[Dict[str, str]]</code> <p>Dict where keys are the band names and values are paths to the band location</p> <code>None</code> <code>polygon</code> <code>Optional[Polygon]</code> <p>polygon with the footprint of the object</p> <code>None</code> <code>metadata_msi</code> <code>Optional[str]</code> <p>path to metadata file</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[S2ImageL2A, S2ImageL1C]</code> <p>S2Image reader</p> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def s2loader(\n    s2folder: str,\n    out_res: int = 10,\n    bands: Optional[List[str]] = None,\n    window_focus: Optional[rasterio.windows.Window] = None,\n    granules: Optional[Dict[str, str]] = None,\n    polygon: Optional[Polygon] = None,\n    metadata_msi: Optional[str] = None,\n) -&gt; Union[S2ImageL2A, S2ImageL1C]:\n    \"\"\"\n    Loads a S2ImageL2A or S2ImageL1C depending on the product type\n\n    Args:\n        s2folder: .SAFE folder. Expected standard ESA naming convention (see s2_name_split fun)\n        out_res: default output resolution {10, 20, 60}\n        bands: Bands to read. Default to BANDS_S2 or BANDS_S2_L2A depending on the product type\n        window_focus: window to read when creating the object\n        granules: Dict where keys are the band names and values are paths to the band location\n        polygon: polygon with the footprint of the object\n        metadata_msi: path to metadata file\n\n    Returns:\n        S2Image reader\n    \"\"\"\n\n    _, producttype_nos2, _, _, _, _, _ = s2_name_split(s2folder)\n\n    if producttype_nos2 == \"MSIL2A\":\n        return S2ImageL2A(\n            s2folder,\n            granules=granules,\n            polygon=polygon,\n            out_res=out_res,\n            bands=bands,\n            window_focus=window_focus,\n            metadata_msi=metadata_msi,\n        )\n    elif producttype_nos2 == \"MSIL1C\":\n        return S2ImageL1C(\n            s2folder,\n            granules=granules,\n            polygon=polygon,\n            out_res=out_res,\n            bands=bands,\n            window_focus=window_focus,\n            metadata_msi=metadata_msi,\n        )\n\n    raise NotImplementedError(f\"Don't know how to load {producttype_nos2} products\")\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.s2_public_bucket_path","title":"<code>s2_public_bucket_path(s2file, check_exists=False, mode='gcp')</code>","text":"<p>Returns the expected patch in the public bucket of the S2 file</p> <p>Parameters:</p> Name Type Description Default <code>s2file</code> <code>str</code> <p>safe file (e.g.  S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE)</p> required <code>check_exists</code> <code>bool</code> <p>check if the file exists in the bucket, This will not work if GOOGLE_APPLICATION_CREDENTIALS and/or GS_USER_PROJECT env variables are not set. Default to False</p> <code>False</code> <code>mode</code> <code>str</code> <p>\"gcp\" or \"rest\"</p> <code>'gcp'</code> <p>Returns:</p> Type Description <code>str</code> <p>full path to the file (e.g. gs://gcp-public-data-sentinel-2/tiles/49/S/GV/S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE)</p> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def s2_public_bucket_path(\n    s2file: str, check_exists: bool = False, mode: str = \"gcp\"\n) -&gt; str:\n    \"\"\"\n    Returns the expected patch in the public bucket of the S2 file\n\n    Args:\n        s2file: safe file (e.g.  S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE)\n        check_exists: check if the file exists in the bucket, This will not work if GOOGLE_APPLICATION_CREDENTIALS and/or GS_USER_PROJECT\n            env variables are not set. Default to False\n        mode: \"gcp\" or \"rest\"\n\n    Returns:\n        full path to the file (e.g. gs://gcp-public-data-sentinel-2/tiles/49/S/GV/S2B_MSIL1C_20220527T030539_N0400_R075_T49SGV_20220527T051042.SAFE)\n    \"\"\"\n    (\n        mission,\n        producttype,\n        sensing_date_str,\n        pdgs,\n        relorbitnum,\n        tile_number_field,\n        product_discriminator,\n    ) = s2_name_split(s2file)\n    s2file = s2file[:-1] if s2file.endswith(\"/\") else s2file\n\n    if not s2file.endswith(\".SAFE\"):\n        s2file += \".SAFE\"\n\n    basename = os.path.basename(s2file)\n    if mode == \"gcp\":\n        s2folder = f\"{FULL_PATH_PUBLIC_BUCKET_SENTINEL_2}tiles/{tile_number_field[:2]}/{tile_number_field[2]}/{tile_number_field[3:]}/{basename}\"\n    elif mode == \"rest\":\n        s2folder = f\"https://storage.googleapis.com/gcp-public-data-sentinel-2/tiles/{tile_number_field[:2]}/{tile_number_field[2]}/{tile_number_field[3:]}/{basename}\"\n    else:\n        raise NotImplementedError(f\"Mode {mode} unknown\")\n\n    if check_exists and (mode == \"gcp\"):\n        fs = get_filesystem(s2folder)\n\n        if not fs.exists(s2folder):\n            raise FileNotFoundError(f\"Sentinel-2 file not found in {s2folder}\")\n\n    return s2folder\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.S2_SAFE_reader.read_srf","title":"<code>read_srf(satellite, srf_file=SRF_FILE_DEFAULT, cache=True)</code>","text":"<p>Process the spectral response function file. If the file is not provided it downloads it from https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi/document-library/-/asset_publisher/Wk0TKajiISaR/content/sentinel-2a-spectral-responses</p> <p>This function requires the fsspec package and pandas and openpyxl for reading excel files.</p> <p>Parameters:</p> Name Type Description Default <code>satellite</code> <code>str</code> <p>satellite name (S2A, S2B or S2C)</p> required <code>srf_file</code> <code>str</code> <p>path to the srf file</p> <code>SRF_FILE_DEFAULT</code> <code>cache</code> <code>bool</code> <p>if True, the srf is cached for future calls. Default True</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: spectral response function for each of the bands of S2</p> Source code in <code>georeader/readers/S2_SAFE_reader.py</code> <pre><code>def read_srf(\n    satellite: str, srf_file: str = SRF_FILE_DEFAULT, cache: bool = True\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Process the spectral response function file. If the file is not provided\n    it downloads it from https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi/document-library/-/asset_publisher/Wk0TKajiISaR/content/sentinel-2a-spectral-responses\n\n    This function requires the fsspec package and pandas and openpyxl for reading excel files.\n\n    Args:\n        satellite (str): satellite name (S2A, S2B or S2C)\n        srf_file (str): path to the srf file\n        cache (bool): if True, the srf is cached for future calls. Default True\n\n    Returns:\n        pd.DataFrame: spectral response function for each of the bands of S2\n    \"\"\"\n    assert satellite in [\"S2A\", \"S2B\", \"S2C\"], \"satellite must be S2A or S2B\"\n\n    if cache:\n        global SRF_S2\n        if satellite in SRF_S2:\n            return SRF_S2[satellite]\n\n    if srf_file == SRF_FILE_DEFAULT:\n        # home_dir = os.path.join(os.path.expanduser('~'),\".georeader\")\n        home_dir = os.path.join(os.path.expanduser(\"~\"), \".georeader\")\n        os.makedirs(home_dir, exist_ok=True)\n        srf_filename = os.path.basename(srf_file)\n\n        # Decode the url to get the filename. Also, replace spaces with underscores\n        import urllib.parse\n\n        srf_filename = urllib.parse.unquote(srf_filename).replace(\" \", \"_\")\n\n        srf_file_local = os.path.join(home_dir, srf_filename)\n        if not os.path.exists(srf_file_local):\n            import fsspec\n\n            with fsspec.open(srf_file, \"rb\") as f:\n                with open(srf_file_local, \"wb\") as f2:\n                    f2.write(f.read())\n        srf_file = srf_file_local\n\n    srf_s2 = pd.read_excel(srf_file, sheet_name=f\"Spectral Responses ({satellite})\")\n\n    srf_s2 = srf_s2.set_index(\"SR_WL\")\n\n    # remove rows with all values zero\n    any_not_cero = np.any((srf_s2 &gt; 1e-6).values, axis=1)\n    srf_s2 = srf_s2.loc[any_not_cero]\n\n    # remove the satellite name from the columns\n    srf_s2.columns = [c.replace(f\"{satellite}_SR_AV_\", \"\") for c in srf_s2.columns]\n    srf_s2.columns = normalize_band_names(srf_s2.columns)\n\n    if cache:\n        SRF_S2[satellite] = srf_s2\n\n    return srf_s2\n</code></pre>"},{"location":"modules/readers_module/#proba-v-reader","title":"Proba-V Reader","text":"<p>The Proba-V reader enables access to Proba-V Level 2A and Level 3 products. It handles:</p> <ul> <li>Reading TOA reflectance from HDF5 files</li> <li>Mask handling for clouds, shadows, and invalid pixels</li> <li>Extraction of metadata and acquisition parameters</li> </ul> <p>Tutorial example:</p> <ul> <li>Reading overlapping Proba-V and Sentinel-2 images</li> </ul>"},{"location":"modules/readers_module/#api-reference_1","title":"API Reference","text":"<p>Proba-V reader</p> <p>Unnoficial Proba-V reader. This reader is based in the Proba-V user manual: https://publications.vito.be/2017-1333-probav-products-user-manual.pdf</p> <p>Author:  Gonzalo Mateo-Garc\u00eda</p>"},{"location":"modules/readers_module/#georeader.readers.probav_image_operational.ProbaV","title":"<code>ProbaV</code>","text":"<p>Proba-V reader for handling Proba-V satellite products.</p> <p>This class provides functionality to read and manipulate Proba-V satellite imagery products. It handles the specific format and metadata of Proba-V HDF5 files, supporting operations like loading radiometry data, masks, and cloud information.</p> <p>Parameters:</p> Name Type Description Default <code>hdf5_file</code> <code>str</code> <p>Path to the HDF5 file containing the Proba-V product.</p> required <code>window</code> <code>Optional[Window]</code> <p>Optional window to focus on a specific region of the image. Defaults to None (entire image).</p> <code>None</code> <code>level_name</code> <code>str</code> <p>Processing level of the product, either \"LEVEL2A\" or \"LEVEL3\". Defaults to \"LEVEL3\".</p> <code>'LEVEL3'</code> <p>Attributes:</p> Name Type Description <code>hdf5_file</code> <code>str</code> <p>Path to the HDF5 file.</p> <code>name</code> <code>str</code> <p>Basename of the HDF5 file.</p> <code>camera</code> <code>str</code> <p>Camera ID (for LEVEL2A products).</p> <code>res_name</code> <code>str</code> <p>Resolution name identifier (e.g., '100M', '300M', '1KM').</p> <code>version</code> <code>str</code> <p>Product version.</p> <code>toatoc</code> <code>str</code> <p>Indicator of whether data is TOA (top of atmosphere) or TOC (top of canopy).</p> <code>real_transform</code> <code>Affine</code> <p>Affine transform for the full image.</p> <code>real_shape</code> <code>Tuple[int, int]</code> <p>Shape of the full image (height, width).</p> <code>dtype_radiometry</code> <p>Data type for radiometry data (typically np.float32).</p> <code>dtype_sm</code> <p>Data type for SM (status map) data.</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Dictionary with product metadata.</p> <code>window_focus</code> <code>Window</code> <p>Current window focus.</p> <code>window_data</code> <code>Window</code> <p>Window representing the full data extent.</p> <code>start_date</code> <code>datetime</code> <p>Start acquisition date and time.</p> <code>end_date</code> <code>datetime</code> <p>End acquisition date and time.</p> <code>map_projection_wkt</code> <code>str</code> <p>WKT representation of the map projection.</p> <code>crs</code> <p>Coordinate reference system.</p> <code>level_name</code> <code>str</code> <p>Processing level identifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import rasterio.windows\n&gt;&gt;&gt; # Initialize the ProbaV reader with a data path\n&gt;&gt;&gt; probav_reader = ProbaV('/path/to/probav_product.HDF5')\n&gt;&gt;&gt; # Load radiometry data\n&gt;&gt;&gt; bands = probav_reader.load_radiometry()\n&gt;&gt;&gt; # Get cloud mask\n&gt;&gt;&gt; cloud_mask = probav_reader.load_sm_cloud_mask()\n&gt;&gt;&gt; # Focus on a specific window\n&gt;&gt;&gt; window = rasterio.windows.Window(col_off=100, row_off=100, width=200, height=200)\n&gt;&gt;&gt; probav_reader.set_window(window)\n</code></pre> Source code in <code>georeader/readers/probav_image_operational.py</code> <pre><code>class ProbaV:\n    \"\"\"\n    Proba-V reader for handling Proba-V satellite products.\n\n    This class provides functionality to read and manipulate Proba-V satellite imagery products.\n    It handles the specific format and metadata of Proba-V HDF5 files, supporting operations\n    like loading radiometry data, masks, and cloud information.\n\n    Args:\n        hdf5_file (str): Path to the HDF5 file containing the Proba-V product.\n        window (Optional[rasterio.windows.Window]): Optional window to focus on a specific\n            region of the image. Defaults to None (entire image).\n        level_name (str): Processing level of the product, either \"LEVEL2A\" or \"LEVEL3\".\n            Defaults to \"LEVEL3\".\n\n    Attributes:\n        hdf5_file (str): Path to the HDF5 file.\n        name (str): Basename of the HDF5 file.\n        camera (str): Camera ID (for LEVEL2A products).\n        res_name (str): Resolution name identifier (e.g., '100M', '300M', '1KM').\n        version (str): Product version.\n        toatoc (str): Indicator of whether data is TOA (top of atmosphere) or TOC (top of canopy).\n        real_transform (rasterio.Affine): Affine transform for the full image.\n        real_shape (Tuple[int, int]): Shape of the full image (height, width).\n        dtype_radiometry: Data type for radiometry data (typically np.float32).\n        dtype_sm: Data type for SM (status map) data.\n        metadata (Dict[str, Any]): Dictionary with product metadata.\n        window_focus (rasterio.windows.Window): Current window focus.\n        window_data (rasterio.windows.Window): Window representing the full data extent.\n        start_date (datetime): Start acquisition date and time.\n        end_date (datetime): End acquisition date and time.\n        map_projection_wkt (str): WKT representation of the map projection.\n        crs: Coordinate reference system.\n        level_name (str): Processing level identifier.\n\n    Examples:\n        &gt;&gt;&gt; import rasterio.windows\n        &gt;&gt;&gt; # Initialize the ProbaV reader with a data path\n        &gt;&gt;&gt; probav_reader = ProbaV('/path/to/probav_product.HDF5')\n        &gt;&gt;&gt; # Load radiometry data\n        &gt;&gt;&gt; bands = probav_reader.load_radiometry()\n        &gt;&gt;&gt; # Get cloud mask\n        &gt;&gt;&gt; cloud_mask = probav_reader.load_sm_cloud_mask()\n        &gt;&gt;&gt; # Focus on a specific window\n        &gt;&gt;&gt; window = rasterio.windows.Window(col_off=100, row_off=100, width=200, height=200)\n        &gt;&gt;&gt; probav_reader.set_window(window)\n    \"\"\"\n\n    def __init__(\n        self,\n        hdf5_file: str,\n        window: Optional[rasterio.windows.Window] = None,\n        level_name: str = \"LEVEL3\",\n    ):\n        self.hdf5_file = hdf5_file\n        self.name = os.path.basename(self.hdf5_file)\n        if level_name == \"LEVEL2A\":\n            matches = re.match(\n                r\"PROBAV_L2A_\\d{8}_\\d{6}_(\\d)_(\\d..?M)_(V\\d0\\d)\", self.name\n            )\n            if matches is not None:\n                self.camera, self.res_name, self.version = matches.groups()\n            self.toatoc = \"TOA\"\n        elif level_name == \"LEVEL3\":\n            matches = re.match(\n                r\"PROBAV_S1_(TO.)_.{6}_\\d{8}_(\\d..?M)_(V\\d0\\d)\", self.name\n            )\n            if matches is not None:\n                self.toatoc, self.res_name, self.version = matches.groups()\n        else:\n            raise NotImplementedError(f\"Unknown level name {level_name}\")\n\n        try:\n            with h5py.File(self.hdf5_file, \"r\") as input_f:\n                # reference metadata: http://www.vito-eodata.be/PDF/image/PROBAV-Products_User_Manual.pdf\n                valores_blue = (\n                    input_f[f\"{level_name}/RADIOMETRY/BLUE/{self.toatoc}\"]\n                    .attrs[\"MAPPING\"][3:7]\n                    .astype(np.float64)\n                )\n                self.real_transform = Affine(\n                    a=valores_blue[2],\n                    b=0,\n                    c=valores_blue[0],\n                    d=0,\n                    e=-valores_blue[3],\n                    f=valores_blue[1],\n                )\n                self.real_shape = input_f[\n                    f\"{level_name}/RADIOMETRY/BLUE/{self.toatoc}\"\n                ].shape\n                # self.dtype_radiometry = input_f[f\"{level_name}/RADIOMETRY/RED/{self.toatoc}\"].dtype\n\n                # Set to float because we're converting the image to TOA when reading (see read_radiometry function)\n                self.dtype_radiometry = np.float32\n                self.dtype_sm = input_f[f\"{level_name}/QUALITY/SM\"].dtype\n                self.metadata = dict(input_f.attrs)\n        except OSError as e:\n            raise FileNotFoundError(\"Error opening file %s\" % self.hdf5_file)\n\n        if window is None:\n            self.window_focus = rasterio.windows.Window(\n                row_off=0,\n                col_off=0,\n                width=self.real_shape[1],\n                height=self.real_shape[0],\n            )\n        else:\n            self.window_focus = rasterio.windows.Window(\n                row_off=0,\n                col_off=0,\n                width=self.real_shape[1],\n                height=self.real_shape[0],\n            )\n\n        self.window_data = rasterio.windows.Window(\n            row_off=0, col_off=0, width=self.real_shape[1], height=self.real_shape[0]\n        )\n\n        if \"OBSERVATION_END_DATE\" in self.metadata:\n            self.end_date = datetime.strptime(\n                \" \".join(\n                    self.metadata[\"OBSERVATION_END_DATE\"].astype(str).tolist()\n                    + self.metadata[\"OBSERVATION_END_TIME\"].astype(str).tolist()\n                ),\n                \"%Y-%m-%d %H:%M:%S\",\n            ).replace(tzinfo=timezone.utc)\n            self.start_date = datetime.strptime(\n                \" \".join(\n                    self.metadata[\"OBSERVATION_START_DATE\"].astype(str).tolist()\n                    + self.metadata[\"OBSERVATION_START_TIME\"].astype(str).tolist()\n                ),\n                \"%Y-%m-%d %H:%M:%S\",\n            ).replace(tzinfo=timezone.utc)\n            self.map_projection_wkt = \" \".join(\n                self.metadata[\"MAP_PROJECTION_WKT\"].astype(str).tolist()\n            )\n\n        # Proba-V images are lat/long\n        self.crs = rasterio.crs.CRS({\"init\": \"epsg:4326\"})\n\n        # Proba-V images have four bands\n        self.level_name = level_name\n\n    def _get_window_pad(\n        self, boundless: bool = True\n    ) -&gt; Tuple[rasterio.windows.Window, Optional[List]]:\n        window_read = rasterio.windows.intersection(self.window_focus, self.window_data)\n\n        if boundless:\n            _, pad_width = window_utils.get_slice_pad(\n                self.window_data, self.window_focus\n            )\n            need_pad = any(p != 0 for p in pad_width[\"x\"] + pad_width[\"y\"])\n            if need_pad:\n                pad_list_np = []\n                for k in [\"y\", \"x\"]:\n                    if k in pad_width:\n                        pad_list_np.append(pad_width[k])\n                    else:\n                        pad_list_np.append((0, 0))\n            else:\n                pad_list_np = None\n        else:\n            pad_list_np = None\n\n        return window_read, pad_list_np\n\n    def footprint(self, crs: Optional[str] = None) -&gt; Polygon:\n        # TODO load footprint from metadata?\n        pol = window_utils.window_polygon(self.window_focus, self.transform)\n        if (crs is None) or window_utils.compare_crs(self.crs, crs):\n            return pol\n\n        return window_utils.polygon_to_crs(pol, self.crs, crs)\n\n    def valid_footprint(self, crs: Optional[str] = None) -&gt; Polygon:\n        valids = self.load_mask()\n        return valids.valid_footprint(crs=crs)\n\n    def _load_bands(\n        self,\n        bands_names: Union[List[str], str],\n        boundless: bool = True,\n        fill_value_default: Number = 0,\n    ) -&gt; geotensor.GeoTensor:\n        window_read, pad_list_np = self._get_window_pad(boundless=boundless)\n        slice_ = window_read.toslices()\n        if isinstance(bands_names, str):\n            bands_names = [bands_names]\n            flatten = True\n        else:\n            flatten = False\n\n        with h5py.File(self.hdf5_file, \"r\") as input_f:\n            bands_arrs = []\n            for band in bands_names:\n                data = read_band_toa(input_f, band, slice_)\n                if pad_list_np is not None:\n                    data = np.pad(\n                        data,\n                        tuple(pad_list_np),\n                        mode=\"constant\",\n                        constant_values=fill_value_default,\n                    )\n\n                bands_arrs.append(data)\n\n        if boundless:\n            transform = self.transform\n        else:\n            transform = rasterio.windows.transform(window_read, self.real_transform)\n\n        if flatten:\n            img = bands_arrs[0]\n        else:\n            img = np.stack(bands_arrs, axis=0)\n\n        return geotensor.GeoTensor(\n            img,\n            transform=transform,\n            crs=self.crs,\n            fill_value_default=fill_value_default,\n        )\n\n    def save_bands(self, img: np.ndarray):\n        \"\"\"\n\n        Args:\n            img: (4, self.real_height, self.real_width, 4) tensor\n\n        Returns:\n\n        \"\"\"\n        assert (\n            img.shape[0] == 4\n        ), \"Unexpected number of channels expected 4 found {}\".format(img.shape)\n        assert (\n            img.shape[1:] == self.real_shape\n        ), f\"Unexpected shape expected {self.real_shape} found {img.shape[1:]}\"\n\n        # TODO save only window_focus?\n\n        with h5py.File(self.hdf5_file, \"r+\") as input_f:\n            for i, b in enumerate(BAND_NAMES):\n                band_to_save = img[i]\n                mask_band_2_save = np.ma.getmaskarray(img[i])\n                band_to_save = np.clip(np.ma.filled(band_to_save, 0), 0, 2)\n                band_name = f\"{self.level_name}/RADIOMETRY/{b}/{self.toatoc}\"\n                attrs = input_f[band_name].attrs\n                band_to_save *= attrs[\"SCALE\"]\n                band_to_save += attrs[\"OFFSET\"]\n                band_to_save = np.round(band_to_save).astype(np.int16)\n                band_to_save[mask_band_2_save] = -1\n                input_f[band_name][...] = band_to_save\n\n    def load_radiometry(\n        self, indexes: Optional[List[int]] = None, boundless: bool = True\n    ) -&gt; geotensor.GeoTensor:\n        if indexes is None:\n            indexes = (0, 1, 2, 3)\n        bands_names = [\n            f\"{self.level_name}/RADIOMETRY/{BAND_NAMES[i]}/{self.toatoc}\"\n            for i in indexes\n        ]\n        return self._load_bands(\n            bands_names, boundless=boundless, fill_value_default=-1 / 2000.0\n        )\n\n    def load_sm(self, boundless: bool = True) -&gt; geotensor.GeoTensor:\n        \"\"\"\n        Reference of values in `SM` flags.\n\n        From [user manual](http://www.vito-eodata.be/PDF/image/PROBAV-Products_User_Manual.pdf) pag 67\n        * Clear  -&gt;    000\n        * Shadow -&gt;    001\n        * Undefined -&gt; 010\n        * Cloud  -&gt;    011\n        * Ice    -&gt;    100\n        * `2**3` sea/land\n        * `2**4` quality swir (0 bad 1 good)\n        * `2**5` quality nir\n        * `2**6` quality red\n        * `2**7` quality blue\n        * `2**8` coverage swir (0 no 1 yes)\n        * `2**9` coverage nir\n        * `2**10` coverage red\n        * `2**11` coverage blue\n        \"\"\"\n        return self._load_bands(\n            f\"{self.level_name}/QUALITY/SM\", boundless=boundless, fill_value_default=0\n        )\n\n    def load_mask(self, boundless: bool = True) -&gt; geotensor.GeoTensor:\n        \"\"\"\n        Returns the valid mask (False if the pixel is out of swath or is invalid). This function loads the SM band\n\n        Args:\n            boundless (bool, optional): boundless option to load the SM band. Defaults to True.\n\n        Returns:\n            geotensor.GeoTensor: mask with the same shape as the image\n        \"\"\"\n        valids = self.load_sm(boundless=boundless)\n        valids.values = ~mask_only_sm(valids.values)\n        valids.fill_value_default = False\n        return valids\n\n    def load_sm_cloud_mask(\n        self, mask_undefined: bool = False, boundless: bool = True\n    ) -&gt; geotensor.GeoTensor:\n        sm = self.load_sm(boundless=boundless)\n        cloud_mask = sm_cloud_mask(sm.values, mask_undefined=mask_undefined)\n        return geotensor.GeoTensor(\n            cloud_mask, transform=self.transform, crs=self.crs, fill_value_default=0\n        )\n\n    def is_recompressed_and_chunked(self) -&gt; bool:\n        original_bands = [\n            f\"{self.level_name}/RADIOMETRY/{b}/{self.toatoc}\" for b in BAND_NAMES\n        ]\n        original_bands.append(f\"{self.level_name}/QUALITY/SM\")\n        with h5py.File(self.hdf5_file, \"r\") as input_:\n            for b in original_bands:\n                if input_[b].compression == \"szip\":\n                    return False\n                if (input_[b].chunks is None) or (input_[b].chunks[0] == 1):\n                    return False\n        return True\n\n    def assert_can_be_read(self):\n        original_bands = [\n            f\"{self.level_name}/RADIOMETRY/{b}/{self.toatoc}\" for b in BAND_NAMES\n        ] + [f\"{self.level_name}/QUALITY/SM\"]\n        with h5py.File(self.hdf5_file, \"a\") as input_:\n            for name in original_bands:\n                assert is_compression_available(\n                    input_[name]\n                ), f\"Band {name} cannot be read. Compression: {input_[name].compression}\"\n\n    def recompress_bands(\n        self,\n        chunks: Tuple[int, int] = (512, 512),\n        replace: bool = True,\n        compression_dest: str = \"gzip\",\n    ):\n        original_bands = {\n            b: f\"{self.level_name}/RADIOMETRY/{b}/{self.toatoc}\" for b in BAND_NAMES\n        }\n        original_bands.update({\"SM\": f\"{self.level_name}/QUALITY/SM\"})\n        copy_bands = {k: v + \"_NEW\" for (k, v) in original_bands.items()}\n        with h5py.File(self.hdf5_file, \"a\") as input_:\n            for b in original_bands.keys():\n                assert_compression_available(input_[original_bands[b]])\n                data = input_[original_bands[b]][:]\n                if copy_bands[b] in input_:\n                    del input_[copy_bands[b]]\n\n                ds = input_.create_dataset(\n                    copy_bands[b],\n                    data=data,\n                    chunks=chunks,\n                    compression=compression_dest,\n                )\n\n                attrs_copy = input_[original_bands[b]].attrs\n                for k, v in attrs_copy.items():\n                    ds.attrs[k] = v\n\n                if replace:\n                    del input_[original_bands[b]]\n                    input_[original_bands[b]] = input_[copy_bands[b]]\n                    del input_[copy_bands[b]]\n\n    @property\n    def transform(self) -&gt; Affine:\n        return rasterio.windows.transform(self.window_focus, self.real_transform)\n\n    @property\n    def res(self) -&gt; Tuple[float, float]:\n        return window_utils.res(self.transform)\n\n    @property\n    def height(self) -&gt; int:\n        return self.window_focus.height\n\n    @property\n    def width(self) -&gt; int:\n        return self.window_focus.width\n\n    @property\n    def bounds(self) -&gt; Tuple[float, float, float, float]:\n        return window_utils.window_bounds(self.window_focus, self.real_transform)\n\n    def set_window(\n        self,\n        window: rasterio.windows.Window,\n        relative: bool = True,\n        boundless: bool = True,\n    ):\n        if relative:\n            self.window_focus = rasterio.windows.Window(\n                col_off=window.col_off + self.window_focus.col_off,\n                row_off=window.row_off + self.window_focus.row_off,\n                height=window.height,\n                width=window.width,\n            )\n        else:\n            self.window_focus = window\n\n        if not boundless:\n            self.window_focus = rasterio.windows.intersection(\n                self.window_data, self.window_focus\n            )\n\n    def __copy__(self) -&gt; \"__class__\":\n        return ProbaV(\n            self.hdf5_file, window=self.window_focus, level_name=self.level_name\n        )\n\n    def read_from_window(\n        self, window: Optional[rasterio.windows.Window] = None, boundless: bool = True\n    ) -&gt; \"__class__\":\n        copy = self.__copy__()\n        copy.set_window(window=window, boundless=boundless)\n\n        return copy\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\" \n         File: {self.hdf5_file}\n         Transform: {self.transform}\n         Shape: {self.height}, {self.width}\n         Resolution: {self.res}\n         Bounds: {self.bounds}\n         CRS: {self.crs}\n         Level: {self.level_name}\n         TOA/TOC: {self.toatoc}\n         Resolution name : {self.res_name}\n        \"\"\"\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.probav_image_operational.ProbaV.load_mask","title":"<code>load_mask(boundless=True)</code>","text":"<p>Returns the valid mask (False if the pixel is out of swath or is invalid). This function loads the SM band</p> <p>Parameters:</p> Name Type Description Default <code>boundless</code> <code>bool</code> <p>boundless option to load the SM band. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>GeoTensor</code> <p>geotensor.GeoTensor: mask with the same shape as the image</p> Source code in <code>georeader/readers/probav_image_operational.py</code> <pre><code>def load_mask(self, boundless: bool = True) -&gt; geotensor.GeoTensor:\n    \"\"\"\n    Returns the valid mask (False if the pixel is out of swath or is invalid). This function loads the SM band\n\n    Args:\n        boundless (bool, optional): boundless option to load the SM band. Defaults to True.\n\n    Returns:\n        geotensor.GeoTensor: mask with the same shape as the image\n    \"\"\"\n    valids = self.load_sm(boundless=boundless)\n    valids.values = ~mask_only_sm(valids.values)\n    valids.fill_value_default = False\n    return valids\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.probav_image_operational.ProbaV.load_sm","title":"<code>load_sm(boundless=True)</code>","text":"<p>Reference of values in <code>SM</code> flags.</p> <p>From user manual pag 67 * Clear  -&gt;    000 * Shadow -&gt;    001 * Undefined -&gt; 010 * Cloud  -&gt;    011 * Ice    -&gt;    100 * <code>2**3</code> sea/land * <code>2**4</code> quality swir (0 bad 1 good) * <code>2**5</code> quality nir * <code>2**6</code> quality red * <code>2**7</code> quality blue * <code>2**8</code> coverage swir (0 no 1 yes) * <code>2**9</code> coverage nir * <code>2**10</code> coverage red * <code>2**11</code> coverage blue</p> Source code in <code>georeader/readers/probav_image_operational.py</code> <pre><code>def load_sm(self, boundless: bool = True) -&gt; geotensor.GeoTensor:\n    \"\"\"\n    Reference of values in `SM` flags.\n\n    From [user manual](http://www.vito-eodata.be/PDF/image/PROBAV-Products_User_Manual.pdf) pag 67\n    * Clear  -&gt;    000\n    * Shadow -&gt;    001\n    * Undefined -&gt; 010\n    * Cloud  -&gt;    011\n    * Ice    -&gt;    100\n    * `2**3` sea/land\n    * `2**4` quality swir (0 bad 1 good)\n    * `2**5` quality nir\n    * `2**6` quality red\n    * `2**7` quality blue\n    * `2**8` coverage swir (0 no 1 yes)\n    * `2**9` coverage nir\n    * `2**10` coverage red\n    * `2**11` coverage blue\n    \"\"\"\n    return self._load_bands(\n        f\"{self.level_name}/QUALITY/SM\", boundless=boundless, fill_value_default=0\n    )\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.probav_image_operational.ProbaV.save_bands","title":"<code>save_bands(img)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>(4, self.real_height, self.real_width, 4) tensor</p> required <p>Returns:</p> Source code in <code>georeader/readers/probav_image_operational.py</code> <pre><code>def save_bands(self, img: np.ndarray):\n    \"\"\"\n\n    Args:\n        img: (4, self.real_height, self.real_width, 4) tensor\n\n    Returns:\n\n    \"\"\"\n    assert (\n        img.shape[0] == 4\n    ), \"Unexpected number of channels expected 4 found {}\".format(img.shape)\n    assert (\n        img.shape[1:] == self.real_shape\n    ), f\"Unexpected shape expected {self.real_shape} found {img.shape[1:]}\"\n\n    # TODO save only window_focus?\n\n    with h5py.File(self.hdf5_file, \"r+\") as input_f:\n        for i, b in enumerate(BAND_NAMES):\n            band_to_save = img[i]\n            mask_band_2_save = np.ma.getmaskarray(img[i])\n            band_to_save = np.clip(np.ma.filled(band_to_save, 0), 0, 2)\n            band_name = f\"{self.level_name}/RADIOMETRY/{b}/{self.toatoc}\"\n            attrs = input_f[band_name].attrs\n            band_to_save *= attrs[\"SCALE\"]\n            band_to_save += attrs[\"OFFSET\"]\n            band_to_save = np.round(band_to_save).astype(np.int16)\n            band_to_save[mask_band_2_save] = -1\n            input_f[band_name][...] = band_to_save\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.probav_image_operational.ProbaVRadiometry","title":"<code>ProbaVRadiometry</code>","text":"<p>               Bases: <code>ProbaV</code></p> <p>A specialized ProbaV reader class focused on radiometry data.</p> <p>This class extends the base ProbaV class to provide a simplified interface for working with radiometry bands from Proba-V products.</p> <p>Parameters:</p> Name Type Description Default <code>hdf5_file</code> <code>str</code> <p>Path to the HDF5 file containing the Proba-V product.</p> required <code>window</code> <code>Optional[Window]</code> <p>Optional window to focus on a specific region of the image. Defaults to None (entire image).</p> <code>None</code> <code>level_name</code> <code>str</code> <p>Processing level of the product. Defaults to \"LEVEL2A\".</p> <code>'LEVEL2A'</code> <code>indexes</code> <code>Optional[List[int]]</code> <p>Optional list of band indices to load. If None, all four bands (0=BLUE, 1=RED, 2=NIR, 3=SWIR) will be loaded. Defaults to None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>dims</code> <code>Tuple[str]</code> <p>Names of the dimensions (\"band\", \"y\", \"x\").</p> <code>indexes</code> <code>List[int]</code> <p>List of band indices to load.</p> <code>dtype</code> <p>Data type of the radiometry data.</p> <code>count</code> <code>int</code> <p>Number of bands to be loaded.</p> <code>shape</code> <code>Tuple[int, int, int]</code> <p>Shape of the data (bands, height, width).</p> <code>values</code> <code>ndarray</code> <p>The radiometry data values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Initialize the ProbaVRadiometry reader with a data path\n&gt;&gt;&gt; probav_rad = ProbaVRadiometry('/path/to/probav_product.HDF5')\n&gt;&gt;&gt; # Load only RED and NIR bands\n&gt;&gt;&gt; probav_rad_rn = ProbaVRadiometry('/path/to/probav_product.HDF5', indexes=[1, 2])\n&gt;&gt;&gt; # Get the data as a GeoTensor\n&gt;&gt;&gt; geotensor_data = probav_rad.load()\n</code></pre> Source code in <code>georeader/readers/probav_image_operational.py</code> <pre><code>class ProbaVRadiometry(ProbaV):\n    \"\"\"\n    A specialized ProbaV reader class focused on radiometry data.\n\n    This class extends the base ProbaV class to provide a simplified interface\n    for working with radiometry bands from Proba-V products.\n\n    Args:\n        hdf5_file (str): Path to the HDF5 file containing the Proba-V product.\n        window (Optional[rasterio.windows.Window]): Optional window to focus on a specific\n            region of the image. Defaults to None (entire image).\n        level_name (str): Processing level of the product. Defaults to \"LEVEL2A\".\n        indexes (Optional[List[int]]): Optional list of band indices to load. If None,\n            all four bands (0=BLUE, 1=RED, 2=NIR, 3=SWIR) will be loaded. Defaults to None.\n\n    Attributes:\n        dims (Tuple[str]): Names of the dimensions (\"band\", \"y\", \"x\").\n        indexes (List[int]): List of band indices to load.\n        dtype: Data type of the radiometry data.\n        count (int): Number of bands to be loaded.\n        shape (Tuple[int, int, int]): Shape of the data (bands, height, width).\n        values (np.ndarray): The radiometry data values.\n\n    Examples:\n        &gt;&gt;&gt; # Initialize the ProbaVRadiometry reader with a data path\n        &gt;&gt;&gt; probav_rad = ProbaVRadiometry('/path/to/probav_product.HDF5')\n        &gt;&gt;&gt; # Load only RED and NIR bands\n        &gt;&gt;&gt; probav_rad_rn = ProbaVRadiometry('/path/to/probav_product.HDF5', indexes=[1, 2])\n        &gt;&gt;&gt; # Get the data as a GeoTensor\n        &gt;&gt;&gt; geotensor_data = probav_rad.load()\n    \"\"\"\n\n    def __init__(\n        self,\n        hdf5_file: str,\n        window: Optional[rasterio.windows.Window] = None,\n        level_name: str = \"LEVEL2A\",\n        indexes: Optional[List[int]] = None,\n    ):\n        super().__init__(hdf5_file=hdf5_file, window=window, level_name=level_name)\n        self.dims = (\"band\", \"y\", \"x\")\n\n        # let read only some bands?\n        if indexes is None:\n            self.indexes = [0, 1, 2, 3]\n        else:\n            self.indexes = indexes\n\n        self.dtype = self.dtype_radiometry\n\n    @property\n    def count(self):\n        return len(self.indexes)\n\n    def load(self, boundless: bool = True) -&gt; geotensor.GeoTensor:\n        return self.load_radiometry(boundless=boundless, indexes=self.indexes)\n\n    @property\n    def shape(self) -&gt; Tuple:\n        return self.count, self.window_focus.height, self.window_focus.width\n\n    @property\n    def width(self) -&gt; int:\n        return self.window_focus.width\n\n    @property\n    def height(self) -&gt; int:\n        return self.window_focus.height\n\n    @property\n    def values(self) -&gt; np.ndarray:\n        return self.load_radiometry(boundless=True, indexes=self.indexes).values\n\n    def __copy__(self) -&gt; \"__class__\":\n        return ProbaVRadiometry(\n            self.hdf5_file,\n            window=self.window_focus,\n            level_name=self.level_name,\n            indexes=self.indexes,\n        )\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.probav_image_operational.ProbaVSM","title":"<code>ProbaVSM</code>","text":"<p>               Bases: <code>ProbaV</code></p> <p>A specialized ProbaV reader class focused on Status Map (SM) data.</p> <p>This class extends the base ProbaV class to provide a simplified interface for working with the status map band from Proba-V products. The SM band contains information about the pixel quality, cloud status, etc.</p> <p>Parameters:</p> Name Type Description Default <code>hdf5_file</code> <code>str</code> <p>Path to the HDF5 file containing the Proba-V product.</p> required <code>window</code> <code>Optional[Window]</code> <p>Optional window to focus on a specific region of the image. Defaults to None (entire image).</p> <code>None</code> <code>level_name</code> <code>str</code> <p>Processing level of the product. Defaults to \"LEVEL2A\".</p> <code>'LEVEL2A'</code> <p>Attributes:</p> Name Type Description <code>dims</code> <code>Tuple[str]</code> <p>Names of the dimensions (\"y\", \"x\").</p> <code>dtype</code> <p>Data type of the SM data.</p> <code>shape</code> <code>Tuple[int, int]</code> <p>Shape of the SM data (height, width).</p> <code>values</code> <code>ndarray</code> <p>The SM data values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Initialize the ProbaVSM reader with a data path\n&gt;&gt;&gt; probav_sm = ProbaVSM('/path/to/probav_product.HDF5')\n&gt;&gt;&gt; # Get the SM data as a GeoTensor\n&gt;&gt;&gt; sm_data = probav_sm.load()\n&gt;&gt;&gt; # Extract cloud information\n&gt;&gt;&gt; cloud_mask = sm_cloud_mask(sm_data.values)\n</code></pre> Source code in <code>georeader/readers/probav_image_operational.py</code> <pre><code>class ProbaVSM(ProbaV):\n    \"\"\"\n    A specialized ProbaV reader class focused on Status Map (SM) data.\n\n    This class extends the base ProbaV class to provide a simplified interface\n    for working with the status map band from Proba-V products. The SM band\n    contains information about the pixel quality, cloud status, etc.\n\n    Args:\n        hdf5_file (str): Path to the HDF5 file containing the Proba-V product.\n        window (Optional[rasterio.windows.Window]): Optional window to focus on a specific\n            region of the image. Defaults to None (entire image).\n        level_name (str): Processing level of the product. Defaults to \"LEVEL2A\".\n\n    Attributes:\n        dims (Tuple[str]): Names of the dimensions (\"y\", \"x\").\n        dtype: Data type of the SM data.\n        shape (Tuple[int, int]): Shape of the SM data (height, width).\n        values (np.ndarray): The SM data values.\n\n    Examples:\n        &gt;&gt;&gt; # Initialize the ProbaVSM reader with a data path\n        &gt;&gt;&gt; probav_sm = ProbaVSM('/path/to/probav_product.HDF5')\n        &gt;&gt;&gt; # Get the SM data as a GeoTensor\n        &gt;&gt;&gt; sm_data = probav_sm.load()\n        &gt;&gt;&gt; # Extract cloud information\n        &gt;&gt;&gt; cloud_mask = sm_cloud_mask(sm_data.values)\n    \"\"\"\n\n    def __init__(\n        self,\n        hdf5_file: str,\n        window: Optional[rasterio.windows.Window] = None,\n        level_name: str = \"LEVEL2A\",\n    ):\n        super().__init__(hdf5_file=hdf5_file, window=window, level_name=level_name)\n        self.dims = (\"y\", \"x\")\n        self.dtype = self.dtype_sm\n\n    def load(self, boundless: bool = True) -&gt; geotensor.GeoTensor:\n        return self.load_sm(boundless=boundless)\n\n    @property\n    def shape(self) -&gt; Tuple:\n        return self.window_focus.height, self.window_focus.width\n\n    @property\n    def width(self) -&gt; int:\n        return self.window_focus.width\n\n    @property\n    def height(self) -&gt; int:\n        return self.window_focus.height\n\n    @property\n    def values(self) -&gt; np.ndarray:\n        return self.load_sm(boundless=True).values\n\n    def __copy__(self) -&gt; \"__class__\":\n        return ProbaVSM(\n            self.hdf5_file, window=self.window_focus, level_name=self.level_name\n        )\n</code></pre>"},{"location":"modules/readers_module/#spot-vgt-reader","title":"SPOT-VGT Reader","text":"<p>The SPOT-VGT reader provides functionality for reading SPOT-VGT products. Features include:</p> <ul> <li>HDF4 file format support</li> <li>Handling of radiometry and quality layers</li> <li>Cloud and shadow mask extraction</li> </ul> <p>Note: See the Proba-V tutorial for similar processing workflows as both sensors share similar data structures.</p>"},{"location":"modules/readers_module/#api-reference_2","title":"API Reference","text":"<p>SPOT VGT reader</p> <p>Unofficial reader for SPOT VGT products. The reader is based on the user manual: https://docs.terrascope.be/DataProducts/SPOT-VGT/references/SPOT_VGT_PUM_v1.3.pdf</p> <p>Authors: Dan Lopez-Puigdollers, Gonzalo Mateo-Garc\u00eda</p>"},{"location":"modules/readers_module/#georeader.readers.spotvgt_image_operational.SpotVGT","title":"<code>SpotVGT</code>","text":"<p>SPOT-VGT reader for handling SPOT Vegetation satellite products.</p> <p>This class provides functionality to read and manipulate SPOT-VGT satellite imagery products. It handles the specific format and metadata of SPOT-VGT HDF4 files, supporting operations like loading radiometry data, masks, and cloud information.</p> <p>Parameters:</p> Name Type Description Default <code>hdf4_file</code> <code>str</code> <p>Path to the HDF4 file or directory containing the SPOT-VGT product.</p> required <code>window</code> <code>Optional[Window]</code> <p>Optional window to focus on a specific  region of the image. Defaults to None (entire image).</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>hdf4_file</code> <code>str</code> <p>Path to the HDF4 file.</p> <code>name</code> <code>str</code> <p>Basename of the HDF4 file.</p> <code>satelliteID</code> <code>str</code> <p>Satellite ID extracted from the filename.</p> <code>station</code> <code>str</code> <p>Station code extracted from the filename.</p> <code>productID</code> <code>str</code> <p>Product ID extracted from the filename.</p> <code>year,</code> <code>month, day (str</code> <p>Date components extracted from the filename.</p> <code>segment</code> <code>str</code> <p>Segment identifier extracted from the filename.</p> <code>version</code> <code>str</code> <p>Product version extracted from the filename.</p> <code>files</code> <code>List[str]</code> <p>List of files in the SPOT-VGT product.</p> <code>files_dict</code> <code>Dict[str, str]</code> <p>Dictionary mapping band names to file paths.</p> <code>metadata</code> <code>Dict[str, str]</code> <p>Metadata extracted from the LOG file.</p> <code>real_shape</code> <code>Tuple[int, int]</code> <p>Shape of the full image (height, width).</p> <code>real_transform</code> <code>Affine</code> <p>Affine transform for the full image.</p> <code>dtype_radiometry</code> <p>Data type for radiometry data (typically np.float32).</p> <code>window_focus</code> <code>Window</code> <p>Current window focus.</p> <code>window_data</code> <code>Window</code> <p>Window representing the full data extent.</p> <code>start_date</code> <code>datetime</code> <p>Start acquisition date and time.</p> <code>end_date</code> <code>datetime</code> <p>End acquisition date and time.</p> <code>crs</code> <p>Coordinate reference system.</p> <code>toatoc</code> <code>str</code> <p>Indicator of whether data is TOA (top of atmosphere).</p> <code>res_name</code> <code>str</code> <p>Resolution name identifier (e.g., '1KM').</p> <code>level_name</code> <code>str</code> <p>Processing level identifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import rasterio.windows\n&gt;&gt;&gt; # Initialize the SpotVGT reader with a data path\n&gt;&gt;&gt; spot_reader = SpotVGT('/path/to/V2KRNP____20140321F146_V003')\n&gt;&gt;&gt; # Load radiometry data\n&gt;&gt;&gt; bands = spot_reader.load_radiometry()\n&gt;&gt;&gt; # Get cloud mask\n&gt;&gt;&gt; cloud_mask = spot_reader.load_sm_cloud_mask()\n&gt;&gt;&gt; # Focus on a specific window\n&gt;&gt;&gt; window = rasterio.windows.Window(col_off=100, row_off=100, width=200, height=200)\n&gt;&gt;&gt; spot_reader.set_window(window)\n</code></pre> Source code in <code>georeader/readers/spotvgt_image_operational.py</code> <pre><code>class SpotVGT:\n    \"\"\"\n    SPOT-VGT reader for handling SPOT Vegetation satellite products.\n\n    This class provides functionality to read and manipulate SPOT-VGT satellite imagery products.\n    It handles the specific format and metadata of SPOT-VGT HDF4 files, supporting operations\n    like loading radiometry data, masks, and cloud information.\n\n    Args:\n        hdf4_file (str): Path to the HDF4 file or directory containing the SPOT-VGT product.\n        window (Optional[rasterio.windows.Window]): Optional window to focus on a specific \n            region of the image. Defaults to None (entire image).\n\n    Attributes:\n        hdf4_file (str): Path to the HDF4 file.\n        name (str): Basename of the HDF4 file.\n        satelliteID (str): Satellite ID extracted from the filename.\n        station (str): Station code extracted from the filename.\n        productID (str): Product ID extracted from the filename.\n        year, month, day (str): Date components extracted from the filename.\n        segment (str): Segment identifier extracted from the filename.\n        version (str): Product version extracted from the filename.\n        files (List[str]): List of files in the SPOT-VGT product.\n        files_dict (Dict[str, str]): Dictionary mapping band names to file paths.\n        metadata (Dict[str, str]): Metadata extracted from the LOG file.\n        real_shape (Tuple[int, int]): Shape of the full image (height, width).\n        real_transform (rasterio.Affine): Affine transform for the full image.\n        dtype_radiometry: Data type for radiometry data (typically np.float32).\n        window_focus (rasterio.windows.Window): Current window focus.\n        window_data (rasterio.windows.Window): Window representing the full data extent.\n        start_date (dt.datetime): Start acquisition date and time.\n        end_date (dt.datetime): End acquisition date and time.\n        crs: Coordinate reference system.\n        toatoc (str): Indicator of whether data is TOA (top of atmosphere).\n        res_name (str): Resolution name identifier (e.g., '1KM').\n        level_name (str): Processing level identifier.\n\n    Examples:\n        &gt;&gt;&gt; import rasterio.windows\n        &gt;&gt;&gt; # Initialize the SpotVGT reader with a data path\n        &gt;&gt;&gt; spot_reader = SpotVGT('/path/to/V2KRNP____20140321F146_V003')\n        &gt;&gt;&gt; # Load radiometry data\n        &gt;&gt;&gt; bands = spot_reader.load_radiometry()\n        &gt;&gt;&gt; # Get cloud mask\n        &gt;&gt;&gt; cloud_mask = spot_reader.load_sm_cloud_mask()\n        &gt;&gt;&gt; # Focus on a specific window\n        &gt;&gt;&gt; window = rasterio.windows.Window(col_off=100, row_off=100, width=200, height=200)\n        &gt;&gt;&gt; spot_reader.set_window(window)\n    \"\"\"\n    def __init__(self, hdf4_file: str, window: Optional[rasterio.windows.Window] = None):\n        self.hdf4_file = hdf4_file\n        self.name = os.path.basename(self.hdf4_file)\n        matches = re.match(r'V(\\d{1})(\\w{3})(\\w{1})____(\\d{4})(\\d{2})(\\d{2})F(\\w{3})_V(\\d{3})', self.name)\n        if matches is not None:\n            (self.satelliteID, self.station, self.productID, self.year,\n             self.month, self.day, self.segment, self.version) = matches.groups()\n        else:\n            raise FileNotFoundError(\"SPOT-VGT product not recognized %s\" % self.hdf4_file)\n\n        try:\n            self.files = sorted([f for f in glob(os.path.join(self.hdf4_file, '*'))])\n            self.files_dict = {re.match(r'V\\d{12}_(\\w+)',\n                                        os.path.basename(self.files[i])).groups()[0]: self.files[i]\n                               for i in range(len(self.files))}\n\n            with open(self.files_dict['LOG'], \"r\") as f:\n                self.metadata = {re.split(r'\\s+', y)[0]: re.split(r'\\s+', y)[1] for y in [x for x in f]}\n\n            self.real_shape = (\n                int(self.metadata[\"IMAGE_LOWER_RIGHT_ROW\"]) - int(self.metadata[\"IMAGE_UPPER_LEFT_ROW\"]) - 1,\n                int(self.metadata[\"IMAGE_LOWER_RIGHT_COL\"]) - int(self.metadata[\"IMAGE_UPPER_LEFT_COL\"]) - 1)\n\n            bbox = [\n                float(self.metadata['CARTO_LOWER_LEFT_X']),\n                float(self.metadata['CARTO_LOWER_LEFT_Y']),\n                float(self.metadata['CARTO_UPPER_RIGHT_X']),\n                float(self.metadata['CARTO_UPPER_RIGHT_Y'])\n            ]\n            self.real_transform = rasterio.transform.from_bounds(*bbox, width=self.real_shape[1],\n                                                                 height=self.real_shape[0])\n\n            self.dtype_radiometry = np.float32\n\n        except OSError as e:\n            raise FileNotFoundError(\"Error reading product %s\" % self.hdf4_file)\n\n        if window is None:\n            self.window_focus = rasterio.windows.Window(row_off=0, col_off=0,\n                                                        width=self.real_shape[1],\n                                                        height=self.real_shape[0])\n        else:\n            self.window_focus = rasterio.windows.Window(row_off=0, col_off=0,\n                                                        width=self.real_shape[1],\n                                                        height=self.real_shape[0])\n\n        self.window_data = rasterio.windows.Window(row_off=0, col_off=0,\n                                                   width=self.real_shape[1],\n                                                   height=self.real_shape[0])\n\n        year, month, day = re.match(r'(\\d{4})(\\d{2})(\\d{2})', self.metadata['SEGM_FIRST_DATE']).groups()\n        hh, mm, ss = re.match(r'(\\d{2})(\\d{2})(\\d{2})', self.metadata['SEGM_FIRST_TIME']).groups()\n\n        self.start_date = dt.datetime(day=int(day), month=int(month), year=int(year),\n                                      hour=int(hh), minute=int(mm), second=int(ss), tzinfo=dt.timezone.utc)\n\n        year, month, day = re.match(r'(\\d{4})(\\d{2})(\\d{2})', self.metadata['SEGM_LAST_DATE']).groups()\n        hh, mm, ss = re.match(r'(\\d{2})(\\d{2})(\\d{2})', self.metadata['SEGM_LAST_TIME']).groups()\n\n        self.end_date = dt.datetime(day=int(day), month=int(month), year=int(year),\n                                    hour=int(hh), minute=int(mm), second=int(ss), tzinfo=dt.timezone.utc)\n\n        # self.map_projection_wkt\n\n        self.toatoc = \"TOA\"\n\n        self.res_name = '1KM'\n\n        # SPOT-VGT images are lat/long\n        self.crs = rasterio.crs.CRS({'init': 'epsg:4326'})\n\n        # SPOT-VGT images have four bands\n        self.level_name = \"LEVEL2A\"\n\n    def _get_window_pad(self, boundless: bool = True) -&gt; Tuple[rasterio.windows.Window, Optional[List]]:\n        window_read = rasterio.windows.intersection(self.window_focus, self.window_data)\n\n        if boundless:\n            _, pad_width = window_utils.get_slice_pad(self.window_data, self.window_focus)\n            need_pad = any(p != 0 for p in pad_width[\"x\"] + pad_width[\"y\"])\n            if need_pad:\n                pad_list_np = []\n                for k in [\"y\", \"x\"]:\n                    if k in pad_width:\n                        pad_list_np.append(pad_width[k])\n                    else:\n                        pad_list_np.append((0, 0))\n            else:\n                pad_list_np = None\n        else:\n            pad_list_np = None\n\n        return window_read, pad_list_np\n\n    def footprint(self, crs:Optional[str]=None) -&gt; Polygon:\n        # TODO load footprint from metadata?\n        pol = window_utils.window_polygon(self.window_focus, self.transform)\n        if (crs is None) or window_utils.compare_crs(self.crs, crs):\n            return pol\n\n        return window_utils.polygon_to_crs(pol, self.crs, crs)\n\n    def valid_footprint(self, crs:Optional[str]=None) -&gt; Polygon:\n        valids = self.load_mask()\n        return valids.valid_footprint(crs=crs)        \n\n    def _load_bands(self, bands_names: Union[List[str], str], boundless: bool = True,\n                    fill_value_default: Number = 0) -&gt; geotensor.GeoTensor:\n        window_read, pad_list_np = self._get_window_pad(boundless=boundless)\n        slice_ = window_read.toslices()\n        if isinstance(bands_names, str):\n            bands_names = [bands_names]\n            flatten = True\n        else:\n            flatten = False\n\n        hdf_objs = {b: SD(self.files_dict[b], SDC.READ) for b in bands_names}\n        # Read dataset\n        # shapes = [hdf_objs[b].datasets()[\"PIXEL_DATA\"][1] for b in bands_names]\n        # data = [hdf_objs[b].select(\"PIXEL_DATA\")[slice_] for b in bands_names]\n\n        bands_arrs = []\n        # Original slice int32 gives an error. Cast to int\n        for band in bands_names:\n            data = read_band_toa(hdf_objs, band, (slice(int(slice_[0].start), int(slice_[0].stop), None),\n                                                  slice(int(slice_[1].start), int(slice_[1].stop), None)))\n            if pad_list_np:\n                data = np.pad(data, tuple(pad_list_np), mode=\"constant\", constant_values=fill_value_default)\n\n            bands_arrs.append(data)\n\n        if boundless:\n            transform = self.transform\n        else:\n            transform = rasterio.windows.transform(window_read, self.real_transform)\n\n        if flatten:\n            img = bands_arrs[0]\n        else:\n            img = np.stack(bands_arrs, axis=0)\n\n        return geotensor.GeoTensor(img, transform=transform, crs=self.crs,\n                                   fill_value_default=fill_value_default)\n\n    def load_radiometry(self, indexes: Optional[List[int]] = None, boundless: bool = True) -&gt; geotensor.GeoTensor:\n        if indexes is None:\n            indexes = (0, 1, 2, 3)\n        # bands_names = [f\"{self.level_name}/RADIOMETRY/{BAND_NAMES[i]}/{self.toatoc}\" for i in indexes]\n        bands_names = [BANDS_DICT[i] for i in indexes]\n        return self._load_bands(bands_names, boundless=boundless, fill_value_default=0)\n\n    def load_sm(self, boundless: bool = True) -&gt; geotensor.GeoTensor:\n        \"\"\"\n        Reference of values in `SM` flags.\n\n        From [user manual](https://docs.terrascope.be/DataProducts/SPOT-VGT/references/SPOT_VGT_PUM_v1.3.pdf) pag 46\n        * Clear  -&gt;    000\n        * Shadow -&gt;    001\n        * Undefined -&gt; 010\n        * Cloud  -&gt;    011\n        * Ice    -&gt;    100\n        * `2**3` sea/land\n        * `2**4` quality swir (0 bad 1 good)\n        * `2**5` quality nir\n        * `2**6` quality red\n        * `2**7` quality blue\n        \"\"\"\n        return self._load_bands('SM', boundless=boundless, fill_value_default=0)\n\n    def load_mask(self, boundless: bool = True) -&gt; geotensor.GeoTensor:\n        \"\"\"\n        Returns the valid mask (False if the pixel is out of swath or is invalid). This function loads the SM band\n\n        Args:\n            boundless (bool, optional): boundless option to load the SM band. Defaults to True.\n\n        Returns:\n            geotensor.GeoTensor: mask with the same shape as the image\n        \"\"\"\n\n        sm = self.load_sm(boundless=boundless)\n        valids = sm.copy()\n        invalids = mask_only_sm(sm.values)\n        valids.values = ~invalids\n        valids.fill_value_default = False\n\n        return valids\n\n    def load_sm_cloud_mask(self, mask_undefined:bool=False, boundless:bool=True) -&gt; geotensor.GeoTensor:\n        sm = self.load_sm(boundless=boundless)\n        cloud_mask = sm_cloud_mask(sm.values, mask_undefined=mask_undefined)\n        cloud_mask+=1\n        invalids = mask_only_sm(sm.values)\n\n        cloud_mask[invalids] = 0\n        return geotensor.GeoTensor(cloud_mask, transform=self.transform, crs=self.crs, fill_value_default=0)\n\n    @property\n    def transform(self) -&gt; Affine:\n        return rasterio.windows.transform(self.window_focus, self.real_transform)\n\n    @property\n    def res(self) -&gt; Tuple[float, float]:\n        return window_utils.res(self.transform)\n\n    @property\n    def height(self) -&gt; int:\n        return self.window_focus.height\n\n    @property\n    def width(self) -&gt; int:\n        return self.window_focus.width\n\n    @property\n    def bounds(self) -&gt; Tuple[float, float, float, float]:\n        return window_utils.window_bounds(self.window_focus, self.real_transform)\n\n    def set_window(self, window:rasterio.windows.Window, relative: bool = True, boundless: bool = True):\n        if relative:\n            self.window_focus = rasterio.windows.Window(col_off=window.col_off + self.window_focus.col_off,\n                                                        row_off=window.row_off + self.window_focus.row_off,\n                                                        height=window.height, width=window.width)\n        else:\n            self.window_focus = window\n\n        if not boundless:\n            self.window_focus = rasterio.windows.intersection(self.window_data, self.window_focus)\n\n    def __copy__(self) -&gt; '__class__':\n        return SpotVGT(self.hdf4_file, window=self.window_focus)\n\n    def read_from_window(self, window: Optional[rasterio.windows.Window] = None, boundless: bool = True) -&gt; '__class__':\n        copy = self.__copy__()\n        copy.set_window(window=window, boundless=boundless)\n\n        return copy\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\" \n         File: {self.hdf4_file}\n         Transform: {self.transform}\n         Shape: {self.height}, {self.width}\n         Resolution: {self.res}\n         Bounds: {self.bounds}\n         CRS: {self.crs}\n         Level: {self.level_name}\n         TOA/TOC: {self.toatoc}\n         Resolution name : {self.res_name}\n        \"\"\"\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.spotvgt_image_operational.SpotVGT.load_mask","title":"<code>load_mask(boundless=True)</code>","text":"<p>Returns the valid mask (False if the pixel is out of swath or is invalid). This function loads the SM band</p> <p>Parameters:</p> Name Type Description Default <code>boundless</code> <code>bool</code> <p>boundless option to load the SM band. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>GeoTensor</code> <p>geotensor.GeoTensor: mask with the same shape as the image</p> Source code in <code>georeader/readers/spotvgt_image_operational.py</code> <pre><code>def load_mask(self, boundless: bool = True) -&gt; geotensor.GeoTensor:\n    \"\"\"\n    Returns the valid mask (False if the pixel is out of swath or is invalid). This function loads the SM band\n\n    Args:\n        boundless (bool, optional): boundless option to load the SM band. Defaults to True.\n\n    Returns:\n        geotensor.GeoTensor: mask with the same shape as the image\n    \"\"\"\n\n    sm = self.load_sm(boundless=boundless)\n    valids = sm.copy()\n    invalids = mask_only_sm(sm.values)\n    valids.values = ~invalids\n    valids.fill_value_default = False\n\n    return valids\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.spotvgt_image_operational.SpotVGT.load_sm","title":"<code>load_sm(boundless=True)</code>","text":"<p>Reference of values in <code>SM</code> flags.</p> <p>From user manual pag 46 * Clear  -&gt;    000 * Shadow -&gt;    001 * Undefined -&gt; 010 * Cloud  -&gt;    011 * Ice    -&gt;    100 * <code>2**3</code> sea/land * <code>2**4</code> quality swir (0 bad 1 good) * <code>2**5</code> quality nir * <code>2**6</code> quality red * <code>2**7</code> quality blue</p> Source code in <code>georeader/readers/spotvgt_image_operational.py</code> <pre><code>def load_sm(self, boundless: bool = True) -&gt; geotensor.GeoTensor:\n    \"\"\"\n    Reference of values in `SM` flags.\n\n    From [user manual](https://docs.terrascope.be/DataProducts/SPOT-VGT/references/SPOT_VGT_PUM_v1.3.pdf) pag 46\n    * Clear  -&gt;    000\n    * Shadow -&gt;    001\n    * Undefined -&gt; 010\n    * Cloud  -&gt;    011\n    * Ice    -&gt;    100\n    * `2**3` sea/land\n    * `2**4` quality swir (0 bad 1 good)\n    * `2**5` quality nir\n    * `2**6` quality red\n    * `2**7` quality blue\n    \"\"\"\n    return self._load_bands('SM', boundless=boundless, fill_value_default=0)\n</code></pre>"},{"location":"modules/readers_module/#prisma-reader","title":"PRISMA Reader","text":"<p>The PRISMA reader handles data from the Italian Space Agency's hyperspectral mission, specifically working with Level 1B radiance data (not atmospherically corrected). PRISMA provides hyperspectral imaging in the 400-2500 nm spectral range, with a spectral resolution of ~12 nm.</p> <p>Key features:</p> <ul> <li>Reading L1B hyperspectral radiance data from HDF5 format files</li> <li>Handling separate VNIR (400-1000 nm) and SWIR (1000-2500 nm) spectral ranges</li> <li>Georeferencing functionality for non-orthorectified data using provided latitude/longitude coordinates</li> <li>On-demand conversion from radiance (mW/m\u00b2/sr/nm) to top-of-atmosphere reflectance</li> <li>Spectral response function integration for accurate band simulation</li> <li>Extraction of RGB previews from specific wavelengths</li> <li>Access to satellite and solar geometry information for radiometric calculations</li> </ul> <p>Tutorial examples:</p> <ul> <li>Reading overlapping PRISMA and EMIT images</li> <li>Cloud detection in PRISMA images</li> </ul>"},{"location":"modules/readers_module/#api-reference_3","title":"API Reference","text":""},{"location":"modules/readers_module/#georeader.readers.prisma.PRISMA","title":"<code>PRISMA</code>","text":"<p>PRISMA (PRecursore IperSpettrale della Missione Applicativa) image reader.</p> <p>This class provides functionality to read and manipulate PRISMA satellite imagery products. It handles the specific format and metadata of PRISMA HDF5 files, supporting operations like loading specific wavelengths, RGB composites, and converting to reflectance.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the PRISMA HDF5 file.</p> required <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>Path to the PRISMA file.</p> <code>swir_cube_dat</code> <code>str</code> <p>Path to SWIR cube data in HDF5 file.</p> <code>vni_cube_dat</code> <code>str</code> <p>Path to VNIR cube data in HDF5 file.</p> <code>lats</code> <code>ndarray</code> <p>Latitude values for each pixel.</p> <code>lons</code> <code>ndarray</code> <p>Longitude values for each pixel.</p> <code>attributes_prisma</code> <code>Dict</code> <p>Dictionary of PRISMA metadata attributes.</p> <code>nbands_vnir</code> <code>int</code> <p>Number of VNIR bands.</p> <code>vnir_range</code> <code>Tuple[float, float]</code> <p>Wavelength range of VNIR bands (min, max).</p> <code>nbands_swir</code> <code>int</code> <p>Number of SWIR bands.</p> <code>swir_range</code> <code>Tuple[float, float]</code> <p>Wavelength range of SWIR bands (min, max).</p> <code>ltoa_swir</code> <code>Optional[NDArray]</code> <p>SWIR radiance data, lazily loaded.</p> <code>ltoa_vnir</code> <code>Optional[NDArray]</code> <p>VNIR radiance data, lazily loaded.</p> <code>wavelength_swir</code> <code>Optional[NDArray]</code> <p>SWIR wavelengths, lazily loaded.</p> <code>fwhm_swir</code> <code>Optional[NDArray]</code> <p>SWIR FWHM (Full Width at Half Maximum), lazily loaded.</p> <code>wavelength_vnir</code> <code>Optional[NDArray]</code> <p>VNIR wavelengths, lazily loaded.</p> <code>fwhm_vnir</code> <code>Optional[NDArray]</code> <p>VNIR FWHM, lazily loaded.</p> <code>vza_swir</code> <code>float</code> <p>Viewing zenith angle for SWIR.</p> <code>vza_vnir</code> <code>float</code> <p>Viewing zenith angle for VNIR.</p> <code>sza_swir</code> <code>float</code> <p>Solar zenith angle for SWIR.</p> <code>sza_vnir</code> <code>float</code> <p>Solar zenith angle for VNIR.</p> <code>time_coverage_start</code> <code>datetime</code> <p>Start time of acquisition.</p> <code>time_coverage_end</code> <code>datetime</code> <p>End time of acquisition.</p> <code>units</code> <code>str</code> <p>Units of radiance data (mW/m2/sr/nm).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Initialize the PRISMA reader with a data path\n&gt;&gt;&gt; prisma = PRISMA('/path/to/prisma_file.he5')\n&gt;&gt;&gt; # Load RGB bands\n&gt;&gt;&gt; rgb = prisma.load_rgb(as_reflectance=True)\n&gt;&gt;&gt; # Load specific wavelengths\n&gt;&gt;&gt; bands = prisma.load_wavelengths([850, 1600, 2200], as_reflectance=True)\n&gt;&gt;&gt; # Get image metadata\n&gt;&gt;&gt; print(prisma)\n</code></pre> Source code in <code>georeader/readers/prisma.py</code> <pre><code>class PRISMA:\n    \"\"\"\n    PRISMA (PRecursore IperSpettrale della Missione Applicativa) image reader.\n\n    This class provides functionality to read and manipulate PRISMA satellite imagery products.\n    It handles the specific format and metadata of PRISMA HDF5 files, supporting operations\n    like loading specific wavelengths, RGB composites, and converting to reflectance.\n\n    Args:\n        filename (str): Path to the PRISMA HDF5 file.\n\n    Attributes:\n        filename (str): Path to the PRISMA file.\n        swir_cube_dat (str): Path to SWIR cube data in HDF5 file.\n        vni_cube_dat (str): Path to VNIR cube data in HDF5 file.\n        lats (numpy.ndarray): Latitude values for each pixel.\n        lons (numpy.ndarray): Longitude values for each pixel.\n        attributes_prisma (Dict): Dictionary of PRISMA metadata attributes.\n        nbands_vnir (int): Number of VNIR bands.\n        vnir_range (Tuple[float, float]): Wavelength range of VNIR bands (min, max).\n        nbands_swir (int): Number of SWIR bands.\n        swir_range (Tuple[float, float]): Wavelength range of SWIR bands (min, max).\n        ltoa_swir (Optional[NDArray]): SWIR radiance data, lazily loaded.\n        ltoa_vnir (Optional[NDArray]): VNIR radiance data, lazily loaded.\n        wavelength_swir (Optional[NDArray]): SWIR wavelengths, lazily loaded.\n        fwhm_swir (Optional[NDArray]): SWIR FWHM (Full Width at Half Maximum), lazily loaded.\n        wavelength_vnir (Optional[NDArray]): VNIR wavelengths, lazily loaded.\n        fwhm_vnir (Optional[NDArray]): VNIR FWHM, lazily loaded.\n        vza_swir (float): Viewing zenith angle for SWIR.\n        vza_vnir (float): Viewing zenith angle for VNIR.\n        sza_swir (float): Solar zenith angle for SWIR.\n        sza_vnir (float): Solar zenith angle for VNIR.\n        time_coverage_start (datetime): Start time of acquisition.\n        time_coverage_end (datetime): End time of acquisition.\n        units (str): Units of radiance data (mW/m2/sr/nm).\n\n    Examples:\n        &gt;&gt;&gt; # Initialize the PRISMA reader with a data path\n        &gt;&gt;&gt; prisma = PRISMA('/path/to/prisma_file.he5')\n        &gt;&gt;&gt; # Load RGB bands\n        &gt;&gt;&gt; rgb = prisma.load_rgb(as_reflectance=True)\n        &gt;&gt;&gt; # Load specific wavelengths\n        &gt;&gt;&gt; bands = prisma.load_wavelengths([850, 1600, 2200], as_reflectance=True)\n        &gt;&gt;&gt; # Get image metadata\n        &gt;&gt;&gt; print(prisma)\n    \"\"\"\n\n    def __init__(self, filename: str) -&gt; None:\n        if not os.path.exists(filename):\n            raise FileNotFoundError(f\"File {filename} not found\")\n        self.filename = filename\n        self.swir_cube_dat = SWIR_FLAG[\"swir_cube_dat\"][True]\n        self.vni_cube_dat = SWIR_FLAG[\"swir_cube_dat\"][False]\n\n        with h5py.File(filename, mode=\"r\") as f:\n            dset = f[HE5_COORDS[\"swir_lat\"]]\n            self.lats = np.flip(dset[:, :], axis=0)\n            dset = f[HE5_COORDS[\"swir_lon\"]]\n            self.lons = np.flip(dset[:, :], axis=0)\n            self.attributes_prisma = dict(f.attrs)\n            sza = f.attrs[\"Sun_zenith_angle\"]\n\n        arr = self.attributes_prisma[\"List_Cw_Vnir\"][\n            self.attributes_prisma[\"List_Cw_Vnir\"] &gt; 0\n        ]\n        self.nbands_vnir = len(arr)\n        self.vnir_range = arr.min(), arr.max()\n        arr = self.attributes_prisma[\"List_Cw_Swir\"][\n            self.attributes_prisma[\"List_Cw_Swir\"] &gt; 0\n        ]\n        self.swir_range = arr.min(), arr.max()\n        self.nbands_swir = len(arr)\n\n        self.ltoa_swir: Optional[NDArray] = None\n        self.ltoa_vnir: Optional[NDArray] = None\n        self.wavelength_swir: Optional[NDArray] = None\n        self.fwhm_swir: Optional[NDArray] = None\n        self.wavelength_vnir: Optional[NDArray] = None\n        self.fwhm_vnir: Optional[NDArray] = None\n        self.vza_swir: float = 0\n        self.vza_vnir: float = 0\n        self.sza_swir: float = sza\n        self.sza_vnir: float = sza\n\n        # self.time_coverage_start = self.attributes_prisma['Product_StartTime']\n        self.time_coverage_start = datetime.fromisoformat(\n            self.attributes_prisma[\"Product_StartTime\"].decode(\"utf-8\")\n        ).replace(tzinfo=timezone.utc)\n        self.time_coverage_end = datetime.fromisoformat(\n            self.attributes_prisma[\"Product_StopTime\"].decode(\"utf-8\")\n        ).replace(tzinfo=timezone.utc)\n        self.units = \"mW/m2/sr/nm\"  # same as W/m^2/SR/um\n\n        self._footprint = griddata.footprint(self.lons, self.lats)\n        self._observation_date_correction_factor: Optional[float] = None\n\n    def footprint(self, crs: Optional[str] = None) -&gt; GeoTensor:\n        if (crs is None) or compare_crs(\"EPSG:4326\", crs):\n            return self._footprint\n\n        return window_utils.polygon_to_crs(\n            self._footprint, crs_polygon=\"EPSG:4326\", crs_dst=crs\n        )\n\n    @property\n    def observation_date_correction_factor(self) -&gt; float:\n        if self._observation_date_correction_factor is None:\n            self._observation_date_correction_factor = (\n                reflectance.observation_date_correction_factor(\n                    date_of_acquisition=self.time_coverage_start,\n                    center_coords=self.footprint(\"EPSG:4326\").centroid.coords[0],\n                )\n            )\n        return self._observation_date_correction_factor\n\n    @property\n    def bounds(self) -&gt; Tuple[float, float, float, float]:\n        return self._footprint.bounds\n\n    def load_raw(self, swir_flag: bool) -&gt; NDArray:\n        \"\"\"\n        Load the all the data from all the wavelengths for the VNIR or SWIR range.\n        This function caches the data, wavelegths and FWHM in the attributes of the class:\n            * `ltoa_swir`, `wavelength_swir`, `fwhm_swir`, `vza_swir`, `sza_swir` if `swir_flag` is True\n            * `ltoa_vnir`, `wavelength_vnir`, `fwhm_vnir`, `vza_vnir`, `sza_vnir` if `swir_flag` is False\n\n        Args:\n            swir_flag (bool): if True it will load the SWIR range, otherwise it will load the VNIR range\n\n        Returns:\n            NDArray: 3D array with the reflectance values (H, W, B)\n                where N and M are the dimensions of the image and B is the number of bands.\n        \"\"\"\n\n        if swir_flag:\n            if all(\n                x is not None\n                for x in [\n                    self.ltoa_swir,\n                    self.wavelength_swir,\n                    self.fwhm_swir,\n                    self.vza_swir,\n                    self.sza_swir,\n                ]\n            ):\n                return self.ltoa_swir\n        else:\n            if all(\n                x is not None\n                for x in [\n                    self.ltoa_vnir,\n                    self.wavelength_vnir,\n                    self.fwhm_vnir,\n                    self.vza_vnir,\n                    self.sza_vnir,\n                ]\n            ):\n                return self.ltoa_vnir\n\n        swir_cube_dat = SWIR_FLAG[\"swir_cube_dat\"][swir_flag]\n        swir_lab = SWIR_FLAG[\"swir_lab\"][swir_flag]  # True: \"Swir\", False: \"Vnir\"\n\n        with h5py.File(self.filename, \"r\") as f:\n            dset = f[swir_cube_dat]\n\n            ltoa_img = np.flip(np.transpose(dset[:, :, :], axes=[0, 2, 1]), axis=0)\n\n            dset = f[\"/KDP_AUX/Cw_\" + swir_lab + \"_Matrix\"]\n            wvl_mat_ini = dset[:, :]\n\n            dset = f[\"/KDP_AUX/Fwhm_\" + swir_lab + \"_Matrix\"]\n            fwhm_mat_ini = dset[:, :]\n\n            sc_fac = f.attrs[\"ScaleFactor_\" + swir_lab]\n\n            of_fac = f.attrs[\"Offset_\" + swir_lab]\n\n            vza = 0.0\n            sza = f.attrs[\"Sun_zenith_angle\"]\n\n            ltoa_img = ltoa_img / sc_fac - of_fac\n\n        # Lambda\n        wvl_mat_ini = np.flip(wvl_mat_ini, axis=1)\n        li_no0 = np.where(wvl_mat_ini[100, :] &gt; 0)[0]\n        wvl_mat = np.copy(wvl_mat_ini[:, li_no0])\n        wl_center_ini = np.mean(wvl_mat, axis=0)\n\n        # FWHM\n        fwhm_mat_ini = np.flip(fwhm_mat_ini, axis=1)\n        fwhm_mat = np.copy(fwhm_mat_ini[:, li_no0])\n\n        M, N, B_tot = ltoa_img.shape\n\n        if swir_flag:\n            if B_tot == len(wl_center_ini):\n                ltoa_img = np.flip(ltoa_img, axis=2)\n            else:\n                ltoa_img = np.flip(ltoa_img[:, :, :-2], axis=2)\n\n        else:\n            if B_tot == len(wl_center_ini):\n                ltoa_img = np.flip(ltoa_img, axis=2)\n            else:\n                ltoa_img = np.flip(ltoa_img[:, :, 3:], axis=2)  # Revisar esto(not sure)\n\n        ltoa_img = np.transpose(ltoa_img, (1, 0, 2))\n        if swir_flag:\n            self.ltoa_swir = ltoa_img\n            self.wavelength_swir = wvl_mat\n            self.fwhm_swir = fwhm_mat\n            self.vza_swir = vza\n            self.sza_swir = sza\n        else:\n            self.ltoa_vnir = ltoa_img\n            self.wavelength_vnir = wvl_mat\n            self.fwhm_vnir = fwhm_mat\n            self.vza_vnir = vza\n            self.sza_vnir = sza\n\n        return ltoa_img\n\n    # def target_spectrum(self, swir_flag:bool) -&gt; NDArray:\n\n    #     if swir_flag:\n    #         vza = self.vza_swir\n    #         sza = self.sza_swir\n    #         band_array = self.wavelength_swir\n    #         fwhm_array = self.fwhm_swir\n    #         N, M, B = self.ltoa_swir.shape\n    #     else:\n    #         vza = self.vza_vnir\n    #         sza = self.sza_vnir\n    #         band_array = self.wavelength_vnir\n    #         fwhm_array = self.fwhm_vnir\n    #         N, M, B = self.ltoa_vnir.shape\n\n    #     amf = 1.0 / np.cos(vza * np.pi / 180) + 1.0 / np.cos(sza * np.pi / 180)\n    #     parent_dir = os.path.dirname(os.path.dirname(__file__))\n    #     file_lut_gas = os.path.join(parent_dir, LUT_FILE[\"name\"])\n\n    #     wvl_mod, t_gas_arr, gas_sc_arr, mr_gas_arr = read_luts(\n    #         file_lut=file_lut_gas,\n    #         t_arr_str=LUT_FILE[\"t_arr_variable\"],\n    #         sc_arr_str=LUT_FILE[\"sc_arr_variable\"],\n    #         mr_arr_str=LUT_FILE[\"mr_arr_variable\"],\n    #         amf=amf,\n    #     )\n\n    #     n_wvl = len(wvl_mod)\n    #     mr_gas_arr = mr_gas_arr / 1000.0\n    #     delta_mr_ref = 1.0\n\n    #     k_spectre = calc_jac_rad(mr_gas_arr, n_wvl, t_gas_arr, delta_mr_ref)\n    #     k_array = np.zeros((M, B))\n    #     for i in range(0, M):\n    #         s = generate_filter(wvl_mod, band_array[i], fwhm_array[i])\n    #         k = np.dot(k_spectre, s)\n    #         k_array[i] = k\n\n    #     return k_array\n\n    def load_wavelengths(\n        self,\n        wavelengths: Union[float, List[float], NDArray],\n        as_reflectance: bool = True,\n        raw: bool = True,\n        resolution_dst=30,\n        dst_crs: Optional[Any] = None,\n        fill_value_default: float = -1,\n    ) -&gt; Union[GeoTensor, NDArray]:\n        \"\"\"\n        Load the reflectance of the given wavelengths\n\n        Args:\n            wavelengths (Union[float, List[float], NDArray]): List of wavelengths to load\n            as_reflectance (bool, optional): return the values as reflectance rather than radiance. Defaults to True.\n                If False values will have units of W/m^2/SR/um (`self.units`)\n            raw (bool, optional): if True it will return the raw values,\n                if False it will return the values reprojected to the specified CRS and resolution. Defaults to True.\n            resolution_dst (int, optional): if raw is False, it will reproject the values to this resolution. Defaults to 30.\n            dst_crs (Optional[Any], optional): if None it will use the corresponding UTM zone.\n            fill_value_default (float, optional): fill value. Defaults to -1.\n\n        Returns:\n            Union[GeoTensor, NDArray]: if raw is True it will return a NDArray with the values, otherwise it will return a GeoTensor\n                with the reprojected values in its `.values` attribute.\n        \"\"\"\n\n        if isinstance(wavelengths, Number):\n            wavelengths = np.array([wavelengths])\n        else:\n            wavelengths = np.array(wavelengths)\n\n        load_swir = any(\n            [\n                wvl &gt;= self.swir_range[0] and wvl &lt; self.swir_range[1]\n                for wvl in wavelengths\n            ]\n        )\n        load_vnir = any(\n            [\n                wvl &gt;= self.vnir_range[0] and wvl &lt; self.vnir_range[1]\n                for wvl in wavelengths\n            ]\n        )\n        if load_swir:\n            self.load_raw(swir_flag=True)\n            wavelength_swir_mean = np.mean(self.wavelength_swir, axis=0)\n            fwhm_swir_mean = np.mean(self.fwhm_swir, axis=0)\n        if load_vnir:\n            self.load_raw(swir_flag=False)\n            wavelength_vnir_mean = np.mean(self.wavelength_vnir, axis=0)\n            fwhm_vnir_mean = np.mean(self.fwhm_vnir, axis=0)\n\n        ltoa_img = []\n        fwhm = []\n        for b in range(len(wavelengths)):\n            if (\n                wavelengths[b] &gt;= self.swir_range[0]\n                and wavelengths[b] &lt; self.swir_range[1]\n            ):\n                index_band = np.argmin(np.abs(wavelengths[b] - wavelength_swir_mean))\n                fwhm.append(fwhm_swir_mean[index_band])\n                img = self.ltoa_swir[..., index_band]\n            else:\n                index_band = np.argmin(np.abs(wavelengths[b] - wavelength_vnir_mean))\n                fwhm.append(fwhm_vnir_mean[index_band])\n                img = self.ltoa_vnir[..., index_band]\n\n            ltoa_img.append(img)\n\n        # Transpose to row major\n        ltoa_img = np.transpose(np.stack(ltoa_img, axis=0), (0, 2, 1))\n\n        if as_reflectance:\n            thuiller = reflectance.load_thuillier_irradiance()\n            response = reflectance.srf(wavelengths, fwhm, thuiller[\"Nanometer\"].values)\n\n            solar_irradiance_norm = thuiller[\"Radiance(mW/m2/nm)\"].values.dot(\n                response\n            )  # mW/m$^2$/nm\n            solar_irradiance_norm /= 1_000  # W/m$^2$/nm\n\n            ltoa_img = reflectance.radiance_to_reflectance(\n                ltoa_img,\n                solar_irradiance_norm,\n                units=self.units,\n                observation_date_corr_factor=self.observation_date_correction_factor,\n            )\n\n        if raw:\n            return ltoa_img\n\n        return griddata.read_to_crs(\n            np.transpose(ltoa_img, (1, 2, 0)),\n            lons=self.lons,\n            lats=self.lats,\n            resolution_dst=resolution_dst,\n            dst_crs=dst_crs,\n            fill_value_default=fill_value_default,\n        )\n\n    def load_rgb(\n        self, as_reflectance: bool = True, raw: bool = True\n    ) -&gt; Union[GeoTensor, NDArray]:\n        return self.load_wavelengths(\n            wavelengths=WAVELENGTHS_RGB, as_reflectance=as_reflectance, raw=raw\n        )\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\"\n        File: {self.filename}\n        Bounds: {self.bounds}\n        Time: {self.time_coverage_start}\n        VNIR Range: {self.vnir_range} {self.nbands_vnir} bands\n        SWIR Range: {self.swir_range} {self.nbands_swir} bands\n        \"\"\"\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.prisma.PRISMA.load_raw","title":"<code>load_raw(swir_flag)</code>","text":"<p>Load the all the data from all the wavelengths for the VNIR or SWIR range. This function caches the data, wavelegths and FWHM in the attributes of the class:     * <code>ltoa_swir</code>, <code>wavelength_swir</code>, <code>fwhm_swir</code>, <code>vza_swir</code>, <code>sza_swir</code> if <code>swir_flag</code> is True     * <code>ltoa_vnir</code>, <code>wavelength_vnir</code>, <code>fwhm_vnir</code>, <code>vza_vnir</code>, <code>sza_vnir</code> if <code>swir_flag</code> is False</p> <p>Parameters:</p> Name Type Description Default <code>swir_flag</code> <code>bool</code> <p>if True it will load the SWIR range, otherwise it will load the VNIR range</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>3D array with the reflectance values (H, W, B) where N and M are the dimensions of the image and B is the number of bands.</p> Source code in <code>georeader/readers/prisma.py</code> <pre><code>def load_raw(self, swir_flag: bool) -&gt; NDArray:\n    \"\"\"\n    Load the all the data from all the wavelengths for the VNIR or SWIR range.\n    This function caches the data, wavelegths and FWHM in the attributes of the class:\n        * `ltoa_swir`, `wavelength_swir`, `fwhm_swir`, `vza_swir`, `sza_swir` if `swir_flag` is True\n        * `ltoa_vnir`, `wavelength_vnir`, `fwhm_vnir`, `vza_vnir`, `sza_vnir` if `swir_flag` is False\n\n    Args:\n        swir_flag (bool): if True it will load the SWIR range, otherwise it will load the VNIR range\n\n    Returns:\n        NDArray: 3D array with the reflectance values (H, W, B)\n            where N and M are the dimensions of the image and B is the number of bands.\n    \"\"\"\n\n    if swir_flag:\n        if all(\n            x is not None\n            for x in [\n                self.ltoa_swir,\n                self.wavelength_swir,\n                self.fwhm_swir,\n                self.vza_swir,\n                self.sza_swir,\n            ]\n        ):\n            return self.ltoa_swir\n    else:\n        if all(\n            x is not None\n            for x in [\n                self.ltoa_vnir,\n                self.wavelength_vnir,\n                self.fwhm_vnir,\n                self.vza_vnir,\n                self.sza_vnir,\n            ]\n        ):\n            return self.ltoa_vnir\n\n    swir_cube_dat = SWIR_FLAG[\"swir_cube_dat\"][swir_flag]\n    swir_lab = SWIR_FLAG[\"swir_lab\"][swir_flag]  # True: \"Swir\", False: \"Vnir\"\n\n    with h5py.File(self.filename, \"r\") as f:\n        dset = f[swir_cube_dat]\n\n        ltoa_img = np.flip(np.transpose(dset[:, :, :], axes=[0, 2, 1]), axis=0)\n\n        dset = f[\"/KDP_AUX/Cw_\" + swir_lab + \"_Matrix\"]\n        wvl_mat_ini = dset[:, :]\n\n        dset = f[\"/KDP_AUX/Fwhm_\" + swir_lab + \"_Matrix\"]\n        fwhm_mat_ini = dset[:, :]\n\n        sc_fac = f.attrs[\"ScaleFactor_\" + swir_lab]\n\n        of_fac = f.attrs[\"Offset_\" + swir_lab]\n\n        vza = 0.0\n        sza = f.attrs[\"Sun_zenith_angle\"]\n\n        ltoa_img = ltoa_img / sc_fac - of_fac\n\n    # Lambda\n    wvl_mat_ini = np.flip(wvl_mat_ini, axis=1)\n    li_no0 = np.where(wvl_mat_ini[100, :] &gt; 0)[0]\n    wvl_mat = np.copy(wvl_mat_ini[:, li_no0])\n    wl_center_ini = np.mean(wvl_mat, axis=0)\n\n    # FWHM\n    fwhm_mat_ini = np.flip(fwhm_mat_ini, axis=1)\n    fwhm_mat = np.copy(fwhm_mat_ini[:, li_no0])\n\n    M, N, B_tot = ltoa_img.shape\n\n    if swir_flag:\n        if B_tot == len(wl_center_ini):\n            ltoa_img = np.flip(ltoa_img, axis=2)\n        else:\n            ltoa_img = np.flip(ltoa_img[:, :, :-2], axis=2)\n\n    else:\n        if B_tot == len(wl_center_ini):\n            ltoa_img = np.flip(ltoa_img, axis=2)\n        else:\n            ltoa_img = np.flip(ltoa_img[:, :, 3:], axis=2)  # Revisar esto(not sure)\n\n    ltoa_img = np.transpose(ltoa_img, (1, 0, 2))\n    if swir_flag:\n        self.ltoa_swir = ltoa_img\n        self.wavelength_swir = wvl_mat\n        self.fwhm_swir = fwhm_mat\n        self.vza_swir = vza\n        self.sza_swir = sza\n    else:\n        self.ltoa_vnir = ltoa_img\n        self.wavelength_vnir = wvl_mat\n        self.fwhm_vnir = fwhm_mat\n        self.vza_vnir = vza\n        self.sza_vnir = sza\n\n    return ltoa_img\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.prisma.PRISMA.load_wavelengths","title":"<code>load_wavelengths(wavelengths, as_reflectance=True, raw=True, resolution_dst=30, dst_crs=None, fill_value_default=-1)</code>","text":"<p>Load the reflectance of the given wavelengths</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Union[float, List[float], NDArray]</code> <p>List of wavelengths to load</p> required <code>as_reflectance</code> <code>bool</code> <p>return the values as reflectance rather than radiance. Defaults to True. If False values will have units of W/m^2/SR/um (<code>self.units</code>)</p> <code>True</code> <code>raw</code> <code>bool</code> <p>if True it will return the raw values, if False it will return the values reprojected to the specified CRS and resolution. Defaults to True.</p> <code>True</code> <code>resolution_dst</code> <code>int</code> <p>if raw is False, it will reproject the values to this resolution. Defaults to 30.</p> <code>30</code> <code>dst_crs</code> <code>Optional[Any]</code> <p>if None it will use the corresponding UTM zone.</p> <code>None</code> <code>fill_value_default</code> <code>float</code> <p>fill value. Defaults to -1.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, NDArray]</code> <p>Union[GeoTensor, NDArray]: if raw is True it will return a NDArray with the values, otherwise it will return a GeoTensor with the reprojected values in its <code>.values</code> attribute.</p> Source code in <code>georeader/readers/prisma.py</code> <pre><code>def load_wavelengths(\n    self,\n    wavelengths: Union[float, List[float], NDArray],\n    as_reflectance: bool = True,\n    raw: bool = True,\n    resolution_dst=30,\n    dst_crs: Optional[Any] = None,\n    fill_value_default: float = -1,\n) -&gt; Union[GeoTensor, NDArray]:\n    \"\"\"\n    Load the reflectance of the given wavelengths\n\n    Args:\n        wavelengths (Union[float, List[float], NDArray]): List of wavelengths to load\n        as_reflectance (bool, optional): return the values as reflectance rather than radiance. Defaults to True.\n            If False values will have units of W/m^2/SR/um (`self.units`)\n        raw (bool, optional): if True it will return the raw values,\n            if False it will return the values reprojected to the specified CRS and resolution. Defaults to True.\n        resolution_dst (int, optional): if raw is False, it will reproject the values to this resolution. Defaults to 30.\n        dst_crs (Optional[Any], optional): if None it will use the corresponding UTM zone.\n        fill_value_default (float, optional): fill value. Defaults to -1.\n\n    Returns:\n        Union[GeoTensor, NDArray]: if raw is True it will return a NDArray with the values, otherwise it will return a GeoTensor\n            with the reprojected values in its `.values` attribute.\n    \"\"\"\n\n    if isinstance(wavelengths, Number):\n        wavelengths = np.array([wavelengths])\n    else:\n        wavelengths = np.array(wavelengths)\n\n    load_swir = any(\n        [\n            wvl &gt;= self.swir_range[0] and wvl &lt; self.swir_range[1]\n            for wvl in wavelengths\n        ]\n    )\n    load_vnir = any(\n        [\n            wvl &gt;= self.vnir_range[0] and wvl &lt; self.vnir_range[1]\n            for wvl in wavelengths\n        ]\n    )\n    if load_swir:\n        self.load_raw(swir_flag=True)\n        wavelength_swir_mean = np.mean(self.wavelength_swir, axis=0)\n        fwhm_swir_mean = np.mean(self.fwhm_swir, axis=0)\n    if load_vnir:\n        self.load_raw(swir_flag=False)\n        wavelength_vnir_mean = np.mean(self.wavelength_vnir, axis=0)\n        fwhm_vnir_mean = np.mean(self.fwhm_vnir, axis=0)\n\n    ltoa_img = []\n    fwhm = []\n    for b in range(len(wavelengths)):\n        if (\n            wavelengths[b] &gt;= self.swir_range[0]\n            and wavelengths[b] &lt; self.swir_range[1]\n        ):\n            index_band = np.argmin(np.abs(wavelengths[b] - wavelength_swir_mean))\n            fwhm.append(fwhm_swir_mean[index_band])\n            img = self.ltoa_swir[..., index_band]\n        else:\n            index_band = np.argmin(np.abs(wavelengths[b] - wavelength_vnir_mean))\n            fwhm.append(fwhm_vnir_mean[index_band])\n            img = self.ltoa_vnir[..., index_band]\n\n        ltoa_img.append(img)\n\n    # Transpose to row major\n    ltoa_img = np.transpose(np.stack(ltoa_img, axis=0), (0, 2, 1))\n\n    if as_reflectance:\n        thuiller = reflectance.load_thuillier_irradiance()\n        response = reflectance.srf(wavelengths, fwhm, thuiller[\"Nanometer\"].values)\n\n        solar_irradiance_norm = thuiller[\"Radiance(mW/m2/nm)\"].values.dot(\n            response\n        )  # mW/m$^2$/nm\n        solar_irradiance_norm /= 1_000  # W/m$^2$/nm\n\n        ltoa_img = reflectance.radiance_to_reflectance(\n            ltoa_img,\n            solar_irradiance_norm,\n            units=self.units,\n            observation_date_corr_factor=self.observation_date_correction_factor,\n        )\n\n    if raw:\n        return ltoa_img\n\n    return griddata.read_to_crs(\n        np.transpose(ltoa_img, (1, 2, 0)),\n        lons=self.lons,\n        lats=self.lats,\n        resolution_dst=resolution_dst,\n        dst_crs=dst_crs,\n        fill_value_default=fill_value_default,\n    )\n</code></pre>"},{"location":"modules/readers_module/#emit-reader","title":"EMIT Reader","text":"<p>The EMIT (Earth Surface Mineral Dust Source Investigation) reader provides access to NASA's imaging spectrometer data from the International Space Station. This reader works with Level 1B calibrated radiance data (not atmospherically corrected).</p> <p>Key features:</p> <ul> <li>Reading L1B hyperspectral radiance data from NetCDF4 format files</li> <li>Working with the 380-2500 nm spectral range with 7.4 nm sampling</li> <li>Irregular grid georeferencing through GLT (Geographic Lookup Table)</li> <li>Support for the observation geometry information (solar and viewing angles)</li> <li>Integration with L2A mask products for cloud and shadow detection</li> <li>Quality-aware analysis with cloud, cirrus, and spacecraft flag masks</li> <li>Conversion from radiance (\u03bcW/cm\u00b2/sr/nm) to top-of-atmosphere reflectance</li> <li>Support for downloading data from NASA DAAC portals</li> <li>Automatic detection and use of appropriate UTM projection</li> </ul> <p>Tutorial example:</p> <ul> <li>Working with EMIT images</li> </ul>"},{"location":"modules/readers_module/#api-reference_4","title":"API Reference","text":"<p>Module to read EMIT images.</p> <p>Requires: netCDF4: pip install netCDF4 </p> <p>Some of the functions of this module are based on the official EMIT repo: https://github.com/emit-sds/emit-utils/</p>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage","title":"<code>EMITImage</code>","text":"<p>Class to read L1B EMIT (Earth Surface Mineral Dust Source Investigation) images.</p> <p>This class provides functionality to read and manipulate EMIT satellite imagery products. It handles the specific format and metadata of EMIT HDF files, supporting operations like loading radiometry data, masks, and viewing/solar angles.</p> <p>This class incorporates features from the official EMIT utilities: https://github.com/emit-sds/emit-utils/</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the EMIT .nc file.</p> required <code>glt</code> <code>Optional[GeoTensor]</code> <p>Optional pre-loaded GLT (Geographic Lookup Table). If None, it will be loaded from the file. Defaults to None.</p> <code>None</code> <code>band_selection</code> <code>Optional[Union[int, Tuple[int, ...], slice]]</code> <p>Optional band selection. Defaults to slice(None) (all bands).</p> <code>slice(None)</code> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>Path to the EMIT file.</p> <code>nc_ds</code> <code>Dataset</code> <p>netCDF4 dataset for the EMIT file.</p> <code>_nc_ds_obs</code> <code>Optional[Dataset]</code> <p>netCDF4 dataset for observation data.</p> <code>_nc_ds_l2amask</code> <code>Optional[Dataset]</code> <p>netCDF4 dataset for L2A mask.</p> <code>real_transform</code> <code>Affine</code> <p>Affine transform for the image.</p> <code>time_coverage_start</code> <code>datetime</code> <p>Start time of the acquisition.</p> <code>time_coverage_end</code> <code>datetime</code> <p>End time of the acquisition.</p> <code>dtype</code> <p>Data type of the radiometry data.</p> <code>dims</code> <code>Tuple[str]</code> <p>Names of dimensions (\"band\", \"y\", \"x\").</p> <code>fill_value_default</code> <p>Default fill value.</p> <code>nodata</code> <p>No data value.</p> <code>units</code> <code>str</code> <p>Units of the radiometry data.</p> <code>glt</code> <code>GeoTensor</code> <p>Geographic Lookup Table as a GeoTensor.</p> <code>valid_glt</code> <code>ndarray</code> <p>Boolean mask of valid GLT values.</p> <code>glt_relative</code> <code>GeoTensor</code> <p>Relative Geographic Lookup Table.</p> <code>window_raw</code> <code>Window</code> <p>Window for raw data.</p> <code>bandname_dimension</code> <code>str</code> <p>Dimension name for bands.</p> <code>band_selection</code> <p>Current band selection.</p> <code>wavelengths</code> <code>ndarray</code> <p>Wavelengths of the selected bands.</p> <code>fwhm</code> <code>ndarray</code> <p>Full Width at Half Maximum for each band.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from georeader.readers.emit import EMITImage, download_product\n&gt;&gt;&gt; link = 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/EMIT_L1B_RAD_001_20220828T051941_2224004_006/EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n&gt;&gt;&gt; filepath = download_product(link)\n&gt;&gt;&gt; emit = EMITImage(filepath)\n&gt;&gt;&gt; # Reproject to UTM\n&gt;&gt;&gt; crs_utm = georeader.get_utm_epsg(emit.footprint(\"EPSG:4326\"))\n&gt;&gt;&gt; emit_utm = emit.to_crs(crs_utm)\n&gt;&gt;&gt; # Load as reflectance\n&gt;&gt;&gt; reflectance = emit_utm.load(as_reflectance=True)\n&gt;&gt;&gt; # Get cloud mask\n&gt;&gt;&gt; cloud_mask = emit.nc_ds_l2amask\n</code></pre> Source code in <code>georeader/readers/emit.py</code> <pre><code>class EMITImage:\n    \"\"\"\n    Class to read L1B EMIT (Earth Surface Mineral Dust Source Investigation) images.\n\n    This class provides functionality to read and manipulate EMIT satellite imagery products.\n    It handles the specific format and metadata of EMIT HDF files, supporting operations\n    like loading radiometry data, masks, and viewing/solar angles.\n\n    This class incorporates features from the official EMIT utilities:\n    https://github.com/emit-sds/emit-utils/\n\n    Args:\n        filename (str): Path to the EMIT .nc file.\n        glt (Optional[GeoTensor]): Optional pre-loaded GLT (Geographic Lookup Table).\n            If None, it will be loaded from the file. Defaults to None.\n        band_selection (Optional[Union[int, Tuple[int, ...], slice]]): Optional band selection.\n            Defaults to slice(None) (all bands).\n\n    Attributes:\n        filename (str): Path to the EMIT file.\n        nc_ds (netCDF4.Dataset): netCDF4 dataset for the EMIT file.\n        _nc_ds_obs (Optional[netCDF4.Dataset]): netCDF4 dataset for observation data.\n        _nc_ds_l2amask (Optional[netCDF4.Dataset]): netCDF4 dataset for L2A mask.\n        real_transform (rasterio.Affine): Affine transform for the image.\n        time_coverage_start (datetime): Start time of the acquisition.\n        time_coverage_end (datetime): End time of the acquisition.\n        dtype: Data type of the radiometry data.\n        dims (Tuple[str]): Names of dimensions (\"band\", \"y\", \"x\").\n        fill_value_default: Default fill value.\n        nodata: No data value.\n        units (str): Units of the radiometry data.\n        glt (GeoTensor): Geographic Lookup Table as a GeoTensor.\n        valid_glt (numpy.ndarray): Boolean mask of valid GLT values.\n        glt_relative (GeoTensor): Relative Geographic Lookup Table.\n        window_raw (rasterio.windows.Window): Window for raw data.\n        bandname_dimension (str): Dimension name for bands.\n        band_selection: Current band selection.\n        wavelengths (numpy.ndarray): Wavelengths of the selected bands.\n        fwhm (numpy.ndarray): Full Width at Half Maximum for each band.\n\n    Examples:\n        &gt;&gt;&gt; from georeader.readers.emit import EMITImage, download_product\n        &gt;&gt;&gt; link = 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/EMIT_L1B_RAD_001_20220828T051941_2224004_006/EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n        &gt;&gt;&gt; filepath = download_product(link)\n        &gt;&gt;&gt; emit = EMITImage(filepath)\n        &gt;&gt;&gt; # Reproject to UTM\n        &gt;&gt;&gt; crs_utm = georeader.get_utm_epsg(emit.footprint(\"EPSG:4326\"))\n        &gt;&gt;&gt; emit_utm = emit.to_crs(crs_utm)\n        &gt;&gt;&gt; # Load as reflectance\n        &gt;&gt;&gt; reflectance = emit_utm.load(as_reflectance=True)\n        &gt;&gt;&gt; # Get cloud mask\n        &gt;&gt;&gt; cloud_mask = emit.nc_ds_l2amask\n    \"\"\"\n    attributes_set_if_exists = [\"_nc_ds_obs\", \"_mean_sza\", \"_mean_vza\", \n                                \"_observation_bands\", \"_nc_ds_l2amask\", \"_mask_bands\", \n                                \"_nc_ds\", \"obs_file\",\n                                \"l2amaskfile\"]\n    def __init__(self, filename:str, glt:Optional[GeoTensor]=None, \n                 band_selection:Optional[Union[int, Tuple[int, ...],slice]]=slice(None)):\n        self.filename = filename\n        self.nc_ds = netCDF4.Dataset(self.filename, 'r', format='NETCDF4')\n        self._nc_ds_obs:Optional[netCDF4.Dataset] = None\n        self._nc_ds_l2amask:Optional[netCDF4.Dataset] = None\n        self._observation_bands = None\n        self._mask_bands = None\n        self.nc_ds.set_auto_mask(False) # disable automatic masking when reading data\n        # self.real_shape = (self.nc_ds['radiance'].shape[-1],) + self.nc_ds['radiance'].shape[:-1]\n\n        self._mean_sza = None\n        self._mean_vza = None\n        self.obs_file:Optional[str] = None\n        self.l2amaskfile:Optional[str] = None\n\n        self.real_transform = rasterio.Affine(self.nc_ds.geotransform[1], self.nc_ds.geotransform[2], self.nc_ds.geotransform[0],\n                                              self.nc_ds.geotransform[4], self.nc_ds.geotransform[5], self.nc_ds.geotransform[3])\n\n        self.time_coverage_start = datetime.strptime(self.nc_ds.time_coverage_start, \"%Y-%m-%dT%H:%M:%S%z\")\n        self.time_coverage_end = datetime.strptime(self.nc_ds.time_coverage_end, \"%Y-%m-%dT%H:%M:%S%z\")\n\n        self.dtype = self.nc_ds['radiance'].dtype\n        self.dims = (\"band\", \"y\", \"x\")\n        self.fill_value_default = self.nc_ds['radiance']._FillValue\n        self.nodata = self.nc_ds['radiance']._FillValue\n        self.units = self.nc_ds[\"radiance\"].units\n\n        if glt is None:\n            glt_arr = np.zeros((2,) + self.nc_ds.groups['location']['glt_x'].shape, dtype=np.int32)\n            glt_arr[0] = np.array(self.nc_ds.groups['location']['glt_x'])\n            glt_arr[1] = np.array(self.nc_ds.groups['location']['glt_y'])\n            # glt_arr -= 1 # account for 1-based indexing\n\n            # https://rasterio.readthedocs.io/en/stable/api/rasterio.crs.html\n            self.glt = GeoTensor(glt_arr, transform=self.real_transform, \n                                 crs=rasterio.crs.CRS.from_wkt(self.nc_ds.spatial_ref),\n                                 fill_value_default=0)\n        else:\n            self.glt = glt\n\n        self.valid_glt = np.all(self.glt.values != self.glt.fill_value_default, axis=0)\n        xmin, ymin, xmax, ymax = self._bounds_indexes_raw() # values are 1-based!\n\n        # glt has the absolute indexes of the netCDF object\n        # glt_relative has the relative indexes\n        self.glt_relative = self.glt.copy()\n        self.glt_relative.values[0, self.valid_glt] -= xmin\n        self.glt_relative.values[1, self.valid_glt] -= ymin\n\n        self.window_raw = rasterio.windows.Window(col_off=xmin-1, row_off=ymin-1, \n                                                  width=xmax-xmin+1, height=ymax-ymin+1)\n\n        if \"wavelengths\" in self.nc_ds['sensor_band_parameters'].variables:\n            self.bandname_dimension = \"wavelengths\"\n        elif \"radiance_wl\"  in self.nc_ds['sensor_band_parameters'].variables:\n            self.bandname_dimension = \"radiance_wl\"\n        else:\n            raise ValueError(f\"Cannot find wavelength dimension in {list(self.nc_ds['sensor_band_parameters'].variables.keys())}\")\n\n        self.band_selection = band_selection\n        self.wavelengths = self.nc_ds['sensor_band_parameters'][self.bandname_dimension][self.band_selection]\n        self.fwhm = self.nc_ds['sensor_band_parameters']['fwhm'][self.band_selection]\n        self._observation_date_correction_factor:Optional[float] = None\n\n    @property\n    def observation_date_correction_factor(self) -&gt; float:\n        if self._observation_date_correction_factor is None:\n            self._observation_date_correction_factor = reflectance.observation_date_correction_factor(date_of_acquisition=self.time_coverage_start,\n                                                                                                      center_coords=self.footprint(\"EPSG:4326\").centroid.coords[0])\n        return self._observation_date_correction_factor\n\n    @property\n    def crs(self) -&gt; Any:\n        return self.glt.crs\n\n    @property\n    def shape(self) -&gt; Tuple:\n        try:\n            n_bands = len(self.wavelengths)\n            return  (n_bands,) + self.glt.shape[1:]\n        except Exception:\n            return self.glt.shape\n\n    @property\n    def width(self) -&gt; int:\n        return self.shape[-1]\n\n    @property\n    def height(self) -&gt; int:\n        return self.shape[-2]\n\n    @property\n    def transform(self) -&gt; rasterio.Affine:\n        return self.glt.transform\n\n    @property\n    def res(self) -&gt; Tuple[float, float]:\n        return self.glt.res\n\n    @property\n    def bounds(self) -&gt; Tuple[float, float, float, float]:\n        return self.glt.bounds\n\n    def footprint(self, crs:Optional[str]=None) -&gt; Polygon:\n        \"\"\"\n        Get the footprint of the image in the given CRS. If no CRS is given, the footprint is returned in the native CRS.\n        This function takes into account the valid_glt mask to compute the footprint.\n\n        Args:\n            crs (Optional[str], optional): The CRS to return the footprint in. Defaults to None. \n                If None, the footprint is returned in the native CRS.\n\n        Returns:\n            Polygon: The footprint of the image in the given CRS.\n        \"\"\"\n        if not hasattr(self, '_pol'):\n            from georeader.vectorize import get_polygons\n            pols = get_polygons(self.valid_glt, transform=self.transform)\n            self._pol = unary_union(pols)\n        if crs is not None:\n            pol_crs = window_utils.polygon_to_crs(self._pol, self.crs, crs)\n        else:\n            pol_crs = self._pol\n\n        pol_glt = self.glt.footprint(crs=crs)\n\n        return pol_crs.intersection(pol_glt)\n\n    def set_band_selection(self, band_selection:Optional[Union[int, Tuple[int, ...],slice]]=None):\n        \"\"\"\n        Set the band selection. Band selection is absolute w.r.t self.nc_ds['radiance']\n\n        Args:\n            band_selection (Optional[Union[int, Tuple[int, ...],slice]], optional): slicing or selection of the bands. Defaults to None.\n\n        Example:\n            &gt;&gt;&gt; emit_image.set_band_selection(slice(0, 3)) # will only load the three first bands\n            &gt;&gt;&gt; emit_image.wavelengths # will only return the wavelengths of the three first bands\n            &gt;&gt;&gt; emit_image.load() # will only load the three first bands\n        \"\"\"\n        if band_selection is None:\n            band_selection = slice(None)\n        self.band_selection = band_selection\n        self.wavelengths = self.nc_ds['sensor_band_parameters'][self.bandname_dimension][self.band_selection]\n        self.fwhm = self.nc_ds['sensor_band_parameters']['fwhm'][self.band_selection]\n\n    @ property\n    def nc_ds_obs(self, obs_file:Optional[str]=None) -&gt; netCDF4.Dataset:\n        \"\"\"\n        Loads the observation file. In this file we have information about angles (solar and viewing),\n        elevation and ilumination based on elevation and path length.\n\n        This function downloads the observation file if it does not exist from the JPL portal.\n\n        It caches the observation file in the object. (self.nc_ds_obs)\n\n        Args:\n            obs_file (Optional[str], optional): Path to the observation file. \n                Defaults to None. If none it will download the observation file \n                from the EMIT server.\n        \"\"\"\n        if self._nc_ds_obs is not None:\n            return self._nc_ds_obs\n\n        if obs_file is None:\n            link_obs_file = get_obs_link(self.filename)\n            obs_file = os.path.join(os.path.dirname(self.filename), os.path.basename(link_obs_file))\n            if not os.path.exists(obs_file):\n                download_product(link_obs_file, obs_file)\n\n        self.obs_file = obs_file\n        self._nc_ds_obs = netCDF4.Dataset(obs_file)\n        self._nc_ds_obs.set_auto_mask(False)\n        self._observation_bands = self._nc_ds_obs['sensor_band_parameters']['observation_bands'][:]\n        return self._nc_ds_obs\n\n    @property\n    def nc_ds_l2amask(self, l2amaskfile:Optional[str]=None) -&gt; netCDF4.Dataset:\n        \"\"\"\n        Loads the L2A mask file. In this file we have information about the cloud mask.\n\n        This function downloads the L2A mask file if it does not exist from the JPL portal.\n\n        It caches the L2A mask file in the object. (self.nc_ds_l2amask)\n\n        See https://lpdaac.usgs.gov/products/emitl2arflv001/ for info about the L2A mask file.\n\n        Args:\n            l2amaskfile (Optional[str], optional): Path to the L2A mask file. \n                Defaults to None. If none it will download the L2A mask file \n                from the EMIT server.\n        \"\"\"\n        if self._nc_ds_l2amask is not None:\n            return self._nc_ds_l2amask\n\n        if l2amaskfile is None:\n            link_l2amaskfile = get_l2amask_link(self.filename)\n            l2amaskfile = os.path.join(os.path.dirname(self.filename), os.path.basename(link_l2amaskfile))\n            if not os.path.exists(l2amaskfile):\n                download_product(link_l2amaskfile, l2amaskfile)\n\n        self.l2amaskfile = l2amaskfile\n        self._nc_ds_l2amask = netCDF4.Dataset(l2amaskfile)\n        self._nc_ds_l2amask.set_auto_mask(False)\n        self._mask_bands = self._nc_ds_l2amask[\"sensor_band_parameters\"][\"mask_bands\"][:]\n        return self._nc_ds_l2amask\n\n    @property\n    def mask_bands(self) -&gt; np.array:\n        \"\"\" Returns the mask bands -&gt; ['Cloud flag', 'Cirrus flag', 'Water flag', 'Spacecraft Flag',\n       'Dilated Cloud Flag', 'AOD550', 'H2O (g cm-2)', 'Aggregate Flag'] \"\"\"\n        self.nc_ds_l2amask\n        return self._mask_bands\n\n    def validmask(self, with_buffer:bool=True) -&gt; GeoTensor:\n        \"\"\"\n        Return the validmask mask\n\n\n        Returns:\n            GeoTensor: bool mask. True means that the pixel is valid.\n        \"\"\"\n\n        validmask = ~self.invalid_mask_raw(with_buffer=with_buffer)\n\n        return self.georreference(validmask,\n                                  fill_value_default=False)\n\n    def invalid_mask_raw(self, with_buffer:bool=True) -&gt; NDArray:\n        \"\"\"\n        Returns the non georreferenced quality mask. True means that the pixel is not valid.\n\n        This mask is computed as the sum of the Cloud flag, Cirrus flag, Spacecraft flag and Dilated Cloud Flag.\n        True means that the pixel is not valid.\n\n        From: https://github.com/nasa/EMIT-Data-Resources/blob/main/python/how-tos/How_to_use_EMIT_Quality_data.ipynb\n        and https://github.com/nasa/EMIT-Data-Resources/blob/main/python/modules/emit_tools.py#L277\n\n\n        \"\"\"\n        band_index =  [0,1,3]\n        if with_buffer:\n            band_index.append(4)\n\n        slice_y, slice_x = self.window_raw.toslices()\n        mask_arr = self.nc_ds_l2amask['mask'][slice_y, slice_x, band_index]\n        mask_arr = np.sum(mask_arr, axis=-1)\n        mask_arr = (mask_arr &gt;= 1)\n        return mask_arr\n\n    @property\n    def percentage_clear(self) -&gt; float:\n        \"\"\"\n        Return the percentage of clear pixels in the image\n\n        Returns:\n            float: percentage of clear pixels\n        \"\"\"\n\n        invalids = self.invalid_mask_raw(with_buffer=False)\n        return 100 * (1 - np.sum(invalids) / np.prod(invalids.shape))\n\n\n    def mask(self, mask_name:str=\"cloud_mask\") -&gt; GeoTensor:\n        \"\"\"\n        Return the mask layer with the given name.\n        Mask shall be one of self.mask_bands -&gt; ['Cloud flag', 'Cirrus flag', 'Water flag', 'Spacecraft Flag',\n       'Dilated Cloud Flag', 'AOD550', 'H2O (g cm-2)', 'Aggregate Flag']\n\n        Args:\n            mask_name (str, optional): Name of the mask. Defaults to \"cloud_mask\".\n\n        Returns:\n            GeoTensor: mask\n        \"\"\"\n        band_index = self.mask_bands.tolist().index(mask_name)\n        slice_y, slice_x = self.window_raw.toslices()\n        mask_arr = self.nc_ds_l2amask['mask'][slice_y, slice_x, band_index]\n        return self.georreference(mask_arr,\n                                  fill_value_default=self.nc_ds_l2amask['mask']._FillValue)\n\n    def water_mask(self) -&gt; GeoTensor:\n        \"\"\" Returns the water mask \"\"\"\n        return self.mask(\"Water flag\")\n\n    @property\n    def observation_bands(self) -&gt; np.array:\n        \"\"\" Returns the observation bands \"\"\"\n        self.nc_ds_obs\n        return self._observation_bands\n\n    def observation(self, name:str) -&gt; GeoTensor:\n        \"\"\" Returns the observation with the given name \"\"\"\n        band_index = self.observation_bands.tolist().index(name)\n        slice_y, slice_x = self.window_raw.toslices()\n        obs_arr = self.nc_ds_obs['obs'][slice_y, slice_x, band_index]\n        return self.georreference(obs_arr, \n                                  fill_value_default=self.nc_ds_obs['obs']._FillValue)\n\n    def sza(self) -&gt; GeoTensor:\n        \"\"\" Return the solar zenith angle as a GeoTensor \"\"\"\n        return self.observation('To-sun zenith (0 to 90 degrees from zenith)')\n\n    def vza(self) -&gt; GeoTensor:\n        \"\"\" Return the view zenith angle as a GeoTensor \"\"\"\n        return self.observation('To-sensor zenith (0 to 90 degrees from zenith)')\n\n    def elevation(self) -&gt; GeoTensor:\n        obs_arr = self.nc_ds[\"location\"][\"elev\"]\n        slice_y, slice_x = self.window_raw.toslices()\n        return self.georreference(obs_arr[slice_y, slice_x], \n                                  fill_value_default=obs_arr._FillValue)\n\n    @property\n    def mean_sza(self) -&gt; float:\n        \"\"\" Return the mean solar zenith angle \"\"\"\n        if self._mean_sza is not None:\n            return self._mean_sza\n\n        band_index = self.observation_bands.tolist().index('To-sun zenith (0 to 90 degrees from zenith)')\n        sza_arr = self.nc_ds_obs['obs'][..., band_index]\n        self._mean_sza = float(np.mean(sza_arr[sza_arr != self.nc_ds_obs['obs']._FillValue]))\n        return self._mean_sza\n\n    @property\n    def mean_vza(self) -&gt; float:\n        \"\"\" Return the mean view zenith angle \"\"\"\n        if self._mean_vza is not None:\n            return self._mean_vza\n        band_index = self.observation_bands.tolist().index('To-sensor zenith (0 to 90 degrees from zenith)')\n        vza_arr = self.nc_ds_obs['obs'][..., band_index]\n        self._mean_vza = float(np.mean(vza_arr[vza_arr != self.nc_ds_obs['obs']._FillValue]))\n        return self._mean_vza\n\n    def __copy__(self) -&gt; '__class__':\n        out = EMITImage(self.filename, glt=self.glt.copy(), band_selection=self.band_selection)\n\n        # copy nc_ds_obs if it exists\n        for attrname in self.attributes_set_if_exists:\n            if hasattr(self, attrname):\n                setattr(out, attrname, getattr(self, attrname))\n\n        return out\n    def copy(self) -&gt; '__class__':\n        return self.__copy__()\n\n    def to_crs(self, crs:Any=\"UTM\", \n               resolution_dst_crs:Optional[Union[float, Tuple[float, float]]]=60) -&gt; '__class__':\n        \"\"\"\n        Reproject the image to a new crs\n\n        Args:\n            crs (Any): CRS. \n\n        Returns:\n            EmitImage: EMIT image in the new CRS\n\n        Example:\n            &gt;&gt;&gt; emit_image = EMITImage(\"path/to/emit_image.nc\")\n            &gt;&gt;&gt; emit_image_utm = emit_image.to_crs(crs=\"UTM\")\n        \"\"\"\n        if crs == \"UTM\":\n            footprint = self.glt.footprint(\"EPSG:4326\")\n            crs = get_utm_epsg(footprint)\n\n        glt = read.read_to_crs(self.glt, crs, resampling=rasterio.warp.Resampling.nearest, \n                               resolution_dst_crs=resolution_dst_crs)\n\n        out = EMITImage(self.filename, glt=glt, band_selection=self.band_selection)\n        # Copy _pol attribute if it exists\n        if hasattr(self, '_pol'):\n            setattr(out, '_pol', window_utils.polygon_to_crs(self._pol, self.crs, crs))\n\n        return out\n\n\n    def read_from_window(self, window:Optional[rasterio.windows.Window]=None, boundless:bool=True) -&gt; '__class__':\n        glt_window = self.glt.read_from_window(window, boundless=boundless)\n        out = EMITImage(self.filename, glt=glt_window, band_selection=self.band_selection)\n\n        # copy attributes as in __copy__ method\n        for attrname in self.attributes_set_if_exists:\n            if hasattr(self, attrname):\n                setattr(out, attrname, self.nc_ds_obs)\n\n        return out\n\n    def read_from_bands(self, bands:Union[int, Tuple[int, ...], slice]) -&gt; '__class__':\n        copy = self.__copy__()\n        copy.set_band_selection(bands)\n        return copy\n\n    def load(self, boundless:bool=True, as_reflectance:bool=False)-&gt; GeoTensor:\n        data = self.load_raw() # (C, H, W) or (H, W)\n        if as_reflectance:\n            invalids = np.isnan(data) | (data == self.fill_value_default)\n            thuiller = reflectance.load_thuillier_irradiance()\n            response = reflectance.srf(self.wavelengths, self.fwhm, thuiller[\"Nanometer\"].values)\n            solar_irradiance_norm = thuiller[\"Radiance(mW/m2/nm)\"].values.dot(response) / 1_000\n            data = reflectance.radiance_to_reflectance(data, solar_irradiance_norm,\n                                                       units=self.units,\n                                                       observation_date_corr_factor=self.observation_date_correction_factor)\n            data[invalids] = self.fill_value_default\n        return self.georreference(data, fill_value_default=self.fill_value_default)\n\n    def load_rgb(self, as_reflectance:bool=True) -&gt; GeoTensor:\n        bands_read = np.argmin(np.abs(WAVELENGTHS_RGB[:, np.newaxis] - self.wavelengths), axis=1).tolist()\n        ei_rgb = self.read_from_bands(bands_read)\n        return ei_rgb.load(boundless=True, as_reflectance=as_reflectance)\n\n    @property\n    def shape_raw(self) -&gt; Tuple[int, int, int]:\n        \"\"\" Return the shape of the raw data in (C, H, W) format \"\"\"\n        return (len(self.wavelengths),) + rasterio.windows.shape(self.window_raw)\n\n    def _bounds_indexes_raw(self) -&gt; Tuple[int, int, int, int]:\n        \"\"\" Return the bounds of the raw data: (min_x, min_y, max_x, max_y) \"\"\"\n        return _bounds_indexes_raw(self.glt.values, self.valid_glt)\n\n\n    def load_raw(self, transpose:bool=True) -&gt; np.array:\n        \"\"\"\n        Load the raw data, without orthorectification\n\n        Args:\n            transpose (bool, optional): Transpose the data if it has 3 dimentsions to (C, H, W) \n                Defaults to True. if False return (H, W, C)\n\n        Returns:\n            np.array: raw data (C, H, W) or (H, W)\n        \"\"\"\n\n        slice_y, slice_x = self.window_raw.toslices()\n\n        if isinstance(self.band_selection, slice):\n            data = np.array(self.nc_ds['radiance'][slice_y, slice_x, self.band_selection])\n        else:\n            data = np.array(self.nc_ds['radiance'][slice_y, slice_x][..., self.band_selection])\n\n        # transpose to (C, H, W)\n        if transpose and (len(data.shape) == 3):\n            data = np.transpose(data, axes=(2, 0, 1))\n\n        return data\n\n\n    def georreference(self, data:np.array, \n                      fill_value_default:Optional[Union[int,float]]=None) -&gt; GeoTensor:\n        \"\"\"\n        Georreference an image in sensor coordinates to coordinates of the current \n        georreferenced object. If you do some processing with the raw data, you can \n        georreference the raw output with this function.\n\n        Args:\n            data (np.array): raw data (C, H, W) or (H, W). \n\n        Returns:\n            GeoTensor: georreferenced version of data (C, H', W') or (H', W')\n\n        Example:\n            &gt;&gt;&gt; emit_image = EMITImage(\"path/to/emit_image.nc\")\n            &gt;&gt;&gt; emit_image_rgb = emit_image.read_from_bands([35, 23, 11])\n            &gt;&gt;&gt; data_rgb = emit_image_rgb.load_raw() # (3, H, W)\n            &gt;&gt;&gt; data_rgb_ortho = emit_image.georreference(data_rgb) # (3, H', W')\n        \"\"\"\n        return georreference(self.glt_relative, data, self.valid_glt, \n                             fill_value_default=fill_value_default)\n\n\n    @property\n    def values(self) -&gt; np.array:\n        # return np.zeros(self.shape, dtype=self.dtype)\n        raise self.load(boundless=True).values\n\n    def __repr__(self)-&gt;str:\n        return f\"\"\" \n         File: {self.filename}\n         Transform: {self.transform}\n         Shape: {self.shape}\n         Resolution: {self.res}\n         Bounds: {self.bounds}\n         CRS: {self.crs}\n         units: {self.units}\n        \"\"\"\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.mask_bands","title":"<code>mask_bands: np.array</code>  <code>property</code>","text":"<p>Returns the mask bands -&gt; ['Cloud flag', 'Cirrus flag', 'Water flag', 'Spacecraft Flag', 'Dilated Cloud Flag', 'AOD550', 'H2O (g cm-2)', 'Aggregate Flag']</p>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.mean_sza","title":"<code>mean_sza: float</code>  <code>property</code>","text":"<p>Return the mean solar zenith angle</p>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.mean_vza","title":"<code>mean_vza: float</code>  <code>property</code>","text":"<p>Return the mean view zenith angle</p>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.nc_ds_l2amask","title":"<code>nc_ds_l2amask: netCDF4.Dataset</code>  <code>property</code>","text":"<p>Loads the L2A mask file. In this file we have information about the cloud mask.</p> <p>This function downloads the L2A mask file if it does not exist from the JPL portal.</p> <p>It caches the L2A mask file in the object. (self.nc_ds_l2amask)</p> <p>See https://lpdaac.usgs.gov/products/emitl2arflv001/ for info about the L2A mask file.</p> <p>Parameters:</p> Name Type Description Default <code>l2amaskfile</code> <code>Optional[str]</code> <p>Path to the L2A mask file.  Defaults to None. If none it will download the L2A mask file  from the EMIT server.</p> required"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.nc_ds_obs","title":"<code>nc_ds_obs: netCDF4.Dataset</code>  <code>property</code>","text":"<p>Loads the observation file. In this file we have information about angles (solar and viewing), elevation and ilumination based on elevation and path length.</p> <p>This function downloads the observation file if it does not exist from the JPL portal.</p> <p>It caches the observation file in the object. (self.nc_ds_obs)</p> <p>Parameters:</p> Name Type Description Default <code>obs_file</code> <code>Optional[str]</code> <p>Path to the observation file.  Defaults to None. If none it will download the observation file  from the EMIT server.</p> required"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.observation_bands","title":"<code>observation_bands: np.array</code>  <code>property</code>","text":"<p>Returns the observation bands</p>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.percentage_clear","title":"<code>percentage_clear: float</code>  <code>property</code>","text":"<p>Return the percentage of clear pixels in the image</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>percentage of clear pixels</p>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.shape_raw","title":"<code>shape_raw: Tuple[int, int, int]</code>  <code>property</code>","text":"<p>Return the shape of the raw data in (C, H, W) format</p>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.footprint","title":"<code>footprint(crs=None)</code>","text":"<p>Get the footprint of the image in the given CRS. If no CRS is given, the footprint is returned in the native CRS. This function takes into account the valid_glt mask to compute the footprint.</p> <p>Parameters:</p> Name Type Description Default <code>crs</code> <code>Optional[str]</code> <p>The CRS to return the footprint in. Defaults to None.  If None, the footprint is returned in the native CRS.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Polygon</code> <code>Polygon</code> <p>The footprint of the image in the given CRS.</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def footprint(self, crs:Optional[str]=None) -&gt; Polygon:\n    \"\"\"\n    Get the footprint of the image in the given CRS. If no CRS is given, the footprint is returned in the native CRS.\n    This function takes into account the valid_glt mask to compute the footprint.\n\n    Args:\n        crs (Optional[str], optional): The CRS to return the footprint in. Defaults to None. \n            If None, the footprint is returned in the native CRS.\n\n    Returns:\n        Polygon: The footprint of the image in the given CRS.\n    \"\"\"\n    if not hasattr(self, '_pol'):\n        from georeader.vectorize import get_polygons\n        pols = get_polygons(self.valid_glt, transform=self.transform)\n        self._pol = unary_union(pols)\n    if crs is not None:\n        pol_crs = window_utils.polygon_to_crs(self._pol, self.crs, crs)\n    else:\n        pol_crs = self._pol\n\n    pol_glt = self.glt.footprint(crs=crs)\n\n    return pol_crs.intersection(pol_glt)\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.georreference","title":"<code>georreference(data, fill_value_default=None)</code>","text":"<p>Georreference an image in sensor coordinates to coordinates of the current  georreferenced object. If you do some processing with the raw data, you can  georreference the raw output with this function.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array</code> <p>raw data (C, H, W) or (H, W). </p> required <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>GeoTensor</code> <p>georreferenced version of data (C, H', W') or (H', W')</p> Example <p>emit_image = EMITImage(\"path/to/emit_image.nc\") emit_image_rgb = emit_image.read_from_bands([35, 23, 11]) data_rgb = emit_image_rgb.load_raw() # (3, H, W) data_rgb_ortho = emit_image.georreference(data_rgb) # (3, H', W')</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def georreference(self, data:np.array, \n                  fill_value_default:Optional[Union[int,float]]=None) -&gt; GeoTensor:\n    \"\"\"\n    Georreference an image in sensor coordinates to coordinates of the current \n    georreferenced object. If you do some processing with the raw data, you can \n    georreference the raw output with this function.\n\n    Args:\n        data (np.array): raw data (C, H, W) or (H, W). \n\n    Returns:\n        GeoTensor: georreferenced version of data (C, H', W') or (H', W')\n\n    Example:\n        &gt;&gt;&gt; emit_image = EMITImage(\"path/to/emit_image.nc\")\n        &gt;&gt;&gt; emit_image_rgb = emit_image.read_from_bands([35, 23, 11])\n        &gt;&gt;&gt; data_rgb = emit_image_rgb.load_raw() # (3, H, W)\n        &gt;&gt;&gt; data_rgb_ortho = emit_image.georreference(data_rgb) # (3, H', W')\n    \"\"\"\n    return georreference(self.glt_relative, data, self.valid_glt, \n                         fill_value_default=fill_value_default)\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.invalid_mask_raw","title":"<code>invalid_mask_raw(with_buffer=True)</code>","text":"<p>Returns the non georreferenced quality mask. True means that the pixel is not valid.</p> <p>This mask is computed as the sum of the Cloud flag, Cirrus flag, Spacecraft flag and Dilated Cloud Flag. True means that the pixel is not valid.</p> <p>From: https://github.com/nasa/EMIT-Data-Resources/blob/main/python/how-tos/How_to_use_EMIT_Quality_data.ipynb and https://github.com/nasa/EMIT-Data-Resources/blob/main/python/modules/emit_tools.py#L277</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def invalid_mask_raw(self, with_buffer:bool=True) -&gt; NDArray:\n    \"\"\"\n    Returns the non georreferenced quality mask. True means that the pixel is not valid.\n\n    This mask is computed as the sum of the Cloud flag, Cirrus flag, Spacecraft flag and Dilated Cloud Flag.\n    True means that the pixel is not valid.\n\n    From: https://github.com/nasa/EMIT-Data-Resources/blob/main/python/how-tos/How_to_use_EMIT_Quality_data.ipynb\n    and https://github.com/nasa/EMIT-Data-Resources/blob/main/python/modules/emit_tools.py#L277\n\n\n    \"\"\"\n    band_index =  [0,1,3]\n    if with_buffer:\n        band_index.append(4)\n\n    slice_y, slice_x = self.window_raw.toslices()\n    mask_arr = self.nc_ds_l2amask['mask'][slice_y, slice_x, band_index]\n    mask_arr = np.sum(mask_arr, axis=-1)\n    mask_arr = (mask_arr &gt;= 1)\n    return mask_arr\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.load_raw","title":"<code>load_raw(transpose=True)</code>","text":"<p>Load the raw data, without orthorectification</p> <p>Parameters:</p> Name Type Description Default <code>transpose</code> <code>bool</code> <p>Transpose the data if it has 3 dimentsions to (C, H, W)  Defaults to True. if False return (H, W, C)</p> <code>True</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array: raw data (C, H, W) or (H, W)</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def load_raw(self, transpose:bool=True) -&gt; np.array:\n    \"\"\"\n    Load the raw data, without orthorectification\n\n    Args:\n        transpose (bool, optional): Transpose the data if it has 3 dimentsions to (C, H, W) \n            Defaults to True. if False return (H, W, C)\n\n    Returns:\n        np.array: raw data (C, H, W) or (H, W)\n    \"\"\"\n\n    slice_y, slice_x = self.window_raw.toslices()\n\n    if isinstance(self.band_selection, slice):\n        data = np.array(self.nc_ds['radiance'][slice_y, slice_x, self.band_selection])\n    else:\n        data = np.array(self.nc_ds['radiance'][slice_y, slice_x][..., self.band_selection])\n\n    # transpose to (C, H, W)\n    if transpose and (len(data.shape) == 3):\n        data = np.transpose(data, axes=(2, 0, 1))\n\n    return data\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.mask","title":"<code>mask(mask_name='cloud_mask')</code>","text":"<p>Return the mask layer with the given name.  Mask shall be one of self.mask_bands -&gt; ['Cloud flag', 'Cirrus flag', 'Water flag', 'Spacecraft Flag', 'Dilated Cloud Flag', 'AOD550', 'H2O (g cm-2)', 'Aggregate Flag']</p> <p>Args:      mask_name (str, optional): Name of the mask. Defaults to \"cloud_mask\".</p> <p>Returns:      GeoTensor: mask</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def mask(self, mask_name:str=\"cloud_mask\") -&gt; GeoTensor:\n    \"\"\"\n    Return the mask layer with the given name.\n    Mask shall be one of self.mask_bands -&gt; ['Cloud flag', 'Cirrus flag', 'Water flag', 'Spacecraft Flag',\n   'Dilated Cloud Flag', 'AOD550', 'H2O (g cm-2)', 'Aggregate Flag']\n\n    Args:\n        mask_name (str, optional): Name of the mask. Defaults to \"cloud_mask\".\n\n    Returns:\n        GeoTensor: mask\n    \"\"\"\n    band_index = self.mask_bands.tolist().index(mask_name)\n    slice_y, slice_x = self.window_raw.toslices()\n    mask_arr = self.nc_ds_l2amask['mask'][slice_y, slice_x, band_index]\n    return self.georreference(mask_arr,\n                              fill_value_default=self.nc_ds_l2amask['mask']._FillValue)\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.observation","title":"<code>observation(name)</code>","text":"<p>Returns the observation with the given name</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def observation(self, name:str) -&gt; GeoTensor:\n    \"\"\" Returns the observation with the given name \"\"\"\n    band_index = self.observation_bands.tolist().index(name)\n    slice_y, slice_x = self.window_raw.toslices()\n    obs_arr = self.nc_ds_obs['obs'][slice_y, slice_x, band_index]\n    return self.georreference(obs_arr, \n                              fill_value_default=self.nc_ds_obs['obs']._FillValue)\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.set_band_selection","title":"<code>set_band_selection(band_selection=None)</code>","text":"<p>Set the band selection. Band selection is absolute w.r.t self.nc_ds['radiance']</p> <p>Parameters:</p> Name Type Description Default <code>band_selection</code> <code>Optional[Union[int, Tuple[int, ...], slice]]</code> <p>slicing or selection of the bands. Defaults to None.</p> <code>None</code> Example <p>emit_image.set_band_selection(slice(0, 3)) # will only load the three first bands emit_image.wavelengths # will only return the wavelengths of the three first bands emit_image.load() # will only load the three first bands</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def set_band_selection(self, band_selection:Optional[Union[int, Tuple[int, ...],slice]]=None):\n    \"\"\"\n    Set the band selection. Band selection is absolute w.r.t self.nc_ds['radiance']\n\n    Args:\n        band_selection (Optional[Union[int, Tuple[int, ...],slice]], optional): slicing or selection of the bands. Defaults to None.\n\n    Example:\n        &gt;&gt;&gt; emit_image.set_band_selection(slice(0, 3)) # will only load the three first bands\n        &gt;&gt;&gt; emit_image.wavelengths # will only return the wavelengths of the three first bands\n        &gt;&gt;&gt; emit_image.load() # will only load the three first bands\n    \"\"\"\n    if band_selection is None:\n        band_selection = slice(None)\n    self.band_selection = band_selection\n    self.wavelengths = self.nc_ds['sensor_band_parameters'][self.bandname_dimension][self.band_selection]\n    self.fwhm = self.nc_ds['sensor_band_parameters']['fwhm'][self.band_selection]\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.sza","title":"<code>sza()</code>","text":"<p>Return the solar zenith angle as a GeoTensor</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def sza(self) -&gt; GeoTensor:\n    \"\"\" Return the solar zenith angle as a GeoTensor \"\"\"\n    return self.observation('To-sun zenith (0 to 90 degrees from zenith)')\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.to_crs","title":"<code>to_crs(crs='UTM', resolution_dst_crs=60)</code>","text":"<p>Reproject the image to a new crs</p> <p>Parameters:</p> Name Type Description Default <code>crs</code> <code>Any</code> <p>CRS. </p> <code>'UTM'</code> <p>Returns:</p> Name Type Description <code>EmitImage</code> <code>__class__</code> <p>EMIT image in the new CRS</p> Example <p>emit_image = EMITImage(\"path/to/emit_image.nc\") emit_image_utm = emit_image.to_crs(crs=\"UTM\")</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def to_crs(self, crs:Any=\"UTM\", \n           resolution_dst_crs:Optional[Union[float, Tuple[float, float]]]=60) -&gt; '__class__':\n    \"\"\"\n    Reproject the image to a new crs\n\n    Args:\n        crs (Any): CRS. \n\n    Returns:\n        EmitImage: EMIT image in the new CRS\n\n    Example:\n        &gt;&gt;&gt; emit_image = EMITImage(\"path/to/emit_image.nc\")\n        &gt;&gt;&gt; emit_image_utm = emit_image.to_crs(crs=\"UTM\")\n    \"\"\"\n    if crs == \"UTM\":\n        footprint = self.glt.footprint(\"EPSG:4326\")\n        crs = get_utm_epsg(footprint)\n\n    glt = read.read_to_crs(self.glt, crs, resampling=rasterio.warp.Resampling.nearest, \n                           resolution_dst_crs=resolution_dst_crs)\n\n    out = EMITImage(self.filename, glt=glt, band_selection=self.band_selection)\n    # Copy _pol attribute if it exists\n    if hasattr(self, '_pol'):\n        setattr(out, '_pol', window_utils.polygon_to_crs(self._pol, self.crs, crs))\n\n    return out\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.validmask","title":"<code>validmask(with_buffer=True)</code>","text":"<p>Return the validmask mask</p> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>GeoTensor</code> <p>bool mask. True means that the pixel is valid.</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def validmask(self, with_buffer:bool=True) -&gt; GeoTensor:\n    \"\"\"\n    Return the validmask mask\n\n\n    Returns:\n        GeoTensor: bool mask. True means that the pixel is valid.\n    \"\"\"\n\n    validmask = ~self.invalid_mask_raw(with_buffer=with_buffer)\n\n    return self.georreference(validmask,\n                              fill_value_default=False)\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.vza","title":"<code>vza()</code>","text":"<p>Return the view zenith angle as a GeoTensor</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def vza(self) -&gt; GeoTensor:\n    \"\"\" Return the view zenith angle as a GeoTensor \"\"\"\n    return self.observation('To-sensor zenith (0 to 90 degrees from zenith)')\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.EMITImage.water_mask","title":"<code>water_mask()</code>","text":"<p>Returns the water mask</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def water_mask(self) -&gt; GeoTensor:\n    \"\"\" Returns the water mask \"\"\"\n    return self.mask(\"Water flag\")\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.download_product","title":"<code>download_product(link_down, filename=None, display_progress_bar=True, auth=None)</code>","text":"<p>Download a product from the EMIT website (https://search.earthdata.nasa.gov/search).  It requires that you have an account in the NASA Earthdata portal. </p> <p>This code is based on this example: https://git.earthdata.nasa.gov/projects/LPDUR/repos/daac_data_download_python/browse</p> <p>Parameters:</p> Name Type Description Default <code>link_down</code> <code>str</code> <p>link to the product</p> required <code>filename</code> <code>Optional[str]</code> <p>filename to save the product</p> <code>None</code> <code>display_progress_bar</code> <code>bool</code> <p>display tqdm progress bar</p> <code>True</code> <code>auth</code> <code>Optional[Tuple[str, str]]</code> <p>tuple with user and password to download the product. If None, it will try to read the user and password from ~/.georeader/auth_emit.json </p> <code>None</code> Example <p>link_down = 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/EMIT_L1B_RAD_001_20220828T051941_2224004_006/EMIT_L1B_RAD_001_20220828T051941_2224004_006.nc' filename = download_product(link_down)</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def download_product(link_down:str, filename:Optional[str]=None,\n                     display_progress_bar:bool=True,\n                     auth:Optional[Tuple[str, str]] = None) -&gt; str:\n    \"\"\"\n    Download a product from the EMIT website (https://search.earthdata.nasa.gov/search). \n    It requires that you have an account in the NASA Earthdata portal. \n\n    This code is based on this example: https://git.earthdata.nasa.gov/projects/LPDUR/repos/daac_data_download_python/browse\n\n    Args:\n        link_down: link to the product\n        filename: filename to save the product\n        display_progress_bar: display tqdm progress bar\n        auth: tuple with user and password to download the product. If None, it will try to read the user and password from ~/.georeader/auth_emit.json \n\n    Example:\n        &gt;&gt;&gt; link_down = 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/EMIT_L1B_RAD_001_20220828T051941_2224004_006/EMIT_L1B_RAD_001_20220828T051941_2224004_006.nc'\n        &gt;&gt;&gt; filename = download_product(link_down)\n    \"\"\"\n    headers = None\n    if auth is None:\n        if AUTH_METHOD == \"auth\":\n            auth = get_auth()\n        elif AUTH_METHOD == \"token\":\n            assert TOKEN is not None, \"You need to set the TOKEN variable to download EMIT images\"\n            headers = get_headers()\n\n    return download_product_base(link_down, filename=filename, auth=auth,\n                                 headers=headers,\n                                 display_progress_bar=display_progress_bar, \n                                 verify=False)\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.get_radiance_link","title":"<code>get_radiance_link(product_path)</code>","text":"<p>Get the link to download a product from the EMIT website. See: https://git.earthdata.nasa.gov/projects/LPDUR/repos/daac_data_download_python/browse</p> <p>Parameters:</p> Name Type Description Default <code>product_path</code> <code>str</code> <p>path to the product or filename of the product or product name with or without extension. e.g. 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'</p> required Example <p>product_path = 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc' link = get_radiance_link(product_path) 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/EMIT_L1B_RAD_001_20220827T060753_2223904_013/EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def get_radiance_link(product_path:str) -&gt; str:\n    \"\"\"\n    Get the link to download a product from the EMIT website.\n    See: https://git.earthdata.nasa.gov/projects/LPDUR/repos/daac_data_download_python/browse\n\n    Args:\n        product_path: path to the product or filename of the product or product name with or without extension.\n            e.g. 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n\n    Example:\n        &gt;&gt;&gt; product_path = 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n        &gt;&gt;&gt; link = get_radiance_link(product_path)\n        'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/EMIT_L1B_RAD_001_20220827T060753_2223904_013/EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n    \"\"\"\n    \"EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc\"\n    namefile = os.path.splitext(os.path.basename(product_path))[0]\n    product_id = os.path.splitext(namefile)[0]\n    content_id = product_id.split(\"_\")\n    content_id[1] = \"L1B\"\n    content_id[2] = \"RAD\"\n    content_id[3] = content_id[3].replace(\"V\", \"\")\n    product_id = \"_\".join(content_id)\n    link = f\"https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/{product_id}/{product_id}.nc\"\n    return link\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.get_obs_link","title":"<code>get_obs_link(product_path)</code>","text":"<p>Get the link to download a product from the EMIT website. See: https://git.earthdata.nasa.gov/projects/LPDUR/repos/daac_data_download_python/browse</p> <p>Parameters:</p> Name Type Description Default <code>product_path</code> <code>str</code> <p>path to the product or filename of the product with or without extension. e.g. 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'</p> required Example <p>product_path = 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc' link = get_radiance_link(product_path) 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/EMIT_L1B_RAD_001_20220827T060753_2223904_013/EMIT_L1B_OBS_001_20220827T060753_2223904_013.nc'</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def get_obs_link(product_path:str) -&gt; str:\n    \"\"\"\n    Get the link to download a product from the EMIT website.\n    See: https://git.earthdata.nasa.gov/projects/LPDUR/repos/daac_data_download_python/browse\n\n    Args:\n        product_path: path to the product or filename of the product with or without extension.\n            e.g. 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n\n    Example:\n        &gt;&gt;&gt; product_path = 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n        &gt;&gt;&gt; link = get_radiance_link(product_path)\n        'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/EMIT_L1B_RAD_001_20220827T060753_2223904_013/EMIT_L1B_OBS_001_20220827T060753_2223904_013.nc'\n    \"\"\"\n    namefile = os.path.splitext(os.path.basename(product_path))[0]\n\n    product_id = os.path.splitext(namefile)[0]\n    content_id = product_id.split(\"_\")\n    content_id[1] = \"L1B\"\n    content_id[2] = \"RAD\"\n    content_id[3] = content_id[3].replace(\"V\", \"\")\n    product_id = \"_\".join(content_id)\n\n    content_id[2] = \"OBS\"\n    namefile = \"_\".join(content_id)\n\n    link = f\"https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL1BRAD.001/{product_id}/{namefile}.nc\"\n    return link\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.get_ch4enhancement_link","title":"<code>get_ch4enhancement_link(tile)</code>","text":"<p>Get the link to download a product from the EMIT website. See: https://git.earthdata.nasa.gov/projects/LPDUR/repos/daac_data_download_python/browse</p> <p>Parameters:</p> Name Type Description Default <code>product_path</code> <p>path to the product or filename of the product with or without extension. e.g. 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'</p> required Example <p>product_path = 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc' link = get_radiance_link(product_path) 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL2BCH4ENH.001/EMIT_L2B_CH4ENH_001_20220810T064957_2222205_033/EMIT_L2B_CH4ENH_001_20220810T064957_2222205_033.tif'</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def get_ch4enhancement_link(tile:str) -&gt; str:\n    \"\"\"\n    Get the link to download a product from the EMIT website.\n    See: https://git.earthdata.nasa.gov/projects/LPDUR/repos/daac_data_download_python/browse\n\n    Args:\n        product_path: path to the product or filename of the product with or without extension.\n            e.g. 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n\n    Example:\n        &gt;&gt;&gt; product_path = 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n        &gt;&gt;&gt; link = get_radiance_link(product_path)\n        'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL2BCH4ENH.001/EMIT_L2B_CH4ENH_001_20220810T064957_2222205_033/EMIT_L2B_CH4ENH_001_20220810T064957_2222205_033.tif'\n    \"\"\"\n    namefile = os.path.splitext(os.path.basename(tile))[0]\n\n    product_id = os.path.splitext(namefile)[0]\n    content_id = product_id.split(\"_\")\n    content_id[1] = \"L2B\"\n    content_id[2] = \"CH4ENH\"\n    content_id[3] = content_id[3].replace(\"V\", \"\")\n    product_id = \"_\".join(content_id)\n    link = f\"https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL2BCH4ENH.001/{product_id}/{product_id}.tif\"\n    return link\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.get_l2amask_link","title":"<code>get_l2amask_link(tile)</code>","text":"<p>Get the link to download a product from the EMIT website (https://search.earthdata.nasa.gov/search)</p> <p>Parameters:</p> Name Type Description Default <code>tile</code> <code>str</code> <p>path to the product or filename of the L1B product with or without extension. e.g. 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>link to the L2A mask product</p> Example <p>tile = 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc' link = get_l2amask_link(tile) 'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL2ARFL.001/EMIT_L2A_RFL_001_20220827T060753_2223904_013/EMIT_L2A_MASK_001_20220827T060753_2223904_013.nc'</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def get_l2amask_link(tile: str) -&gt; str:\n    \"\"\"\n    Get the link to download a product from the EMIT website (https://search.earthdata.nasa.gov/search)\n\n    Args:\n        tile (str): path to the product or filename of the L1B product with or without extension.\n            e.g. 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n\n    Returns:\n        str: link to the L2A mask product\n\n    Example:\n        &gt;&gt;&gt; tile = 'EMIT_L1B_RAD_001_20220827T060753_2223904_013.nc'\n        &gt;&gt;&gt; link = get_l2amask_link(tile)\n        'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL2ARFL.001/EMIT_L2A_RFL_001_20220827T060753_2223904_013/EMIT_L2A_MASK_001_20220827T060753_2223904_013.nc'\n    \"\"\"\n    namefile = os.path.splitext(os.path.basename(tile))[0]\n    namefile = namefile + \".nc\"\n\n    product_id = os.path.splitext(namefile)[0]\n    content_id = product_id.split(\"_\")\n    content_id[1] = \"L2A\"\n    content_id[2] = \"RFL\"\n    content_id[3] = content_id[3].replace(\"V\", \"\")\n    product_id = \"_\".join(content_id)\n\n    content_id[2] = \"MASK\"\n    namefilenew = \"_\".join(content_id) + \".nc\"\n    link = f\"https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-protected/EMITL2ARFL.001/{product_id}/{namefilenew}\"\n    return link\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.emit.valid_mask","title":"<code>valid_mask(filename, with_buffer=False, dst_crs='UTM', resolution_dst_crs=60)</code>","text":"<p>Loads the valid mask from the EMIT L2AMASK file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path to the L2AMASK file. e.g. EMIT_L2A_MASK_001_20220827T060753_2223904_013.nc</p> required <code>with_buffer</code> <code>bool</code> <p>If True, the buffer band is used to compute the valid mask. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>GeoTensor</code> <code>Tuple[GeoTensor, float]</code> <p>valid mask</p> Source code in <code>georeader/readers/emit.py</code> <pre><code>def valid_mask(filename:str, with_buffer:bool=False, \n               dst_crs:Optional[Any]=\"UTM\", \n               resolution_dst_crs:Optional[Union[float, Tuple[float, float]]]=60) -&gt; Tuple[GeoTensor, float]:\n    \"\"\"\n    Loads the valid mask from the EMIT L2AMASK file.\n\n    Args:\n        filename (str): path to the L2AMASK file. e.g. EMIT_L2A_MASK_001_20220827T060753_2223904_013.nc\n        with_buffer (bool, optional): If True, the buffer band is used to compute the valid mask. Defaults to False.\n\n    Returns:\n        GeoTensor: valid mask\n    \"\"\"\n\n    nc_ds = netCDF4.Dataset(filename, 'r', format='NETCDF4')\n    nc_ds.set_auto_mask(False)\n\n    real_transform = rasterio.Affine(nc_ds.geotransform[1], nc_ds.geotransform[2], nc_ds.geotransform[0],\n                                     nc_ds.geotransform[4], nc_ds.geotransform[5], nc_ds.geotransform[3])\n\n    glt_arr = np.zeros((2,) + nc_ds.groups['location']['glt_x'].shape, dtype=np.int32)\n    glt_arr[0] = np.array(nc_ds.groups['location']['glt_x'])\n    glt_arr[1] = np.array(nc_ds.groups['location']['glt_y'])\n    # glt_arr -= 1 # account for 1-based indexing\n\n    # https://rasterio.readthedocs.io/en/stable/api/rasterio.crs.html\n    glt = GeoTensor(glt_arr, transform=real_transform, \n                    crs=rasterio.crs.CRS.from_wkt(nc_ds.spatial_ref),\n                    fill_value_default=0)\n\n    if dst_crs is not None:\n        if dst_crs == \"UTM\":\n            footprint = glt.footprint(\"EPSG:4326\")\n            dst_crs = get_utm_epsg(footprint)\n\n        glt = read.read_to_crs(glt, dst_crs=dst_crs, \n                               resampling=rasterio.warp.Resampling.nearest, \n                               resolution_dst_crs=resolution_dst_crs)\n\n    valid_glt = np.all(glt.values != glt.fill_value_default, axis=0)\n    xmin = np.min(glt.values[0, valid_glt])\n    ymin = np.min(glt.values[1, valid_glt])\n\n    glt_relative = glt.copy()\n    glt_relative.values[0, valid_glt] -= xmin\n    glt_relative.values[1, valid_glt] -= ymin\n    # mask_bands = nc_ds[\"sensor_band_parameters\"][\"mask_bands\"][:]\n\n    band_index =  [0,1,3]\n    if with_buffer:\n        band_index.append(4)\n\n    mask_arr = nc_ds['mask'][:, :, band_index]\n    invalidmask_raw = np.sum(mask_arr, axis=-1)\n    invalidmask_raw = (invalidmask_raw &gt;= 1)\n\n    validmask = ~invalidmask_raw\n\n    percentage_clear = 100 * (np.sum(validmask) / np.prod(validmask.shape))\n\n    return georreference(glt_relative, validmask, valid_glt,\n                         fill_value_default=False), percentage_clear\n</code></pre>"},{"location":"modules/readers_module/#enmap-reader","title":"EnMAP Reader","text":"<p>The EnMAP (Environmental Mapping and Analysis Program) reader processes data from the German hyperspectral satellite mission. This reader works with Level 1B radiometrically calibrated data (not atmospherically corrected) that contains radiance values in physical units.</p> <p>Key features:</p> <ul> <li>Reading L1B hyperspectral radiance data from GeoTIFF format with accompanying XML metadata</li> <li>Working with separate VNIR (420-1000 nm) and SWIR (900-2450 nm) spectral ranges</li> <li>Support for 228 spectral channels with 6.5 nm (VNIR) and 10 nm (SWIR) sampling</li> <li>Integration with Rational Polynomial Coefficients (RPCs) for accurate geometric correction</li> <li>Conversion from radiance (mW/m\u00b2/sr/nm) to top-of-atmosphere reflectance</li> <li>Access to solar illumination and viewing geometry for radiometric calculations</li> <li>Support for quality masks</li> </ul> <p>Tutorial example:</p> <ul> <li>Working with EnMAP and CloudSEN12</li> </ul>"},{"location":"modules/readers_module/#api-reference_5","title":"API Reference","text":""},{"location":"modules/readers_module/#georeader.readers.enmap.EnMAP","title":"<code>EnMAP</code>","text":"<p>EnMAP (Environmental Mapping and Analysis Program) image reader.</p> <p>This class provides functionality to read and manipulate EnMAP satellite imagery products. It handles the specific format and metadata of EnMAP files, supporting operations like loading specific wavelengths, RGB composites, and converting to reflectance.</p> <p>Parameters:</p> Name Type Description Default <code>xml_file</code> <code>str</code> <p>Path to the EnMAP XML metadata file.</p> required <code>by_folder</code> <code>bool</code> <p>If True, files are organized by folder structure. Defaults to False.</p> <code>False</code> <code>window_focus</code> <code>Optional[Window]</code> <p>Window to focus on a specific region of the image. Defaults to None (entire image).</p> <code>None</code> <code>fs</code> <code>Optional[AbstractFileSystem]</code> <p>Filesystem to use for file access. Defaults to None (local filesystem).</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>xml_file</code> <code>str</code> <p>Path to the XML metadata file.</p> <code>by_folder</code> <code>bool</code> <p>Whether files are organized by folder structure.</p> <code>swir_file</code> <code>str</code> <p>Path to the SWIR image file.</p> <code>fs</code> <code>AbstractFileSystem</code> <p>Filesystem used for file access.</p> <code>swir</code> <code>RasterioReader</code> <p>Reader for SWIR image.</p> <code>vnir</code> <code>RasterioReader</code> <p>Reader for VNIR image.</p> <code>wl_center</code> <code>Dict</code> <p>Dictionary of center wavelengths for each band.</p> <code>wl_fwhm</code> <code>Dict</code> <p>Dictionary of FWHM (Full Width at Half Maximum) for each band.</p> <code>hsf</code> <code>float</code> <p>Mean ground elevation.</p> <code>sza</code> <code>float</code> <p>Solar zenith angle.</p> <code>saa</code> <code>float</code> <p>Solar azimuth angle.</p> <code>vaa</code> <code>float</code> <p>Viewing azimuth angle.</p> <code>vza</code> <code>float</code> <p>Viewing zenith angle.</p> <code>gain_arr</code> <code>Dict</code> <p>Dictionary of gain values for each band.</p> <code>offs_arr</code> <code>Dict</code> <p>Dictionary of offset values for each band.</p> <code>rpcs_vnir</code> <code>Dict</code> <p>Rational Polynomial Coefficients for VNIR.</p> <code>rpcs_swir</code> <code>Dict</code> <p>Rational Polynomial Coefficients for SWIR.</p> <code>swir_range</code> <code>Tuple[float, float]</code> <p>Wavelength range of SWIR bands.</p> <code>vnir_range</code> <code>Tuple[float, float]</code> <p>Wavelength range of VNIR bands.</p> <code>units</code> <code>str</code> <p>Units of radiance data (mW/m2/sr/nm).</p> <code>time_coverage_start</code> <code>datetime</code> <p>Start time of acquisition.</p> <code>time_coverage_end</code> <code>datetime</code> <p>End time of acquisition.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Initialize the EnMAP reader with a data path\n&gt;&gt;&gt; enmap = EnMAP('/path/to/enmap_metadata.xml')\n&gt;&gt;&gt; # Load RGB bands as reflectance with RPCs applied\n&gt;&gt;&gt; rgb = enmap.load_rgb(as_reflectance=True, apply_rpcs=True)\n&gt;&gt;&gt; # Load specific wavelengths\n&gt;&gt;&gt; bands = enmap.load_wavelengths([850, 1600, 2200], as_reflectance=True)\n&gt;&gt;&gt; # Load cloud mask or other quality products\n&gt;&gt;&gt; clouds = enmap.load_product('QL_QUALITY_CLOUD')\n</code></pre> Source code in <code>georeader/readers/enmap.py</code> <pre><code>class EnMAP:\n    \"\"\"\n    EnMAP (Environmental Mapping and Analysis Program) image reader.\n\n    This class provides functionality to read and manipulate EnMAP satellite imagery products.\n    It handles the specific format and metadata of EnMAP files, supporting operations\n    like loading specific wavelengths, RGB composites, and converting to reflectance.\n\n    Args:\n        xml_file (str): Path to the EnMAP XML metadata file.\n        by_folder (bool): If True, files are organized by folder structure.\n            Defaults to False.\n        window_focus (Optional[Window]): Window to focus on a specific\n            region of the image. Defaults to None (entire image).\n        fs (Optional[fsspec.AbstractFileSystem]): Filesystem to use for file access.\n            Defaults to None (local filesystem).\n\n    Attributes:\n        xml_file (str): Path to the XML metadata file.\n        by_folder (bool): Whether files are organized by folder structure.\n        swir_file (str): Path to the SWIR image file.\n        fs (fsspec.AbstractFileSystem): Filesystem used for file access.\n        swir (RasterioReader): Reader for SWIR image.\n        vnir (RasterioReader): Reader for VNIR image.\n        wl_center (Dict): Dictionary of center wavelengths for each band.\n        wl_fwhm (Dict): Dictionary of FWHM (Full Width at Half Maximum) for each band.\n        hsf (float): Mean ground elevation.\n        sza (float): Solar zenith angle.\n        saa (float): Solar azimuth angle.\n        vaa (float): Viewing azimuth angle.\n        vza (float): Viewing zenith angle.\n        gain_arr (Dict): Dictionary of gain values for each band.\n        offs_arr (Dict): Dictionary of offset values for each band.\n        rpcs_vnir: Rational Polynomial Coefficients for VNIR.\n        rpcs_swir: Rational Polynomial Coefficients for SWIR.\n        swir_range (Tuple[float, float]): Wavelength range of SWIR bands.\n        vnir_range (Tuple[float, float]): Wavelength range of VNIR bands.\n        units (str): Units of radiance data (mW/m2/sr/nm).\n        time_coverage_start (datetime): Start time of acquisition.\n        time_coverage_end (datetime): End time of acquisition.\n\n    Examples:\n        &gt;&gt;&gt; # Initialize the EnMAP reader with a data path\n        &gt;&gt;&gt; enmap = EnMAP('/path/to/enmap_metadata.xml')\n        &gt;&gt;&gt; # Load RGB bands as reflectance with RPCs applied\n        &gt;&gt;&gt; rgb = enmap.load_rgb(as_reflectance=True, apply_rpcs=True)\n        &gt;&gt;&gt; # Load specific wavelengths\n        &gt;&gt;&gt; bands = enmap.load_wavelengths([850, 1600, 2200], as_reflectance=True)\n        &gt;&gt;&gt; # Load cloud mask or other quality products\n        &gt;&gt;&gt; clouds = enmap.load_product('QL_QUALITY_CLOUD')\n    \"\"\"\n\n    def __init__(\n        self,\n        xml_file: str,\n        by_folder: bool = False,\n        window_focus: Optional[Window] = None,\n        fs: Optional[fsspec.AbstractFileSystem] = None,\n    ) -&gt; None:\n        self.xml_file = xml_file\n        self.by_folder = by_folder\n        if not self.xml_file.endswith(\".xml\") and not self.xml_file.endswith(\".XML\"):\n            raise ValueError(\n                f\"Invalid SWIR file path {self.xml_file} must be a XML file\"\n            )\n\n        if self.by_folder:\n            assert (\n                PRODUCT_FOLDERS[\"METADATA\"] in self.xml_file\n            ), f\"Invalid SWIR file path {self.xml_file} must contain {PRODUCT_FOLDERS['METADATA']} if by folder\"\n            self.swir_file = (\n                self.xml_file.replace(\n                    PRODUCT_FOLDERS[\"METADATA\"], PRODUCT_FOLDERS[\"SPECTRAL_IMAGE_SWIR\"]\n                )\n                .replace(\".XML\", \".TIF\")\n                .replace(\".xml\", \".tif\")\n            )\n        else:\n            assert (\n                \"METADATA\" in self.xml_file\n            ), f\"Invalid SWIR file path {self.xml_file} must contain METADATA if not by folder\"\n            self.swir_file = (\n                self.xml_file.replace(\"METADATA\", \"SPECTRAL_IMAGE_SWIR\")\n                .replace(\".XML\", \".TIF\")\n                .replace(\".xml\", \".tif\")\n            )\n\n        if not self.swir_file.endswith(\".tif\") and not self.swir_file.endswith(\".TIF\"):\n            raise ValueError(\n                f\"Invalid SWIR file path {self.swir_file} must be a TIF file\"\n            )\n\n        if self.xml_file.startswith(\"gs://\") or self.xml_file.startswith(\"az://\"):\n            assert fs is not None, \"Filesystem must be provided if using cloud storage\"\n            self.fs = fs\n            assert fs.exists(self.xml_file), f\"File {self.xml_file} does not exist\"\n            assert fs.exists(self.swir_file), f\"File {self.swir_file} does not exist\"\n        else:\n            self.fs = fs or fsspec.filesystem(\"file\")\n            assert os.path.exists(self.xml_file), f\"File {self.xml_file} does not exist\"\n            assert os.path.exists(\n                self.swir_file\n            ), f\"File {self.swir_file} does not exist\"\n\n        self.swir = RasterioReader(self.swir_file, window_focus=window_focus)\n\n        if self.by_folder:\n            self.vnir = RasterioReader(\n                self.swir_file.replace(\n                    PRODUCT_FOLDERS[\"SPECTRAL_IMAGE_SWIR\"],\n                    PRODUCT_FOLDERS[\"SPECTRAL_IMAGE_VNIR\"],\n                ),\n                window_focus=window_focus,\n            )\n        else:\n            self.vnir = RasterioReader(\n                self.swir_file.replace(\"SPECTRAL_IMAGE_SWIR\", \"SPECTRAL_IMAGE_VNIR\"),\n                window_focus=window_focus,\n            )\n\n        with self.fs.open(self.xml_file) as fh:\n            (\n                self.wl_center,\n                self.wl_fwhm,\n                self.hsf,\n                self.sza,\n                self.saa,\n                self.vaa,\n                self.vza,\n                self.gain_arr,\n                self.offs_arr,\n                startTime,\n                endTime,\n                self.rpcs_vnir,\n                self.rpcs_swir,\n            ) = read_xml(fh)\n\n        self.swir_range = (\n            self.wl_center[\"swir\"][0] - self.wl_fwhm[\"swir\"][0],\n            self.wl_center[\"swir\"][-1] + self.wl_fwhm[\"swir\"][-1],\n        )\n        self.vnir_range = (\n            self.wl_center[\"vnir\"][0] - self.wl_fwhm[\"vnir\"][0],\n            self.wl_center[\"vnir\"][-1] + self.wl_fwhm[\"vnir\"][-1],\n        )\n\n        self.units = \"mW/m2/sr/nm\"  # == W/m^2/SR/um\n        self.time_coverage_start = startTime\n        self.time_coverage_end = endTime\n        self._observation_date_correction_factor: Optional[float] = None\n\n    @property\n    def observation_date_correction_factor(self) -&gt; float:\n        if self._observation_date_correction_factor is None:\n            self._observation_date_correction_factor = (\n                reflectance.observation_date_correction_factor(\n                    date_of_acquisition=self.time_coverage_start,\n                    center_coords=self.footprint(\"EPSG:4326\").centroid.coords[0],\n                )\n            )\n        return self._observation_date_correction_factor\n\n    @property\n    def window_focus(self) -&gt; Optional[Window]:\n        return self.swir.window_focus\n\n    @property\n    def shape(self) -&gt; tuple:\n        return (\n            len(self.wl_center[\"vnir\"]) + len(self.wl_center[\"swir\"]),\n        ) + self.swir.shape[-2:]\n\n    @property\n    def transform(self):\n        return self.swir.transform\n\n    @property\n    def crs(self):\n        return self.swir.crs\n\n    @property\n    def res(self):\n        return self.swir.res\n\n    @property\n    def width(self):\n        return self.window_focus.width\n\n    @property\n    def height(self):\n        return self.window_focus.height\n\n    @property\n    def bounds(self):\n        return self.swir.bounds\n\n    @property\n    def fill_value_default(self):\n        return self.swir.fill_value_default\n\n    def footprint(self, crs: Optional[Any] = None) -&gt; Any:\n        return self.swir.footprint(crs=crs)\n\n    def load_product(self, product_name: str) -&gt; GeoTensor:\n        if product_name not in PRODUCT_FOLDERS:\n            raise ValueError(f\"Invalid product name: {product_name}\")\n\n        if self.by_folder:\n            folder = PRODUCT_FOLDERS[product_name]\n            product_path = self.swir_file.replace(\n                PRODUCT_FOLDERS[\"SPECTRAL_IMAGE_SWIR\"], folder\n            )\n\n            raster_product = RasterioReader(\n                product_path, window_focus=self.window_focus\n            ).load()\n        else:\n            product_path = self.swir_file.replace(\"SPECTRAL_IMAGE_SWIR\", product_name)\n            raster_product = RasterioReader(\n                product_path, window_focus=self.window_focus\n            ).load()\n\n        # Convert to radiance if SPECTRAL_IMAGE_SWIR or SPECRTAL_IMAGE_VNIR\n        if product_name == \"SPECTRAL_IMAGE_SWIR\":\n            name_coef = \"swir\"\n        elif product_name == \"SPECTRAL_IMAGE_VNIR\":\n            name_coef = \"vnir\"\n        else:\n            name_coef = None\n\n        # https://github.com/GFZ/enpt/blob/main/enpt/model/images/images_sensorgeo.py#L327\n        # L\u03bb = QCAL * GAIN + OFFSET\n        # NOTE: - DLR provides gains between 2000 and 10000, so we have to DEVIDE by gains\n        #       - DLR gains / offsets are provided in W/m2/sr/nm, so we have to multiply by 1000 to get\n        #         mW/m2/sr/nm as needed later\n        if name_coef is not None:\n            gain = self.gain_arr[name_coef]\n            offset = self.offs_arr[name_coef]\n            invalids = raster_product.values == raster_product.fill_value_default\n            raster_product.values = (\n                gain[:, np.newaxis, np.newaxis] * raster_product.values\n                + offset[:, np.newaxis, np.newaxis]\n            ) * SC_COEFF\n            raster_product.values[invalids] = self.fill_value_default\n\n        return raster_product\n\n    def load_wavelengths(\n        self,\n        wavelengths: Union[float, List[float], NDArray],\n        as_reflectance: bool = True,\n    ) -&gt; Union[GeoTensor, NDArray]:\n        \"\"\"\n        Load the reflectance of the given wavelengths\n\n        Args:\n            wavelengths (Union[float, List[float], NDArray]): List of wavelengths to load\n            as_reflectance (bool, optional): return the values as reflectance rather than radiance.\n                Defaults to True. If False values will have units of W/m^2/SR/um == mW/m2/sr/nm (`self.units`)\n\n        Returns:\n            Union[GeoTensor, NDArray]: GeoTensor with the values in reflectance or radiance units.\n\n        Raises:\n            ValueError: If any wavelength is outside the sensor's range.\n        \"\"\"\n        if isinstance(wavelengths, Number):\n            wavelengths = np.array([wavelengths])\n        else:\n            wavelengths = np.array(wavelengths)\n\n        # Check all wavelengths are within the range of the sensor\n        if any(\n            [\n                wvl &lt; self.vnir_range[0] or wvl &gt; self.swir_range[1]\n                for wvl in wavelengths\n            ]\n        ):\n            raise ValueError(\n                f\"Invalid wavelength range, must be between {self.vnir_range[0]} and {self.swir_range[1]}\"\n            )\n\n        wavelengths_loaded = []\n        fwhm = []\n        ltoa_img = []\n        for b in range(len(wavelengths)):\n            if (\n                wavelengths[b] &gt;= self.swir_range[0]\n                and wavelengths[b] &lt; self.swir_range[1]\n            ):\n                index_band = np.argmin(np.abs(wavelengths[b] - self.wl_center[\"swir\"]))\n                fwhm.append(self.wl_fwhm[\"swir\"][index_band])\n                wavelengths_loaded.append(self.wl_center[\"swir\"][index_band])\n                rst = self.swir.isel({\"band\": [index_band]}).load().squeeze()\n                invalids = (rst.values == rst.fill_value_default) | np.isnan(rst.values)\n\n                # Convert to radiance\n                gain = self.gain_arr[\"swir\"][index_band]\n                offset = self.offs_arr[\"swir\"][index_band]\n                img = (gain * rst.values + offset) * SC_COEFF\n                img[invalids] = self.fill_value_default\n            else:\n                index_band = np.argmin(np.abs(wavelengths[b] - self.wl_center[\"vnir\"]))\n                fwhm.append(self.wl_fwhm[\"vnir\"][index_band])\n                wavelengths_loaded.append(self.wl_center[\"vnir\"][index_band])\n                rst = self.vnir.isel({\"band\": [index_band]}).load().squeeze()\n                invalids = (rst.values == rst.fill_value_default) | np.isnan(rst.values)\n\n                # Convert to radiance\n                gain = self.gain_arr[\"vnir\"][index_band]\n                offset = self.offs_arr[\"vnir\"][index_band]\n                img = (gain * rst.values + offset) * SC_COEFF\n                img[invalids] = self.fill_value_default\n\n            ltoa_img.append(img)\n\n        ltoa_img = GeoTensor(\n            np.stack(ltoa_img, axis=0),\n            transform=self.transform,\n            crs=self.crs,\n            fill_value_default=self.fill_value_default,\n        )\n\n        if as_reflectance:\n            thuiller = reflectance.load_thuillier_irradiance()\n            response = reflectance.srf(\n                wavelengths_loaded, fwhm, thuiller[\"Nanometer\"].values\n            )\n\n            solar_irradiance_norm = thuiller[\"Radiance(mW/m2/nm)\"].values.dot(\n                response\n            )  # mW/m$^2$/SR/nm\n            solar_irradiance_norm /= 1_000  # W/m$^2$/nm\n\n            # Divide by 10 to convert from mW/m^2/SR/nm to \u00b5W /cm\u00b2/SR/nm\n            ltoa_img = reflectance.radiance_to_reflectance(\n                ltoa_img,\n                solar_irradiance_norm,\n                units=self.units,\n                observation_date_corr_factor=self.observation_date_correction_factor,\n            )\n\n        return ltoa_img\n\n    def load_rgb(\n        self,\n        as_reflectance: bool = True,\n        apply_rpcs: bool = True,\n        dst_crs: str = \"EPSG:4326\",\n        resolution_dst_crs: Optional[Union[float, Tuple[float, float]]] = None,\n    ) -&gt; GeoTensor:\n        \"\"\"\n        Load RGB image from VNIR bands. Converts radiance to TOA reflectance if as_reflectance is True\n        otherwise it will return the radiance values in W/m^2/SR/um == mW/m2/sr/nm (`self.units`)\n\n        Args:\n            as_reflectance (bool, optional): Convert radiance to TOA reflectance. Defaults to True.\n            apply_rpcs (bool, optional): Apply RPCs to the image. Defaults to True.\n            dst_crs (str, optional): Destination CRS. Defaults to \"EPSG:4326\".\n            resolution_dst_crs (Optional[Union[float, Tuple[float, float]]], optional):\n                Resolution of the destination CRS. Defaults to None.\n        Returns:\n            GeoTensor: with the RGB image\n        \"\"\"\n        rgb = self.load_wavelengths(WAVELENGTHS_RGB, as_reflectance=as_reflectance)\n        if apply_rpcs:\n            return read.read_rpcs(\n                rgb.values,\n                rpcs=self.rpcs_vnir,\n                dst_crs=dst_crs,\n                resolution_dst_crs=resolution_dst_crs,\n                fill_value_default=rgb.fill_value_default,\n            )\n        elif dst_crs is not None:\n            return read.read_to_crs(\n                rgb, resolution_dst_crs=resolution_dst_crs, dst_crs=dst_crs\n            )\n\n        return rgb\n\n    def load(self) -&gt; GeoTensor:\n        swir = self.load_product(\"SPECTRAL_IMAGE_SWIR\")\n        # vnir = self.load_product('SPECTRAL_IMAGE_VNIR')\n\n        return swir\n\n    def __repr__(self) -&gt; str:\n        return f\"\"\"\n        File: {self.xml_file}\n        Bounds: {self.bounds}\n        Time: {self.time_coverage_start}\n        Spatial shape (height, width): {self.height, self.width}\n        VNIR Range: {self.vnir_range} nbands: {len(self.wl_center['vnir'])} \n        SWIR Range: {self.swir_range} nbands: {len(self.wl_center['swir'])}\n        \"\"\"\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.enmap.EnMAP.load_rgb","title":"<code>load_rgb(as_reflectance=True, apply_rpcs=True, dst_crs='EPSG:4326', resolution_dst_crs=None)</code>","text":"<p>Load RGB image from VNIR bands. Converts radiance to TOA reflectance if as_reflectance is True otherwise it will return the radiance values in W/m^2/SR/um == mW/m2/sr/nm (<code>self.units</code>)</p> <p>Parameters:</p> Name Type Description Default <code>as_reflectance</code> <code>bool</code> <p>Convert radiance to TOA reflectance. Defaults to True.</p> <code>True</code> <code>apply_rpcs</code> <code>bool</code> <p>Apply RPCs to the image. Defaults to True.</p> <code>True</code> <code>dst_crs</code> <code>str</code> <p>Destination CRS. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>resolution_dst_crs</code> <code>Optional[Union[float, Tuple[float, float]]]</code> <p>Resolution of the destination CRS. Defaults to None.</p> <code>None</code> <p>Returns:     GeoTensor: with the RGB image</p> Source code in <code>georeader/readers/enmap.py</code> <pre><code>def load_rgb(\n    self,\n    as_reflectance: bool = True,\n    apply_rpcs: bool = True,\n    dst_crs: str = \"EPSG:4326\",\n    resolution_dst_crs: Optional[Union[float, Tuple[float, float]]] = None,\n) -&gt; GeoTensor:\n    \"\"\"\n    Load RGB image from VNIR bands. Converts radiance to TOA reflectance if as_reflectance is True\n    otherwise it will return the radiance values in W/m^2/SR/um == mW/m2/sr/nm (`self.units`)\n\n    Args:\n        as_reflectance (bool, optional): Convert radiance to TOA reflectance. Defaults to True.\n        apply_rpcs (bool, optional): Apply RPCs to the image. Defaults to True.\n        dst_crs (str, optional): Destination CRS. Defaults to \"EPSG:4326\".\n        resolution_dst_crs (Optional[Union[float, Tuple[float, float]]], optional):\n            Resolution of the destination CRS. Defaults to None.\n    Returns:\n        GeoTensor: with the RGB image\n    \"\"\"\n    rgb = self.load_wavelengths(WAVELENGTHS_RGB, as_reflectance=as_reflectance)\n    if apply_rpcs:\n        return read.read_rpcs(\n            rgb.values,\n            rpcs=self.rpcs_vnir,\n            dst_crs=dst_crs,\n            resolution_dst_crs=resolution_dst_crs,\n            fill_value_default=rgb.fill_value_default,\n        )\n    elif dst_crs is not None:\n        return read.read_to_crs(\n            rgb, resolution_dst_crs=resolution_dst_crs, dst_crs=dst_crs\n        )\n\n    return rgb\n</code></pre>"},{"location":"modules/readers_module/#georeader.readers.enmap.EnMAP.load_wavelengths","title":"<code>load_wavelengths(wavelengths, as_reflectance=True)</code>","text":"<p>Load the reflectance of the given wavelengths</p> <p>Parameters:</p> Name Type Description Default <code>wavelengths</code> <code>Union[float, List[float], NDArray]</code> <p>List of wavelengths to load</p> required <code>as_reflectance</code> <code>bool</code> <p>return the values as reflectance rather than radiance. Defaults to True. If False values will have units of W/m^2/SR/um == mW/m2/sr/nm (<code>self.units</code>)</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, NDArray]</code> <p>Union[GeoTensor, NDArray]: GeoTensor with the values in reflectance or radiance units.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any wavelength is outside the sensor's range.</p> Source code in <code>georeader/readers/enmap.py</code> <pre><code>def load_wavelengths(\n    self,\n    wavelengths: Union[float, List[float], NDArray],\n    as_reflectance: bool = True,\n) -&gt; Union[GeoTensor, NDArray]:\n    \"\"\"\n    Load the reflectance of the given wavelengths\n\n    Args:\n        wavelengths (Union[float, List[float], NDArray]): List of wavelengths to load\n        as_reflectance (bool, optional): return the values as reflectance rather than radiance.\n            Defaults to True. If False values will have units of W/m^2/SR/um == mW/m2/sr/nm (`self.units`)\n\n    Returns:\n        Union[GeoTensor, NDArray]: GeoTensor with the values in reflectance or radiance units.\n\n    Raises:\n        ValueError: If any wavelength is outside the sensor's range.\n    \"\"\"\n    if isinstance(wavelengths, Number):\n        wavelengths = np.array([wavelengths])\n    else:\n        wavelengths = np.array(wavelengths)\n\n    # Check all wavelengths are within the range of the sensor\n    if any(\n        [\n            wvl &lt; self.vnir_range[0] or wvl &gt; self.swir_range[1]\n            for wvl in wavelengths\n        ]\n    ):\n        raise ValueError(\n            f\"Invalid wavelength range, must be between {self.vnir_range[0]} and {self.swir_range[1]}\"\n        )\n\n    wavelengths_loaded = []\n    fwhm = []\n    ltoa_img = []\n    for b in range(len(wavelengths)):\n        if (\n            wavelengths[b] &gt;= self.swir_range[0]\n            and wavelengths[b] &lt; self.swir_range[1]\n        ):\n            index_band = np.argmin(np.abs(wavelengths[b] - self.wl_center[\"swir\"]))\n            fwhm.append(self.wl_fwhm[\"swir\"][index_band])\n            wavelengths_loaded.append(self.wl_center[\"swir\"][index_band])\n            rst = self.swir.isel({\"band\": [index_band]}).load().squeeze()\n            invalids = (rst.values == rst.fill_value_default) | np.isnan(rst.values)\n\n            # Convert to radiance\n            gain = self.gain_arr[\"swir\"][index_band]\n            offset = self.offs_arr[\"swir\"][index_band]\n            img = (gain * rst.values + offset) * SC_COEFF\n            img[invalids] = self.fill_value_default\n        else:\n            index_band = np.argmin(np.abs(wavelengths[b] - self.wl_center[\"vnir\"]))\n            fwhm.append(self.wl_fwhm[\"vnir\"][index_band])\n            wavelengths_loaded.append(self.wl_center[\"vnir\"][index_band])\n            rst = self.vnir.isel({\"band\": [index_band]}).load().squeeze()\n            invalids = (rst.values == rst.fill_value_default) | np.isnan(rst.values)\n\n            # Convert to radiance\n            gain = self.gain_arr[\"vnir\"][index_band]\n            offset = self.offs_arr[\"vnir\"][index_band]\n            img = (gain * rst.values + offset) * SC_COEFF\n            img[invalids] = self.fill_value_default\n\n        ltoa_img.append(img)\n\n    ltoa_img = GeoTensor(\n        np.stack(ltoa_img, axis=0),\n        transform=self.transform,\n        crs=self.crs,\n        fill_value_default=self.fill_value_default,\n    )\n\n    if as_reflectance:\n        thuiller = reflectance.load_thuillier_irradiance()\n        response = reflectance.srf(\n            wavelengths_loaded, fwhm, thuiller[\"Nanometer\"].values\n        )\n\n        solar_irradiance_norm = thuiller[\"Radiance(mW/m2/nm)\"].values.dot(\n            response\n        )  # mW/m$^2$/SR/nm\n        solar_irradiance_norm /= 1_000  # W/m$^2$/nm\n\n        # Divide by 10 to convert from mW/m^2/SR/nm to \u00b5W /cm\u00b2/SR/nm\n        ltoa_img = reflectance.radiance_to_reflectance(\n            ltoa_img,\n            solar_irradiance_norm,\n            units=self.units,\n            observation_date_corr_factor=self.observation_date_correction_factor,\n        )\n\n    return ltoa_img\n</code></pre>"},{"location":"modules/reflectance_module/","title":"reflectance","text":""},{"location":"modules/reflectance_module/#georeader.reflectance.compute_sza","title":"<code>compute_sza(center_coords, date_of_acquisition, crs_coords=None)</code>","text":"<p>This function returns the solar zenith angle for a given location and date of acquisition.</p> <p>Parameters:</p> Name Type Description Default <code>center_coords</code> <code>Tuple[float, float]</code> <p>location being considered (x,y) (long, lat if EPSG:4326)</p> required <code>date_of_acquisition</code> <code>datetime</code> <p>date of acquisition to compute the solar zenith angles. It  is assumed to be UTC time.</p> required <code>crs_coords</code> <code>Optional[str]</code> <p>if None it will assume center_coords are in EPSG:4326. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>solar zenith angle in degrees</p> Source code in <code>georeader/reflectance.py</code> <pre><code>def compute_sza(center_coords:Tuple[float, float], date_of_acquisition:datetime, crs_coords:Optional[str]=None) -&gt; float:\n    \"\"\"\n    This function returns the solar zenith angle for a given location and date of acquisition.\n\n    Args:\n        center_coords (Tuple[float, float]): location being considered (x,y) (long, lat if EPSG:4326)\n        date_of_acquisition (datetime): date of acquisition to compute the solar zenith angles. It \n            is assumed to be UTC time.\n        crs_coords (Optional[str], optional): if None it will assume center_coords are in EPSG:4326. Defaults to None.\n\n    Returns:\n        float: solar zenith angle in degrees\n    \"\"\"\n    try:\n        from pysolar.solar import get_altitude\n    except ImportError:\n        raise ImportError(\"pysolar is required to compute the solar zenith angle. Install it with `pip install pysolar`\")\n\n    if crs_coords is not None and not window_utils.compare_crs(crs_coords, \"EPSG:4326\"):\n        from rasterio import warp\n        centers_long, centers_lat = warp.transform(crs_coords,\n                                                   {'init': 'epsg:4326'}, [center_coords[0]], [center_coords[1]])\n        centers_long = centers_long[0]\n        centers_lat = centers_lat[0]\n    else:\n        centers_long = center_coords[0]\n        centers_lat = center_coords[1]\n\n    # Get Solar Altitude (in degrees)\n    solar_altitude = get_altitude(latitude_deg=centers_lat, longitude_deg=centers_long,\n                                  when=date_of_acquisition)\n    return 90 - solar_altitude\n</code></pre>"},{"location":"modules/reflectance_module/#georeader.reflectance.earth_sun_distance_correction_factor","title":"<code>earth_sun_distance_correction_factor(date_of_acquisition)</code>","text":"<p>This function returns the Earth-sun distance correction factor given by the formula:</p> <pre><code>d = 1-0.01673*cos(0.0172*(t-4))\n\nWhere:\n0.0172 = 360/365.256363 * np.pi/180.  # (Earth orbit angular velocity)\n0.01673 is the Earth eccentricity\n\n# t is the day of the year starting in 1:\nt = datenum(Y,M,D) - datenum(Y,1,1) + 1;\n\n# tm_yday starts in 1\ndatetime.datetime.strptime(\"2022-01-01\", \"%Y-%m-%d\").timetuple().tm_yday -&gt; 1\n</code></pre> <p>In the Sentinel-2 metadata they provide <code>U</code> which is the square inverse of this factor: <code>U = 1 / d^2</code></p> <p>https://sentiwiki.copernicus.eu/web/s2-processing#S2Processing-TOAReflectanceComputation</p> <p>Parameters:</p> Name Type Description Default <code>date_of_acquisition</code> <code>datetime</code> <p>date of acquisition. The day of the year will be used  to compute the correction factor</p> required <p>Returns:</p> Type Description <code>float</code> <p>(1-0.01673cos(0.0172(t-4)))</p> Source code in <code>georeader/reflectance.py</code> <pre><code>def earth_sun_distance_correction_factor(date_of_acquisition:datetime) -&gt; float:\n    \"\"\"\n    This function returns the Earth-sun distance correction factor given by the formula:\n\n    ```\n    d = 1-0.01673*cos(0.0172*(t-4))\n\n    Where:\n    0.0172 = 360/365.256363 * np.pi/180.  # (Earth orbit angular velocity)\n    0.01673 is the Earth eccentricity\n\n    # t is the day of the year starting in 1:\n    t = datenum(Y,M,D) - datenum(Y,1,1) + 1;\n\n    # tm_yday starts in 1\n    datetime.datetime.strptime(\"2022-01-01\", \"%Y-%m-%d\").timetuple().tm_yday -&gt; 1\n\n    ```\n\n    In the Sentinel-2 metadata they provide `U` which is the square inverse of this factor: `U = 1 / d^2`\n\n    [https://sentiwiki.copernicus.eu/web/s2-processing#S2Processing-TOAReflectanceComputation](https://sentiwiki.copernicus.eu/web/s2-processing#S2Processing-TOAReflectanceComputation)\n\n    Args:\n        date_of_acquisition: date of acquisition. The day of the year will be used \n            to compute the correction factor\n\n    Returns:\n        (1-0.01673*cos(0.0172*(t-4)))\n    \"\"\"\n    tm_yday = date_of_acquisition.timetuple().tm_yday # from 1 to 365 (or 366!)\n    return 1 - 0.01673 * np.cos(0.0172 * (tm_yday - 4))\n</code></pre>"},{"location":"modules/reflectance_module/#georeader.reflectance.integrated_irradiance","title":"<code>integrated_irradiance(srf, solar_irradiance=None, epsilon_srf=0.0001)</code>","text":"<p>Returns the integrated irradiance for the given spectral response function (SRF) and solar irradiance.</p> <p>The output is the integrated irradiance for each band.</p> <p>Parameters:</p> Name Type Description Default <code>srf</code> <code>DataFrame</code> <p>dataframe with the spectral response function (SRF) (N, K) where N is the number of wavelengths and K the number of bands. The index is the wavelengths in nanometers and the columns are the bands.</p> required <code>solar_irradiance</code> <code>Optional[DataFrame]</code> <p>dataframe with the solar irradiance. It must contain the columns \"Nanometer\" and \"Radiance(mW/m2/nm)\". (D, 2)       Defaults to None. If None, it will load the Thuillier solar irradiance and the output will be in mW/m2/nm.</p> <code>None</code> <code>epsilon_srf</code> <code>float</code> <p>threshold to consider a band in the SRF. Defaults to 1e-4.</p> <code>0.0001</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>integrated irradiance (K,)</p> Source code in <code>georeader/reflectance.py</code> <pre><code>def integrated_irradiance(srf:pd.DataFrame, \n                          solar_irradiance:Optional[pd.DataFrame]=None,\n                          epsilon_srf:float=1e-4) -&gt; NDArray:\n    \"\"\"\n    Returns the integrated irradiance for the given spectral response function (SRF) and solar irradiance.\n\n    The output is the integrated irradiance for each band.\n\n    Args:\n        srf (pd.DataFrame): dataframe with the spectral response function (SRF) (N, K) where N is the number of wavelengths and K the number of bands.\n            The index is the wavelengths in nanometers and the columns are the bands.\n        solar_irradiance (Optional[pd.DataFrame], optional): dataframe with the solar irradiance. It must contain the columns \"Nanometer\" and \"Radiance(mW/m2/nm)\". (D, 2)\n                  Defaults to None. If None, it will load the Thuillier solar irradiance and the output will be in mW/m2/nm.\n        epsilon_srf (float, optional): threshold to consider a band in the SRF. Defaults to 1e-4.\n\n    Returns:\n        NDArray: integrated irradiance (K,)\n    \"\"\"\n    from scipy import interpolate\n\n    if solar_irradiance is None:\n        solar_irradiance = load_thuillier_irradiance()\n\n    anybigvalue = (srf&gt;epsilon_srf).any(axis=1)\n    srf = srf.loc[anybigvalue, :]\n\n    # Trim the solar irradiance to the min and max wavelengths\n    solar_irradiance = solar_irradiance[(solar_irradiance[\"Nanometer\"] &gt;= srf.index.min()) &amp;\\\n                                        (solar_irradiance[\"Nanometer\"] &lt;= srf.index.max())]\n\n    # interpolate srf to the solar irradiance\n    interp = interpolate.interp1d(srf.index, srf, kind=\"linear\", axis=0)\n    srf_interp = interp(solar_irradiance[\"Nanometer\"].values) # (D, K)\n\n    # integrate the product of the solar irradiance and the srf\n    return np.sum(solar_irradiance[\"Radiance(mW/m2/nm)\"].values[:, np.newaxis] * srf_interp, axis=0) / srf_interp.sum(axis=0)\n</code></pre>"},{"location":"modules/reflectance_module/#georeader.reflectance.load_thuillier_irradiance","title":"<code>load_thuillier_irradiance()</code>","text":"<p>https://oceancolor.gsfc.nasa.gov/docs/rsr/f0.txt</p> <p>G. Thuillier et al., \"The Solar Spectral Irradiance from 200 to 2400nm as      Measured by the SOLSPEC Spectrometer from the Atlas and Eureca Missions\", Solar Physics, vol. 214, no. 1, pp. 1-22, May 2003, doi: 10.1023/A:1024048429145.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas dataframe with columns: Nanometer, Radiance(mW/m2/nm)</p> Source code in <code>georeader/reflectance.py</code> <pre><code>def load_thuillier_irradiance() -&gt; pd.DataFrame:\n    \"\"\"\n    https://oceancolor.gsfc.nasa.gov/docs/rsr/f0.txt\n\n    G. Thuillier et al., \"The Solar Spectral Irradiance from 200 to 2400nm as \n        Measured by the SOLSPEC Spectrometer from the Atlas and Eureca Missions\",\n    Solar Physics, vol. 214, no. 1, pp. 1-22, May 2003, doi: 10.1023/A:1024048429145.\n\n\n    Returns:\n        pandas dataframe with columns: Nanometer, Radiance(mW/m2/nm)\n    \"\"\"\n    global THUILLIER_RADIANCE\n\n    if THUILLIER_RADIANCE is None:\n        THUILLIER_RADIANCE = pd.read_csv(pkg_resources.resource_filename(\"georeader\",\"SolarIrradiance_Thuillier.csv\"))\n\n    return THUILLIER_RADIANCE\n</code></pre>"},{"location":"modules/reflectance_module/#georeader.reflectance.observation_date_correction_factor","title":"<code>observation_date_correction_factor(center_coords, date_of_acquisition, crs_coords=None)</code>","text":"<p>This function returns the observation date correction factor given by the formula:</p> <p><code>obfactor = (pi * d^2) / cos(solarzenithangle/180*pi)</code> where:     - <code>d</code> is the Earth-sun distance correction factor. In Sentinel-2 they provide U         in the metadata which is the square inverse of this factor: <code>U = 1 / d^2</code>.         <code>d</code>is computed from the date of acquisition.     - <code>solarzenithangle</code> is obtained from the date of acquisition and location.</p> <p>Parameters:</p> Name Type Description Default <code>center_coords</code> <code>Tuple[float, float]</code> <p>location being considered (x,y) (long, lat if EPSG:4326) </p> required <code>date_of_acquisition</code> <code>datetime</code> <p>date of acquisition to compute the solar zenith angles.</p> required <code>crs_coords</code> <code>Optional[str]</code> <p>if None it will assume center_coords are in EPSG:4326</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>correction factor</p> Source code in <code>georeader/reflectance.py</code> <pre><code>def observation_date_correction_factor(center_coords:Tuple[float, float], \n                                       date_of_acquisition:datetime,\n                                       crs_coords:Optional[str]=None) -&gt; float:\n    \"\"\"\n    This function returns the observation date correction factor given by the formula:\n\n    ``\n      obfactor = (pi * d^2) / cos(solarzenithangle/180*pi)\n    ``\n    where:\n        - `d` is the Earth-sun distance correction factor. In Sentinel-2 they provide U\n            in the metadata which is the square inverse of this factor: `U = 1 / d^2`.\n            `d`is computed from the date of acquisition.\n        - `solarzenithangle` is obtained from the date of acquisition and location.\n\n    Args:\n        center_coords: location being considered (x,y) (long, lat if EPSG:4326) \n        date_of_acquisition: date of acquisition to compute the solar zenith angles.\n        crs_coords: if None it will assume center_coords are in EPSG:4326\n\n    Returns:\n        correction factor\n\n    \"\"\"\n    sza = compute_sza(center_coords, date_of_acquisition, crs_coords=crs_coords)\n    d = earth_sun_distance_correction_factor(date_of_acquisition)\n\n    return np.pi*(d**2) / np.cos(sza/180.*np.pi)\n</code></pre>"},{"location":"modules/reflectance_module/#georeader.reflectance.radiance_to_reflectance","title":"<code>radiance_to_reflectance(data, solar_irradiance, date_of_acquisition=None, center_coords=None, crs_coords=None, observation_date_corr_factor=None, units='uW/cm^2/SR/nm')</code>","text":"<p>Convert the radiance to ToA reflectance using the solar irradiance and the date of acquisition.</p> <pre><code>toaBandX = (radianceBandX  * pi * d^2) / (cos(solarzenithangle/180*pi) * solarIrradianceBandX)\ntoaBandX = (radianceBandX / solarIrradianceBandX) * observation_date_correction_factor(center_coords, date_of_acquisition)\n</code></pre> <p>ESA reference of ToA calculation</p> where <p>d = earth_sun_distance_correction_factor(date_of_acquisition) solarzenithangle = is obtained from the date of aquisition and location</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[GeoTensor, ArrayLike]</code> <p>(C, H, W) tensor with units: \u00b5W /(nm cm\u00b2 sr)     microwatts per centimeter_squared per nanometer per steradian</p> required <code>solar_irradiance</code> <code>ArrayLike</code> <p>(C,) vector units: W/m\u00b2/nm</p> required <code>date_of_acquisition</code> <code>Optional[datetime]</code> <p>date of acquisition to compute the solar zenith angles and the Earth-Sun distance correction factor.</p> <code>None</code> <code>center_coords</code> <code>Optional[Tuple[float, float]]</code> <p>location being considered to compute the solar zenith angles and the Earth-Sun distance correction factor. (x,y) (long, lat if EPSG:4326). If None, it will use the center of the image.</p> <code>None</code> <code>observation_date_corr_factor</code> <code>Optional[float]</code> <p>if None, it will be computed using the center_coords and date_of_acquisition.        </p> <code>None</code> <code>crs_coords</code> <code>Optional[str]</code> <p>if None it will assume center_coords are in <code>EPSG:4326</code>.</p> <code>None</code> <code>units</code> <code>str</code> <p>if as_reflectance is True, the units of the hyperspectral data must be provided. Defaults to None. accepted values: \"mW/m2/sr/nm\", \"W/m2/sr/nm\", \"uW/cm^2/SR/nm\"</p> <code>'uW/cm^2/SR/nm'</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, NDArray]</code> <p>GeoTensor with ToA reflectance values (C, H, W)</p> Source code in <code>georeader/reflectance.py</code> <pre><code>def radiance_to_reflectance(data:Union[GeoTensor, ArrayLike], \n                            solar_irradiance:ArrayLike,\n                            date_of_acquisition:Optional[datetime]=None,\n                            center_coords:Optional[Tuple[float, float]]=None,\n                            crs_coords:Optional[str]=None,\n                            observation_date_corr_factor:Optional[float]=None,\n                            units:str=\"uW/cm^2/SR/nm\") -&gt; Union[GeoTensor, NDArray]:\n    \"\"\"\n    Convert the radiance to ToA reflectance using the solar irradiance and the date of acquisition.\n\n    ```\n    toaBandX = (radianceBandX  * pi * d^2) / (cos(solarzenithangle/180*pi) * solarIrradianceBandX)\n    toaBandX = (radianceBandX / solarIrradianceBandX) * observation_date_correction_factor(center_coords, date_of_acquisition)\n    ```\n\n    [ESA reference of ToA calculation](https://sentiwiki.copernicus.eu/web/s2-processing#S2Processing-TOAReflectanceComputation)\n\n    where:\n        d = earth_sun_distance_correction_factor(date_of_acquisition)\n        solarzenithangle = is obtained from the date of aquisition and location\n\n    Args:\n        data:  (C, H, W) tensor with units: \u00b5W /(nm cm\u00b2 sr)\n                microwatts per centimeter_squared per nanometer per steradian\n        solar_irradiance: (C,) vector units: W/m\u00b2/nm\n        date_of_acquisition: date of acquisition to compute the solar zenith angles and the Earth-Sun distance correction factor.\n        center_coords: location being considered to compute the solar zenith angles and the Earth-Sun distance correction factor.\n            (x,y) (long, lat if EPSG:4326). If None, it will use the center of the image.\n        observation_date_corr_factor: if None, it will be computed using the center_coords and date_of_acquisition.        \n        crs_coords: if None it will assume center_coords are in `EPSG:4326`.\n        units: if as_reflectance is True, the units of the hyperspectral data must be provided. Defaults to None.\n            accepted values: \"mW/m2/sr/nm\", \"W/m2/sr/nm\", \"uW/cm^2/SR/nm\"\n\n    Returns:\n        GeoTensor with ToA reflectance values (C, H, W)\n    \"\"\"\n\n    solar_irradiance = np.array(solar_irradiance)[:, np.newaxis, np.newaxis] # (C, 1, 1)\n    assert len(data.shape) == 3, f\"Expected 3 channels found {len(data.shape)}\"\n    assert data.shape[0] == len(solar_irradiance), \\\n        f\"Different number of channels {data.shape[0]} than number of radiances {len(solar_irradiance)}\"\n\n    if units == \"mW/m2/sr/nm\":\n        factor_div = 1000\n    elif units == \"W/m2/sr/nm\":\n        factor_div = 1\n    elif units == \"uW/cm^2/SR/nm\":\n        factor_div = 100 # (10**(-6) / 1) * (1 /10**(-4))\n    else:\n        raise ValueError(f\"Units {units} not recognized must be 'mW/m2/sr/nm', 'W/m2/sr/nm', 'uW/cm^2/SR/nm'\")\n\n\n    if observation_date_corr_factor is None:\n        assert date_of_acquisition is not None, \"If observation_date_corr_factor is None, date_of_acquisition must be provided\"\n        # Get latitude and longitude of the center of image to compute the solar angle\n        if center_coords is None:\n            assert isinstance(data, GeoTensor), \"If center_coords is None, data must be a GeoTensor\"\n            center_coords = data.transform * (data.shape[-1] // 2, data.shape[-2] // 2)\n            crs_coords = data.crs\n\n        observation_date_corr_factor = observation_date_correction_factor(center_coords, date_of_acquisition, crs_coords=crs_coords)\n\n    if isinstance(data, GeoTensor):\n        data_values = data.values\n    else:\n        data_values = data\n\n    # radiances = data_values * (10**(-6) / 1) * (1 /10**(-4))\n\n    # Convert units to W/m\u00b2/sr/nm\n    radiances = data_values / factor_div\n\n    # data_toa = data.values / 100 * constant_factor / solar_irradiance\n    data_toa_reflectance = radiances * observation_date_corr_factor / solar_irradiance\n    if not  isinstance(data, GeoTensor):\n        return data_toa_reflectance\n\n    mask = data.values == data.fill_value_default\n    data_toa_reflectance[mask] = data.fill_value_default\n\n    return GeoTensor(values=data_toa_reflectance, crs=data.crs, transform=data.transform,\n                     fill_value_default=data.fill_value_default)\n</code></pre>"},{"location":"modules/reflectance_module/#georeader.reflectance.reflectance_to_radiance","title":"<code>reflectance_to_radiance(data, solar_irradiance, date_of_acquisition=None, center_coords=None, crs_coords=None, observation_date_corr_factor=None)</code>","text":"<p>Convert the ToA reflectance to radiance using the solar irradiance and the date of acquisition. The formula is:</p> <pre><code>radianceBandX = (toaBandX * solarIrradianceBandX * cos(solarzenithangle/180*pi)) / (pi * d^2)\nradianceBandX = (toaBandX * solarIrradianceBandX) / observation_date_correction_factor(center_coords, date_of_acquisition)\n</code></pre> <p>Formula for <code>observation_date_corr_factor</code>: <pre><code>    obfactor = (pi * d^2) / cos(solarzenithangle/180*pi)\n</code></pre></p> <p>ESA reference of ToA calculation </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[GeoTensor, ArrayLike]</code> <p>data to be converted (C, H, W) tensor in ToA reflectance units</p> required <code>solar_irradiance</code> <code>ArrayLike</code> <p>solar irradiance for each band (C,) in W/m\u00b2/nm</p> required <code>date_of_acquisition</code> <code>Optional[datetime]</code> <p>Date of acquisition to compute the  solar zenith angles and the Earth-Sun distance correction factor.</p> <code>None</code> <code>center_coords</code> <code>Optional[Tuple[float, float]]</code> <p>location being considered to compute  the solar zenith angles and the Earth-Sun distance correction factor.</p> <code>None</code> <code>crs_coords</code> <code>Optional[str]</code> <p>if None it will assume center_coords are in EPSG:4326.  Defaults to None.</p> <code>None</code> <code>observation_date_corr_factor</code> <code>Optional[float]</code> <p>observation date correction factor.  If provided, it will be used instead of computing it from the date of acquisition and the center coordinates.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[GeoTensor, NDArray]</code> <p>Union[GeoTensor, NDArray]: radiance (C, H, W) tensor in W/m\u00b2/nm</p> Source code in <code>georeader/reflectance.py</code> <pre><code>def reflectance_to_radiance(data:Union[GeoTensor, ArrayLike], \n                            solar_irradiance:ArrayLike,\n                            date_of_acquisition:Optional[datetime]=None,\n                            center_coords:Optional[Tuple[float, float]]=None,\n                            crs_coords:Optional[str]=None,\n                            observation_date_corr_factor:Optional[float]=None) -&gt; Union[GeoTensor, NDArray]:\n    \"\"\"\n    Convert the ToA reflectance to radiance using the solar irradiance and the date of acquisition.\n    The formula is:\n\n    ```\n    radianceBandX = (toaBandX * solarIrradianceBandX * cos(solarzenithangle/180*pi)) / (pi * d^2)\n    radianceBandX = (toaBandX * solarIrradianceBandX) / observation_date_correction_factor(center_coords, date_of_acquisition)\n    ```\n\n    Formula for `observation_date_corr_factor`:\n    ```\n        obfactor = (pi * d^2) / cos(solarzenithangle/180*pi)\n    ```\n\n    [ESA reference of ToA calculation](https://sentiwiki.copernicus.eu/web/s2-processing#S2Processing-TOAReflectanceComputation)    \n\n    Args:\n        data (Union[GeoTensor, ArrayLike]): data to be converted (C, H, W) tensor in ToA reflectance units\n        solar_irradiance (ArrayLike): solar irradiance for each band (C,) in W/m\u00b2/nm\n        date_of_acquisition (Optional[datetime], optional): Date of acquisition to compute the \n            solar zenith angles and the Earth-Sun distance correction factor.\n        center_coords (Optional[Tuple[float, float]], optional): location being considered to compute \n            the solar zenith angles and the Earth-Sun distance correction factor.\n        crs_coords (Optional[str], optional): if None it will assume center_coords are in EPSG:4326. \n            Defaults to None.\n        observation_date_corr_factor (Optional[float], optional): observation date correction factor. \n            If provided, it will be used instead of computing it from the date of acquisition and the center coordinates.\n\n    Returns:\n        Union[GeoTensor, NDArray]: radiance (C, H, W) tensor in W/m\u00b2/nm\n    \"\"\"\n    solar_irradiance = np.array(solar_irradiance)[:, np.newaxis, np.newaxis] # (C, 1, 1)\n    assert len(data.shape) == 3, f\"Expected 3 channels found {len(data.shape)}\"\n    assert data.shape[0] == len(solar_irradiance), \\\n        f\"Different number of channels {data.shape[0]} than number of radiances {len(solar_irradiance)}\"\n\n    if observation_date_corr_factor is None:\n        assert date_of_acquisition is not None, \"If observation_date_corr_factor is None, date_of_acquisition must be provided\"\n        # Get latitude and longitude of the center of image to compute the solar angle\n        if center_coords is None:\n            assert isinstance(data, GeoTensor), \"If center_coords is None, data must be a GeoTensor\"\n            center_coords = data.transform * (data.shape[-1] // 2, data.shape[-2] // 2)\n            crs_coords = data.crs\n\n        observation_date_corr_factor = observation_date_correction_factor(center_coords, \n                                                                          date_of_acquisition, \n                                                                          crs_coords=crs_coords)\n\n    if isinstance(data, GeoTensor):\n        data_values = data.values\n    else:\n        data_values = data\n\n    data_toa_reflectance = data_values\n    radiances = data_toa_reflectance / observation_date_corr_factor * solar_irradiance\n\n    if not  isinstance(data, GeoTensor):\n        return radiances\n\n    mask = data.values == data.fill_value_default\n    radiances[mask] = data.fill_value_default\n\n    return GeoTensor(values=radiances, crs=data.crs, transform=data.transform,\n                     fill_value_default=data.fill_value_default)\n</code></pre>"},{"location":"modules/reflectance_module/#georeader.reflectance.srf","title":"<code>srf(center_wavelengths, fwhm, wavelengths)</code>","text":"<p>Returns the spectral response function (SRF) for the given center wavelengths and full width half maximum (FWHM).</p> <p>Parameters:</p> Name Type Description Default <code>center_wavelengths</code> <code>array</code> <p>array with center wavelengths. (K, )</p> required <code>fwhm</code> <code>array</code> <p>array with full width half maximum (FWHM) values (K,)</p> required <code>wavelengths</code> <code>array</code> <p>array with wavelengths where the SRF is evaluated (N,)</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>np.array: normalized SRF (N, K)</p> Source code in <code>georeader/reflectance.py</code> <pre><code>def srf(center_wavelengths:ArrayLike, fwhm:ArrayLike, wavelengths:ArrayLike) -&gt; NDArray:\n    \"\"\"\n    Returns the spectral response function (SRF) for the given center wavelengths and full width half maximum (FWHM).\n\n    Args:\n        center_wavelengths (np.array): array with center wavelengths. (K, )\n        fwhm (np.array): array with full width half maximum (FWHM) values (K,)\n        wavelengths (np.array): array with wavelengths where the SRF is evaluated (N,)\n\n    Returns:\n        np.array: normalized SRF (N, K)\n    \"\"\"\n    center_wavelengths = np.array(center_wavelengths) # (K, )\n    fwhm = np.array(fwhm) # (K, )\n    assert center_wavelengths.shape == fwhm.shape, f\"Center wavelengths and FWHM must have the same shape {center_wavelengths.shape} != {fwhm.shape}\"\n\n    sigma = fwhm / (2.0 * np.sqrt(2.0 * np.log(2.0))) # (K, )\n    var = sigma ** 2 # (K, )\n    denom = (2 * np.pi * var) ** 0.5 # (K, )\n    numer = np.exp(-(wavelengths[:, None] - center_wavelengths[None, :])**2 / (2*var)) # (N, K)\n    response = numer / denom # (N, K)\n\n    # Normalize each gaussian response to sum to 1.\n    response = np.divide(response, response.sum(axis=0), where=response.sum(axis=0) &gt; 0)# (N, K)\n    return response\n</code></pre>"},{"location":"modules/reflectance_module/#georeader.reflectance.transform_to_srf","title":"<code>transform_to_srf(hyperspectral_data, srf, wavelengths_hyperspectral, as_reflectance=False, solar_irradiance_bands=None, observation_date_corr_factor=None, center_coords=None, date_of_acquisition=None, resolution_dst=None, fill_value_default=0.0, sigma_bands=None, verbose=False, epsilon_srf=0.0001, extrapolate=False, units=None)</code>","text":"<p>Integrates the hyperspectral bands to the multispectral bands using the spectral response function (SRF).</p> <p>Parameters:</p> Name Type Description Default <code>hyperspectral_data</code> <code>Union[GeoData, NDArray]</code> <p>hyperspectral data (B, H, W) or GeoData. If as_reflectance is True, the data must be radiance and units must be filled in.</p> required <code>srf</code> <code>DataFrame</code> <p>spectral response function (SRF) (N, K). The index is the wavelengths and the columns are the bands.</p> required <code>wavelengths_hyperspectral</code> <code>List[float]</code> <p>wavelengths of the hyperspectral data (B,)</p> required <code>as_reflectance</code> <code>bool</code> <p>if True, the hyperspectral data will be converted to reflectance after integrating. Defaults to False.</p> <code>False</code> <code>solar_irradiance_bands</code> <code>Optional[NDArray]</code> <p>solar irradiance for each band to be used for the conversion to reflectance (K,).  Defaults to None. Must be provided in W/m\u00b2/nm.</p> <code>None</code> <code>observation_date_corr_factor</code> <code>Optional[float]</code> <p>observation date correction factor. Defaults to None.  Only used if as_reflectance is True.</p> <code>None</code> <code>center_coords</code> <code>Optional[Tuple[float, float]]</code> <p>center coordinates of the image. Defaults to None.  Only used if as_reflectance is True and observation_date_corr_factor is None.</p> <code>None</code> <code>date_of_acquisition</code> <code>Optional[datetime]</code> <p>date of acquisition. Defaults to None. Only used if as_reflectance is True and observation_date_corr_factor is None.</p> <code>None</code> <code>resolution_dst</code> <code>Optional[Union[float, Tuple[float, float]]]</code> <p>output resolution of the multispectral data. Defaults to None.  If None, the output will have the same resolution as the input hyperspectral data.</p> <code>None</code> <code>fill_value_default</code> <code>float</code> <p>fill value for missing data. Defaults to 0.</p> <code>0.0</code> <code>sigma_bands</code> <code>Optional[array]</code> <p>sigma for the anti-aliasing filter. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>print progress. Defaults to False.</p> <code>False</code> <code>epsilon_srf</code> <code>float</code> <p>threshold to consider a band in the SRF. Defaults to 1e-4.</p> <code>0.0001</code> <code>extrapolate</code> <code>bool</code> <p>if True, it will extrapolate the SRF to the hyperspectral wavelengths. Defaults to False.</p> <code>False</code> <code>units</code> <code>Optional[str]</code> <p>if as_reflectance is True, the units of the hyperspectral data must be provided. Defaults to None. accepted values: \"mW/m2/sr/nm\", \"W/m2/sr/nm\", \"uW/cm^2/SR/nm\"</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[GeoData, NDArray]</code> <p>Union[GeoData, NDArray]: multispectral data (C, H, W) or GeoData</p> Source code in <code>georeader/reflectance.py</code> <pre><code>def transform_to_srf(hyperspectral_data:Union[GeoData, NDArray], \n                     srf:pd.DataFrame,\n                     wavelengths_hyperspectral:List[float],\n                     as_reflectance:bool=False,\n                     solar_irradiance_bands:Optional[NDArray]=None,\n                     observation_date_corr_factor:Optional[float]=None,\n                     center_coords:Optional[Tuple[float, float]]=None,\n                     date_of_acquisition:Optional[datetime]=None,\n                     resolution_dst:Optional[Union[float,Tuple[float,float]]]=None,\n                     fill_value_default:float=0.,\n                     sigma_bands:Optional[np.array]=None,\n                     verbose:bool=False,\n                     epsilon_srf:float=1e-4,\n                     extrapolate:bool=False,\n                     units:Optional[str]=None) -&gt; Union[GeoData, NDArray]:\n    \"\"\"\n    Integrates the hyperspectral bands to the multispectral bands using the spectral response function (SRF).\n\n    Args:\n        hyperspectral_data (Union[GeoData, NDArray]): hyperspectral data (B, H, W) or GeoData. If as_reflectance is True, the data must be radiance\n            and units must be filled in.\n        srf (pd.DataFrame): spectral response function (SRF) (N, K). The index is the wavelengths and the columns are the bands.\n        wavelengths_hyperspectral (List[float]): wavelengths of the hyperspectral data (B,)\n        as_reflectance (bool, optional): if True, the hyperspectral data will be converted to reflectance after integrating. Defaults to False.\n        solar_irradiance_bands (Optional[NDArray], optional): solar irradiance for each band to be used for the conversion to reflectance (K,). \n            Defaults to None. Must be provided in W/m\u00b2/nm.\n        observation_date_corr_factor (Optional[float], optional): observation date correction factor. Defaults to None. \n            Only used if as_reflectance is True.\n        center_coords (Optional[Tuple[float, float]], optional): center coordinates of the image. Defaults to None. \n            Only used if as_reflectance is True and observation_date_corr_factor is None.\n        date_of_acquisition (Optional[datetime], optional): date of acquisition. Defaults to None.\n            Only used if as_reflectance is True and observation_date_corr_factor is None.\n        resolution_dst (Optional[Union[float,Tuple[float,float]]], optional): output resolution of the multispectral data. Defaults to None. \n            If None, the output will have the same resolution as the input hyperspectral data.\n        fill_value_default (float, optional): fill value for missing data. Defaults to 0.\n        sigma_bands (Optional[np.array], optional): sigma for the anti-aliasing filter. Defaults to None.\n        verbose (bool, optional): print progress. Defaults to False.\n        epsilon_srf (float, optional): threshold to consider a band in the SRF. Defaults to 1e-4.\n        extrapolate (bool, optional): if True, it will extrapolate the SRF to the hyperspectral wavelengths. Defaults to False.\n        units: if as_reflectance is True, the units of the hyperspectral data must be provided. Defaults to None.\n            accepted values: \"mW/m2/sr/nm\", \"W/m2/sr/nm\", \"uW/cm^2/SR/nm\"\n\n    Returns:\n        Union[GeoData, NDArray]: multispectral data (C, H, W) or GeoData\n    \"\"\"\n    from scipy import interpolate\n\n    assert hyperspectral_data.shape[0] == len(wavelengths_hyperspectral), f\"Different number of bands {hyperspectral_data.shape[0]} and band frequency centers {len(wavelengths_hyperspectral)}\"\n\n    anybigvalue = (srf&gt;epsilon_srf).any(axis=1)\n    srf = srf.loc[anybigvalue, :]    \n    bands = srf.columns\n\n    if as_reflectance:\n        assert units is not None, \"If as_reflectance is True, the units of the hyperspectral data must be specified\"\n        # check observation_date_corr_factor\n        if observation_date_corr_factor is None:\n            assert date_of_acquisition is not None, \"If observation_date_corr_factor is None, date_of_acquisition must be provided\"\n            if center_coords is None:\n                assert isinstance(hyperspectral_data, GeoTensor), \"If center_coords is None, data must be a GeoTensor\"\n                center_coords = hyperspectral_data.transform * (hyperspectral_data.shape[-1] // 2, hyperspectral_data.shape[-2] // 2)\n                crs_coords = hyperspectral_data.crs\n            else:\n                crs_coords = None\n\n            observation_date_corr_factor = observation_date_correction_factor(center_coords, date_of_acquisition,crs_coords=crs_coords)\n\n        if solar_irradiance_bands is None:\n            solar_irradiance_bands = integrated_irradiance(srf, epsilon_srf=epsilon_srf)\n            solar_irradiance_bands/=1_000\n\n    # Construct hyperspectral frequencies in the same resolution as srf\n    bands_index_hyperspectral = np.arange(0, len(wavelengths_hyperspectral))\n    interp = interpolate.interp1d(wavelengths_hyperspectral, bands_index_hyperspectral, kind=\"nearest\",\n                                  fill_value=\"extrapolate\" if extrapolate else np.nan)\n    y_nearest = interp(srf.index).astype(int)\n    table_hyperspectral_as_srf_multispectral = pd.DataFrame({\"SR_WL\": srf.index, \"band\": y_nearest})\n    table_hyperspectral_as_srf_multispectral = table_hyperspectral_as_srf_multispectral.set_index(\"SR_WL\")\n\n    output_array_spectral = np.full((len(bands),) + hyperspectral_data.shape[-2:],\n                                    fill_value=fill_value_default, dtype=np.float32)\n\n    for i,column_name in enumerate(bands):\n        if verbose:\n            print(f\"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}({i}/{len(bands)}) Processing band {column_name}\")\n        mask_zero = srf[column_name] &lt;= epsilon_srf\n        weight_per_wavelength = srf.loc[~mask_zero, [column_name]].copy()\n\n        assert weight_per_wavelength.shape[0] &gt;= 0, f\"No weights found! {weight_per_wavelength}\"\n\n        # Join with table of previous chunk\n        weight_per_wavelength = weight_per_wavelength.join(table_hyperspectral_as_srf_multispectral)\n\n        assert weight_per_wavelength.shape[0] &gt;= 0, \"No weights found!\"\n\n        # Normalize the SRF to sum one\n        column_name_norm = f\"{column_name}_norm\"\n        weight_per_wavelength[column_name_norm] = weight_per_wavelength[column_name] / weight_per_wavelength[\n            column_name].sum()\n        weight_per_hyperspectral_band = weight_per_wavelength.groupby(\"band\")[[column_name_norm]].sum()\n\n        indexes_read = weight_per_hyperspectral_band.index.tolist()\n\n        # Load bands of hyperspectral image\n        if verbose:\n            print(f\"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\t Loading {len(weight_per_hyperspectral_band.index)} bands\")\n            # print(\"these ones:\", weight_per_aviris_band.index)\n\n        if hasattr(hyperspectral_data, \"isel\"):\n            hyperspectral_multispectral_band_i_values = hyperspectral_data.isel({\"band\":indexes_read}).load().values\n\n            missing_values = np.any(hyperspectral_multispectral_band_i_values == hyperspectral_data.fill_value_default, axis=0)\n            if not np.any(missing_values):\n                missing_values = None\n        else:\n            hyperspectral_multispectral_band_i_values = hyperspectral_data[indexes_read]\n            missing_values = None\n\n        # hyperspectral_multispectral_band_i = hyperspectral_data.isel({\"band\": weight_per_hyperspectral_band.index}).load()\n        if verbose:\n            print(f\"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\t bands loaded, computing tensor\")\n\n\n        output_array_spectral[i] = np.sum(weight_per_hyperspectral_band[column_name_norm].values[:, np.newaxis,\n                                          np.newaxis] * hyperspectral_multispectral_band_i_values,\n                                          axis=0)\n\n        if as_reflectance:\n            output_array_spectral[i:(i+1)] = radiance_to_reflectance(output_array_spectral[i:(i+1)],\n                                                                     solar_irradiance_bands[i:(i+1)],\n                                                                     observation_date_corr_factor=observation_date_corr_factor,\n                                                                     units=units)\n\n        if missing_values is not None:\n            output_array_spectral[i][missing_values] = fill_value_default\n\n    if hasattr(hyperspectral_data, \"load\"):\n        geotensor_spectral = GeoTensor(output_array_spectral, transform=hyperspectral_data.transform,\n                                       crs=hyperspectral_data.crs,\n                                       fill_value_default=fill_value_default)\n\n        if (resolution_dst is None) or (resolution_dst == geotensor_spectral.res):\n            return geotensor_spectral\n\n        if isinstance(resolution_dst, numbers.Number):\n            resolution_dst = (abs(resolution_dst), abs(resolution_dst))\n\n\n        return read.resize(geotensor_spectral, resolution_dst=resolution_dst,\n                           anti_aliasing=True, anti_aliasing_sigma=sigma_bands)\n    else:\n        return output_array_spectral\n</code></pre>"},{"location":"modules/save_module/","title":"save","text":""},{"location":"modules/save_module/#georeader.save.save_cog","title":"<code>save_cog(data_save, path_tiff_save, profile=None, descriptions=None, tags=None, dir_tmpfiles='.', fs=None)</code>","text":"<p>Save data GeoData object as cloud optimized GeoTIFF</p> <p>Parameters:</p> Name Type Description Default <code>data_save</code> <code>GeoData</code> <p>GeoData (C, H, W) format with geoinformation (crs and transform).</p> required <code>descriptions</code> <code>Optional[List[str]]</code> <p>name of the bands</p> <code>None</code> <code>path_tiff_save</code> <code>str</code> <p>path to save the COG GeoTIFF</p> required <code>profile</code> <code>Optional[Dict[str, Any]]</code> <p>profile dict to save the data. crs and transform will be updated from data_save.</p> <code>None</code> <code>tags</code> <code>Optional[Dict[str, Any]]</code> <p>Dict to save as tags of the image</p> <code>None</code> <code>dir_tmpfiles</code> <code>str</code> <p>dir to create tempfiles if needed</p> <code>'.'</code> <code>fs</code> <code>Optional[Any]</code> <p>fsspec filesystem to save the file</p> <code>None</code> <p>Examples:</p> <p>img = np.random.randn(4,256,256) transform = rasterio.Affine(10, 0, 799980.0, 0, -10, 1900020.0) data = GeoTensor(img, crs=\"EPSG:32644\", transform=transform) save_cog(data, \"example.tif\", descriptions=[\"band1\", \"band2\", \"band3\", \"band4\"])</p> Source code in <code>georeader/save.py</code> <pre><code>def save_cog(data_save:GeoData, path_tiff_save:str,\n             profile:Optional[Dict[str, Any]]=None,\n             descriptions:Optional[List[str]] = None, \n             tags:Optional[Dict[str, Any]]=None,\n             dir_tmpfiles:str=\".\",\n             fs:Optional[Any]=None) -&gt; None:\n    \"\"\"\n    Save data GeoData object as cloud optimized GeoTIFF\n\n    Args:\n        data_save: GeoData (C, H, W) format with geoinformation (crs and transform).\n        descriptions: name of the bands\n        path_tiff_save: path to save the COG GeoTIFF\n        profile: profile dict to save the data. crs and transform will be updated from data_save.\n        tags: Dict to save as tags of the image\n        dir_tmpfiles: dir to create tempfiles if needed\n        fs: fsspec filesystem to save the file\n\n\n    Examples:\n        &gt;&gt; img = np.random.randn(4,256,256)\n        &gt;&gt; transform = rasterio.Affine(10, 0, 799980.0, 0, -10, 1900020.0)\n        &gt;&gt; data = GeoTensor(img, crs=\"EPSG:32644\", transform=transform)\n        &gt;&gt; save_cog(data, \"example.tif\", descriptions=[\"band1\", \"band2\", \"band3\", \"band4\"])\n\n    \"\"\"\n    if profile is None:\n        profile = {\n            \"compress\": \"lzw\",\n            \"RESAMPLING\": \"CUBICSPLINE\",  # for pyramids\n        }\n    if len(data_save.shape) == 3:\n        np_data = np.asanyarray(data_save.values)\n    elif len(data_save.shape) == 2:\n        np_data = np.asanyarray(data_save.values[np.newaxis])\n    else:\n        raise NotImplementedError(f\"Expected data with 2 or 3 dimensions found: {data_save.shape}\")\n\n    profile[\"crs\"] = data_save.crs\n    profile[\"transform\"] = data_save.transform\n\n    if \"nodata\" not in profile:\n        profile[\"nodata\"] = data_save.fill_value_default\n\n    _save_cog(np_data,\n              path_tiff_save, profile, descriptions=descriptions,\n              tags=tags, dir_tmpfiles=dir_tmpfiles, fs=fs)\n</code></pre>"},{"location":"modules/save_module/#georeader.save.save_tiled_geotiff","title":"<code>save_tiled_geotiff(data_save, path_tiff_save, profile_arg=None, descriptions=None, tags=None, dir_tmpfiles='.', blocksize=BLOCKSIZE_DEFAULT, fs=None)</code>","text":"<p>Save data GeoData object as tiled GeoTIFF (see <code>save_cog</code> to save as a Cloud Optimized GeoTIFF)</p> <p>Parameters:</p> Name Type Description Default <code>data_save</code> <code>GeoData</code> <p>GeoData (C, H, W) format with geoinformation (crs and transform).</p> required <code>path_tiff_save</code> <code>str</code> <p>path to save the GeoTIFF</p> required <code>profile_arg</code> <code>Optional[Dict[str, Any]]</code> <p>profile dict to save the data. crs and transform will be updated from data_save.</p> <code>None</code> <code>descriptions</code> <code>Optional[List[str]]</code> <p>name of the bands</p> <code>None</code> <code>profile</code> <p>profile dict to save the data. crs and transform will be updated from data_save.</p> required <code>tags</code> <code>Optional[Dict[str, Any]]</code> <p>Dict to save as tags of the image</p> <code>None</code> <code>dir_tmpfiles</code> <code>str</code> <p>dir to create tempfiles if needed</p> <code>'.'</code> <code>blocksize</code> <code>int</code> <p>blocksize of the GeoTIFF</p> <code>BLOCKSIZE_DEFAULT</code> <code>fs</code> <code>Optional[Any]</code> <p>fsspec filesystem to save the file</p> <code>None</code> Source code in <code>georeader/save.py</code> <pre><code>def save_tiled_geotiff(data_save:GeoData, path_tiff_save:str,\n                       profile_arg:Optional[Dict[str, Any]]=None,\n                       descriptions:Optional[List[str]] = None,\n                       tags:Optional[Dict[str, Any]]=None,\n                       dir_tmpfiles:str=\".\",\n                       blocksize:int=BLOCKSIZE_DEFAULT,\n                       fs:Optional[Any]=None) -&gt; None:\n    \"\"\"\n    Save data GeoData object as tiled GeoTIFF (see `save_cog` to save as a Cloud Optimized GeoTIFF)\n\n    Args:\n        data_save: GeoData (C, H, W) format with geoinformation (crs and transform).\n        path_tiff_save: path to save the GeoTIFF\n        profile_arg: profile dict to save the data. crs and transform will be updated from data_save.\n        descriptions: name of the bands\n        profile: profile dict to save the data. crs and transform will be updated from data_save.\n        tags: Dict to save as tags of the image\n        dir_tmpfiles: dir to create tempfiles if needed\n        blocksize: blocksize of the GeoTIFF\n        fs: fsspec filesystem to save the file\n\n    \"\"\"\n    profile = PROFILE_TILED_GEOTIFF_DEFAULT.copy()\n    profile.update({\"blockxsize\": blocksize, \"blockysize\": blocksize})\n    if profile_arg is not None:\n        profile.update(profile_arg)\n\n    if len(data_save.shape) == 3:\n        out_np = np.asanyarray(data_save.values)\n    elif len(data_save.shape) == 2:\n        out_np = np.asanyarray(data_save.values[np.newaxis])\n    else:\n        raise NotImplementedError(f\"Expected data with 2 or 3 dimensions found: {data_save.shape}\")\n\n    profile[\"crs\"] = data_save.crs\n    profile[\"transform\"] = data_save.transform\n\n    if \"nodata\" not in profile:\n        profile[\"nodata\"] = data_save.fill_value_default\n\n    if descriptions is not None:\n        assert len(descriptions) == out_np.shape[0], f\"Unexpected band descriptions {len(descriptions)} expected {out_np.shape[0]}\"\n\n    # Set count, height, width\n    for idx, c in enumerate([\"count\", \"height\", \"width\"]):\n        if c in profile:\n            assert profile[c] == out_np.shape[idx], f\"Unexpected shape: {profile[c]} {out_np.shape}\"\n        else:\n            profile[c] = out_np.shape[idx]\n\n    if \"dtype\" not in profile:\n        profile[\"dtype\"] = str(out_np.dtype)\n\n    # check blocksize\n    for idx, b in enumerate([\"blockysize\", \"blockxsize\"]):\n        if b in profile:\n            profile[b] = min(profile[b], out_np.shape[idx + 1])\n\n    if (out_np.shape[1] &gt; profile[\"blockysize\"]) or (out_np.shape[2] &gt; profile[\"blockxsize\"]):\n        profile[\"tiled\"] = True\n\n    profile[\"driver\"] = \"GTiff\"\n    is_remote_file = any((path_tiff_save.startswith(ext) for ext in REMOTE_FILE_EXTENSIONS))\n\n    # Create a tempfile if is a remote file\n    if is_remote_file:\n        with tempfile.NamedTemporaryFile(dir=dir_tmpfiles, suffix=\".tif\", delete=True) as fileobj:\n            name_save = fileobj.name\n    else:\n        name_save = path_tiff_save\n\n    with rasterio.open(name_save, \"w\", **profile) as rst_out:\n        if tags is not None:\n            rst_out.update_tags(**tags)\n        rst_out.write(out_np)\n        if descriptions is not None:\n            for i in range(1, out_np.shape[0] + 1):\n                rst_out.set_band_description(i, descriptions[i - 1])\n\n    if is_remote_file:\n        if fs is None:\n            import fsspec\n            fs = fsspec.filesystem(path_tiff_save.split(\":\")[0])\n\n        if not os.path.exists(name_save):\n            raise FileNotFoundError(f\"File {name_save} have not been created\")\n\n        fs.put_file(name_save, path_tiff_save, overwrite=True)\n        if os.path.exists(name_save):\n            os.remove(name_save)\n</code></pre>"},{"location":"modules/vectorize_module/","title":"vectorize","text":""},{"location":"modules/vectorize_module/#georeader.vectorize.get_polygons","title":"<code>get_polygons(binary_mask, min_area=25.5, polygon_buffer=0, tolerance=1.0, transform=None)</code>","text":"<p>Vectorize the polygons of the provided binary_mask.</p> <p>Parameters:</p> Name Type Description Default <code>binary_mask</code> <code>Union[ndarray, GeoData]</code> <p>(H, W) binary mask to rasterise</p> required <code>min_area</code> <code>float</code> <p>polygons with pixel area lower than this will be filtered</p> <code>25.5</code> <code>polygon_buffer</code> <code>int</code> <p>buffering of the polygons</p> <code>0</code> <code>tolerance</code> <code>float</code> <p>to simplify the polygons</p> <code>1.0</code> <code>transform</code> <code>Optional[Affine]</code> <p>affine transformation of the binary_water_mask raster. It will be used only if binary mask is        numpy array.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Polygon]</code> <p>list of vectorized polygons</p> Source code in <code>georeader/vectorize.py</code> <pre><code>def get_polygons(binary_mask: Union[np.ndarray, GeoData], min_area:float=25.5,\n                 polygon_buffer:int=0, tolerance:float=1., transform: Optional[rasterio.Affine]=None) -&gt; List[Polygon]:\n    \"\"\"\n    Vectorize the polygons of the provided binary_mask.\n\n    Args:\n        binary_mask: (H, W) binary mask to rasterise\n        min_area: polygons with pixel area lower than this will be filtered\n        polygon_buffer: buffering of the polygons\n        tolerance: to simplify the polygons\n        transform: affine transformation of the binary_water_mask raster. It will be used only if binary mask is \n                  numpy array.\n\n    Returns:\n        list of vectorized polygons\n\n    \"\"\"\n\n    if isinstance(binary_mask, np.ndarray):\n        binary_mask_np = binary_mask\n    else:\n        binary_mask_np = binary_mask.values\n\n        assert transform is None, \"transform only must be used if input is np.ndarray\"\n        transform = binary_mask.transform\n\n    shape_ = binary_mask_np.shape\n    if len(shape_) != 2:\n        binary_mask_np.squeeze()\n\n    assert len(binary_mask_np.shape) == 2, f\"Expected mask with 2 dim found {binary_mask_np.shape}\"\n\n    geoms_polygons = []\n    polygon_generator = features.shapes(binary_mask_np.astype(np.int16),\n                                        binary_mask_np)\n\n    for polygon, _ in polygon_generator:\n        p = shape(polygon)\n        if polygon_buffer &gt; 0:\n            p = p.buffer(polygon_buffer)\n        if p.area &gt;= min_area:\n            p = p.simplify(tolerance=tolerance)\n            if transform is not None:\n                p = transform_polygon(p, transform) # Convert polygon to raster coordinates\n            geoms_polygons.append(p)\n\n    return geoms_polygons\n</code></pre>"},{"location":"modules/vectorize_module/#georeader.vectorize.transform_polygon","title":"<code>transform_polygon(polygon, transform, relative=False, shape_raster=None)</code>","text":"<p>Transforms a polygon from pixel coordinates to the coordinates specified by the affine transform</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>Union[Polygon, MultiPolygon]</code> <p>polygon to transform</p> required <code>transform</code> <code>Affine</code> <p>Affine transformation</p> required <code>relative</code> <code>bool</code> <p>if True, the polygon is transformed to relative coordinates (from 0 to 1)</p> <code>False</code> <code>shape_raster</code> <code>Optional[Tuple[int, int]]</code> <p>shape of the raster to which the polygon belongs. It is used only if relative is True</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Polygon, MultiPolygon]</code> <p>polygon with coordinates transformed by the affine transformation</p> Source code in <code>georeader/vectorize.py</code> <pre><code>def transform_polygon(polygon:Union[Polygon, MultiPolygon], \n                      transform: rasterio.Affine, relative:bool=False,\n                      shape_raster:Optional[Tuple[int,int]] = None) -&gt; Union[Polygon, MultiPolygon]:\n    \"\"\"\n    Transforms a polygon from pixel coordinates to the coordinates specified by the affine transform\n\n    Args:\n        polygon: polygon to transform\n        transform: Affine transformation\n        relative: if True, the polygon is transformed to relative coordinates (from 0 to 1)\n        shape_raster: shape of the raster to which the polygon belongs. It is used only if relative is True\n\n    Returns:\n        polygon with coordinates transformed by the affine transformation\n\n    \"\"\"\n    if relative:\n        assert shape_raster is not None, \"shape_raster must be provided if relative is True\"\n        transform = rasterio.Affine.scale(1/shape_raster[1], 1/shape_raster[0]) * transform\n\n    geojson_dict = mapping(polygon)\n    if geojson_dict[\"type\"] == \"Polygon\":\n        geojson_dict[\"coordinates\"] = [geojson_dict[\"coordinates\"]]\n\n    multipol_coords = []\n    for pol in geojson_dict[\"coordinates\"]:\n        pol_coords = []\n        for shell_or_holes in pol:\n            pol_out = []\n            for coords in shell_or_holes:\n                pol_out.append(transform * coords)\n\n            pol_coords.append(pol_out)\n\n        multipol_coords.append(pol_coords)\n\n    if geojson_dict[\"type\"] == \"Polygon\":\n        geojson_dict[\"coordinates\"] = multipol_coords[0]\n    else:\n        geojson_dict[\"coordinates\"] = multipol_coords\n\n    return shape(geojson_dict)\n</code></pre>"}]}